# 02 - Multi-tenancy Strategy

## Isolation Model: Shared Schema, Discriminator Column
We use a shared database and shared schema for all tenants. This ensures maximum efficiency and simplifies migrations.

## Key Mechanisms

### 1. The Discriminator: `tenant_id`
Every table that belongs to a school (Tenant) MUST contain a non-nullable `tenant_id` UUID column.
Master data (e.g., global language keys, plan definitions) does not have a `tenant_id`.

### 2. Branch Support: `branch_id`
Schools with multiple campuses use `branch_id`. Columns are optional but enforced via the policy engine where applicable.

### 3. Application-Level Enforcement
- **Middleware**: The API middleware extracts the `tenant_id` from the request (via subdomain, SchoolID header, or JWT claim).
- **Context Injection**: The `tenant_id` is injected into the Go `context.Context`.
- **Repository Safety**: Every query generated by SQLC or manual SQL MUST include `WHERE tenant_id = $1`.

### 4. Database Constraints
- **Uniqueness**: Composite unique keys must include `tenant_id`.
  - Example: `UNIQUE(tenant_id, admission_no)` or `UNIQUE(tenant_id, receipt_no)`.

### 5. Indexing Strategy
Mandatory composite indexes on:
- `(tenant_id, created_at)`: For filtering lists and audits.
- `(tenant_id, branch_id)`: For multi-branch filters.

### 6. Row Level Security (RLS)
PostgreSQL RLS will be configured as a "defense-in-depth" measure.
```sql
CREATE POLICY tenant_isolation_policy ON students
    FOR ALL
    TO authenticated_user
    USING (tenant_id = current_setting('app.current_tenant')::uuid);
```
Even if a developer forgets a `WHERE` clause in the Go code, the database will block unauthorized access.
