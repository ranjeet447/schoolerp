// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInventoryCategory = `-- name: CreateInventoryCategory :one
INSERT INTO inventory_categories (
    tenant_id, name, type, description
) VALUES (
    $1, $2, $3, $4
) RETURNING id, tenant_id, name, type, description, created_at, updated_at
`

type CreateInventoryCategoryParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	Type        string      `json:"type"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateInventoryCategory(ctx context.Context, arg CreateInventoryCategoryParams) (InventoryCategory, error) {
	row := q.db.QueryRow(ctx, createInventoryCategory,
		arg.TenantID,
		arg.Name,
		arg.Type,
		arg.Description,
	)
	var i InventoryCategory
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInventoryItem = `-- name: CreateInventoryItem :one
INSERT INTO inventory_items (
    tenant_id, category_id, name, sku, unit, reorder_level, description
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, category_id, name, sku, description, unit, reorder_level, created_at, updated_at
`

type CreateInventoryItemParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	CategoryID   pgtype.UUID `json:"category_id"`
	Name         string      `json:"name"`
	Sku          pgtype.Text `json:"sku"`
	Unit         pgtype.Text `json:"unit"`
	ReorderLevel pgtype.Int4 `json:"reorder_level"`
	Description  pgtype.Text `json:"description"`
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, createInventoryItem,
		arg.TenantID,
		arg.CategoryID,
		arg.Name,
		arg.Sku,
		arg.Unit,
		arg.ReorderLevel,
		arg.Description,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.Unit,
		&i.ReorderLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInventoryTransaction = `-- name: CreateInventoryTransaction :one
INSERT INTO inventory_transactions (
    tenant_id, item_id, type, quantity, unit_price, supplier_id, reference_id, reference_type, remarks, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tenant_id, item_id, type, quantity, unit_price, supplier_id, reference_id, reference_type, remarks, created_by, created_at
`

type CreateInventoryTransactionParams struct {
	TenantID      pgtype.UUID    `json:"tenant_id"`
	ItemID        pgtype.UUID    `json:"item_id"`
	Type          string         `json:"type"`
	Quantity      int32          `json:"quantity"`
	UnitPrice     pgtype.Numeric `json:"unit_price"`
	SupplierID    pgtype.UUID    `json:"supplier_id"`
	ReferenceID   pgtype.UUID    `json:"reference_id"`
	ReferenceType pgtype.Text    `json:"reference_type"`
	Remarks       pgtype.Text    `json:"remarks"`
	CreatedBy     pgtype.UUID    `json:"created_by"`
}

func (q *Queries) CreateInventoryTransaction(ctx context.Context, arg CreateInventoryTransactionParams) (InventoryTransaction, error) {
	row := q.db.QueryRow(ctx, createInventoryTransaction,
		arg.TenantID,
		arg.ItemID,
		arg.Type,
		arg.Quantity,
		arg.UnitPrice,
		arg.SupplierID,
		arg.ReferenceID,
		arg.ReferenceType,
		arg.Remarks,
		arg.CreatedBy,
	)
	var i InventoryTransaction
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ItemID,
		&i.Type,
		&i.Quantity,
		&i.UnitPrice,
		&i.SupplierID,
		&i.ReferenceID,
		&i.ReferenceType,
		&i.Remarks,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createSupplier = `-- name: CreateSupplier :one
INSERT INTO inventory_suppliers (
    tenant_id, name, contact_person, phone, email, address
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, name, contact_person, phone, email, address, created_at, updated_at
`

type CreateSupplierParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	Name          string      `json:"name"`
	ContactPerson pgtype.Text `json:"contact_person"`
	Phone         pgtype.Text `json:"phone"`
	Email         pgtype.Text `json:"email"`
	Address       pgtype.Text `json:"address"`
}

func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) (InventorySupplier, error) {
	row := q.db.QueryRow(ctx, createSupplier,
		arg.TenantID,
		arg.Name,
		arg.ContactPerson,
		arg.Phone,
		arg.Email,
		arg.Address,
	)
	var i InventorySupplier
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.ContactPerson,
		&i.Phone,
		&i.Email,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryItem = `-- name: GetInventoryItem :one
SELECT id, tenant_id, category_id, name, sku, description, unit, reorder_level, created_at, updated_at FROM inventory_items WHERE id = $1 AND tenant_id = $2
`

type GetInventoryItemParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetInventoryItem(ctx context.Context, arg GetInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, getInventoryItem, arg.ID, arg.TenantID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.Unit,
		&i.ReorderLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInventoryCategories = `-- name: ListInventoryCategories :many
SELECT id, tenant_id, name, type, description, created_at, updated_at FROM inventory_categories
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListInventoryCategories(ctx context.Context, tenantID pgtype.UUID) ([]InventoryCategory, error) {
	rows, err := q.db.Query(ctx, listInventoryCategories, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryCategory
	for rows.Next() {
		var i InventoryCategory
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryItems = `-- name: ListInventoryItems :many
SELECT 
    i.id, i.tenant_id, i.category_id, i.name, i.sku, i.description, i.unit, i.reorder_level, i.created_at, i.updated_at,
    c.name as category_name,
    COALESCE(SUM(s.quantity), 0)::INTEGER as current_stock
FROM inventory_items i
LEFT JOIN inventory_categories c ON i.category_id = c.id
LEFT JOIN inventory_stocks s ON i.id = s.item_id
WHERE i.tenant_id = $1
GROUP BY i.id, c.name
ORDER BY i.name
LIMIT $2 OFFSET $3
`

type ListInventoryItemsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListInventoryItemsRow struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	Name         string             `json:"name"`
	Sku          pgtype.Text        `json:"sku"`
	Description  pgtype.Text        `json:"description"`
	Unit         pgtype.Text        `json:"unit"`
	ReorderLevel pgtype.Int4        `json:"reorder_level"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	CategoryName pgtype.Text        `json:"category_name"`
	CurrentStock int32              `json:"current_stock"`
}

func (q *Queries) ListInventoryItems(ctx context.Context, arg ListInventoryItemsParams) ([]ListInventoryItemsRow, error) {
	rows, err := q.db.Query(ctx, listInventoryItems, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryItemsRow
	for rows.Next() {
		var i ListInventoryItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoryID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.Unit,
			&i.ReorderLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.CurrentStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryTransactions = `-- name: ListInventoryTransactions :many
SELECT 
    t.id, t.tenant_id, t.item_id, t.type, t.quantity, t.unit_price, t.supplier_id, t.reference_id, t.reference_type, t.remarks, t.created_by, t.created_at,
    i.name as item_name,
    u.full_name as created_by_name
FROM inventory_transactions t
JOIN inventory_items i ON t.item_id = i.id
LEFT JOIN users u ON t.created_by = u.id
WHERE t.tenant_id = $1
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListInventoryTransactionsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListInventoryTransactionsRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	ItemID        pgtype.UUID        `json:"item_id"`
	Type          string             `json:"type"`
	Quantity      int32              `json:"quantity"`
	UnitPrice     pgtype.Numeric     `json:"unit_price"`
	SupplierID    pgtype.UUID        `json:"supplier_id"`
	ReferenceID   pgtype.UUID        `json:"reference_id"`
	ReferenceType pgtype.Text        `json:"reference_type"`
	Remarks       pgtype.Text        `json:"remarks"`
	CreatedBy     pgtype.UUID        `json:"created_by"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	ItemName      string             `json:"item_name"`
	CreatedByName pgtype.Text        `json:"created_by_name"`
}

func (q *Queries) ListInventoryTransactions(ctx context.Context, arg ListInventoryTransactionsParams) ([]ListInventoryTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listInventoryTransactions, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryTransactionsRow
	for rows.Next() {
		var i ListInventoryTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ItemID,
			&i.Type,
			&i.Quantity,
			&i.UnitPrice,
			&i.SupplierID,
			&i.ReferenceID,
			&i.ReferenceType,
			&i.Remarks,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ItemName,
			&i.CreatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppliers = `-- name: ListSuppliers :many
SELECT id, tenant_id, name, contact_person, phone, email, address, created_at, updated_at FROM inventory_suppliers
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListSuppliers(ctx context.Context, tenantID pgtype.UUID) ([]InventorySupplier, error) {
	rows, err := q.db.Query(ctx, listSuppliers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventorySupplier
	for rows.Next() {
		var i InventorySupplier
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.ContactPerson,
			&i.Phone,
			&i.Email,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertStock = `-- name: UpsertStock :exec
INSERT INTO inventory_stocks (tenant_id, item_id, location, quantity)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id, item_id, location) 
DO UPDATE SET 
    quantity = inventory_stocks.quantity + $4,
    updated_at = NOW()
`

type UpsertStockParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ItemID   pgtype.UUID `json:"item_id"`
	Location pgtype.Text `json:"location"`
	Quantity int32       `json:"quantity"`
}

func (q *Queries) UpsertStock(ctx context.Context, arg UpsertStockParams) error {
	_, err := q.db.Exec(ctx, upsertStock,
		arg.TenantID,
		arg.ItemID,
		arg.Location,
		arg.Quantity,
	)
	return err
}
