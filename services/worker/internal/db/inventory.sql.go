// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInventoryCategory = `-- name: CreateInventoryCategory :one
INSERT INTO inventory_categories (
    tenant_id, name, type, description
) VALUES (
    $1, $2, $3, $4
) RETURNING id, tenant_id, name, type, description, created_at, updated_at
`

type CreateInventoryCategoryParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	Type        string      `json:"type"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateInventoryCategory(ctx context.Context, arg CreateInventoryCategoryParams) (InventoryCategory, error) {
	row := q.db.QueryRow(ctx, createInventoryCategory,
		arg.TenantID,
		arg.Name,
		arg.Type,
		arg.Description,
	)
	var i InventoryCategory
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInventoryItem = `-- name: CreateInventoryItem :one
INSERT INTO inventory_items (
    tenant_id, category_id, name, sku, unit, reorder_level, description
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, category_id, name, sku, description, unit, reorder_level, created_at, updated_at
`

type CreateInventoryItemParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	CategoryID   pgtype.UUID `json:"category_id"`
	Name         string      `json:"name"`
	Sku          pgtype.Text `json:"sku"`
	Unit         pgtype.Text `json:"unit"`
	ReorderLevel pgtype.Int4 `json:"reorder_level"`
	Description  pgtype.Text `json:"description"`
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, createInventoryItem,
		arg.TenantID,
		arg.CategoryID,
		arg.Name,
		arg.Sku,
		arg.Unit,
		arg.ReorderLevel,
		arg.Description,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.Unit,
		&i.ReorderLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInventoryTransaction = `-- name: CreateInventoryTransaction :one
INSERT INTO inventory_transactions (
    tenant_id, item_id, type, quantity, unit_price, supplier_id, reference_id, reference_type, remarks, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tenant_id, item_id, type, quantity, unit_price, supplier_id, reference_id, reference_type, remarks, created_by, created_at
`

type CreateInventoryTransactionParams struct {
	TenantID      pgtype.UUID    `json:"tenant_id"`
	ItemID        pgtype.UUID    `json:"item_id"`
	Type          string         `json:"type"`
	Quantity      int32          `json:"quantity"`
	UnitPrice     pgtype.Numeric `json:"unit_price"`
	SupplierID    pgtype.UUID    `json:"supplier_id"`
	ReferenceID   pgtype.UUID    `json:"reference_id"`
	ReferenceType pgtype.Text    `json:"reference_type"`
	Remarks       pgtype.Text    `json:"remarks"`
	CreatedBy     pgtype.UUID    `json:"created_by"`
}

func (q *Queries) CreateInventoryTransaction(ctx context.Context, arg CreateInventoryTransactionParams) (InventoryTransaction, error) {
	row := q.db.QueryRow(ctx, createInventoryTransaction,
		arg.TenantID,
		arg.ItemID,
		arg.Type,
		arg.Quantity,
		arg.UnitPrice,
		arg.SupplierID,
		arg.ReferenceID,
		arg.ReferenceType,
		arg.Remarks,
		arg.CreatedBy,
	)
	var i InventoryTransaction
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ItemID,
		&i.Type,
		&i.Quantity,
		&i.UnitPrice,
		&i.SupplierID,
		&i.ReferenceID,
		&i.ReferenceType,
		&i.Remarks,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createPurchaseOrder = `-- name: CreatePurchaseOrder :one

INSERT INTO purchase_orders (
    tenant_id, po_number, supplier_id, status, notes, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, po_number, supplier_id, status, total_amount, notes, created_by, approved_by, approved_at, received_at, created_at, updated_at
`

type CreatePurchaseOrderParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	PoNumber   string      `json:"po_number"`
	SupplierID pgtype.UUID `json:"supplier_id"`
	Status     string      `json:"status"`
	Notes      pgtype.Text `json:"notes"`
	CreatedBy  pgtype.UUID `json:"created_by"`
}

// ==================== Purchase Orders ====================
func (q *Queries) CreatePurchaseOrder(ctx context.Context, arg CreatePurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrder,
		arg.TenantID,
		arg.PoNumber,
		arg.SupplierID,
		arg.Status,
		arg.Notes,
		arg.CreatedBy,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PoNumber,
		&i.SupplierID,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.ReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPurchaseOrderItem = `-- name: CreatePurchaseOrderItem :one
INSERT INTO purchase_order_items (
    po_id, item_id, quantity, unit_price
) VALUES (
    $1, $2, $3, $4
) RETURNING id, po_id, item_id, quantity, unit_price, received_quantity, created_at
`

type CreatePurchaseOrderItemParams struct {
	PoID      pgtype.UUID    `json:"po_id"`
	ItemID    pgtype.UUID    `json:"item_id"`
	Quantity  int32          `json:"quantity"`
	UnitPrice pgtype.Numeric `json:"unit_price"`
}

func (q *Queries) CreatePurchaseOrderItem(ctx context.Context, arg CreatePurchaseOrderItemParams) (PurchaseOrderItem, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrderItem,
		arg.PoID,
		arg.ItemID,
		arg.Quantity,
		arg.UnitPrice,
	)
	var i PurchaseOrderItem
	err := row.Scan(
		&i.ID,
		&i.PoID,
		&i.ItemID,
		&i.Quantity,
		&i.UnitPrice,
		&i.ReceivedQuantity,
		&i.CreatedAt,
	)
	return i, err
}

const createSupplier = `-- name: CreateSupplier :one
INSERT INTO inventory_suppliers (
    tenant_id, name, contact_person, phone, email, address
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, name, contact_person, phone, email, address, created_at, updated_at
`

type CreateSupplierParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	Name          string      `json:"name"`
	ContactPerson pgtype.Text `json:"contact_person"`
	Phone         pgtype.Text `json:"phone"`
	Email         pgtype.Text `json:"email"`
	Address       pgtype.Text `json:"address"`
}

func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) (InventorySupplier, error) {
	row := q.db.QueryRow(ctx, createSupplier,
		arg.TenantID,
		arg.Name,
		arg.ContactPerson,
		arg.Phone,
		arg.Email,
		arg.Address,
	)
	var i InventorySupplier
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.ContactPerson,
		&i.Phone,
		&i.Email,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryItem = `-- name: GetInventoryItem :one
SELECT id, tenant_id, category_id, name, sku, description, unit, reorder_level, created_at, updated_at FROM inventory_items WHERE id = $1 AND tenant_id = $2
`

type GetInventoryItemParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetInventoryItem(ctx context.Context, arg GetInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, getInventoryItem, arg.ID, arg.TenantID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.Name,
		&i.Sku,
		&i.Description,
		&i.Unit,
		&i.ReorderLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPurchaseOrder = `-- name: GetPurchaseOrder :one
SELECT id, tenant_id, po_number, supplier_id, status, total_amount, notes, created_by, approved_by, approved_at, received_at, created_at, updated_at FROM purchase_orders WHERE id = $1 AND tenant_id = $2
`

type GetPurchaseOrderParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetPurchaseOrder(ctx context.Context, arg GetPurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, getPurchaseOrder, arg.ID, arg.TenantID)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PoNumber,
		&i.SupplierID,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.ReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInventoryCategories = `-- name: ListInventoryCategories :many
SELECT id, tenant_id, name, type, description, created_at, updated_at FROM inventory_categories
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListInventoryCategories(ctx context.Context, tenantID pgtype.UUID) ([]InventoryCategory, error) {
	rows, err := q.db.Query(ctx, listInventoryCategories, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryCategory
	for rows.Next() {
		var i InventoryCategory
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryItems = `-- name: ListInventoryItems :many
SELECT 
    i.id, i.tenant_id, i.category_id, i.name, i.sku, i.description, i.unit, i.reorder_level, i.created_at, i.updated_at,
    c.name as category_name,
    COALESCE(SUM(s.quantity), 0)::INTEGER as current_stock
FROM inventory_items i
LEFT JOIN inventory_categories c ON i.category_id = c.id
LEFT JOIN inventory_stocks s ON i.id = s.item_id
WHERE i.tenant_id = $1
GROUP BY i.id, c.name
ORDER BY i.name
LIMIT $2 OFFSET $3
`

type ListInventoryItemsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListInventoryItemsRow struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	Name         string             `json:"name"`
	Sku          pgtype.Text        `json:"sku"`
	Description  pgtype.Text        `json:"description"`
	Unit         pgtype.Text        `json:"unit"`
	ReorderLevel pgtype.Int4        `json:"reorder_level"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	CategoryName pgtype.Text        `json:"category_name"`
	CurrentStock int32              `json:"current_stock"`
}

func (q *Queries) ListInventoryItems(ctx context.Context, arg ListInventoryItemsParams) ([]ListInventoryItemsRow, error) {
	rows, err := q.db.Query(ctx, listInventoryItems, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryItemsRow
	for rows.Next() {
		var i ListInventoryItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoryID,
			&i.Name,
			&i.Sku,
			&i.Description,
			&i.Unit,
			&i.ReorderLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.CurrentStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryTransactions = `-- name: ListInventoryTransactions :many
SELECT 
    t.id, t.tenant_id, t.item_id, t.type, t.quantity, t.unit_price, t.supplier_id, t.reference_id, t.reference_type, t.remarks, t.created_by, t.created_at,
    i.name as item_name,
    u.full_name as created_by_name
FROM inventory_transactions t
JOIN inventory_items i ON t.item_id = i.id
LEFT JOIN users u ON t.created_by = u.id
WHERE t.tenant_id = $1
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListInventoryTransactionsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListInventoryTransactionsRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	ItemID        pgtype.UUID        `json:"item_id"`
	Type          string             `json:"type"`
	Quantity      int32              `json:"quantity"`
	UnitPrice     pgtype.Numeric     `json:"unit_price"`
	SupplierID    pgtype.UUID        `json:"supplier_id"`
	ReferenceID   pgtype.UUID        `json:"reference_id"`
	ReferenceType pgtype.Text        `json:"reference_type"`
	Remarks       pgtype.Text        `json:"remarks"`
	CreatedBy     pgtype.UUID        `json:"created_by"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	ItemName      string             `json:"item_name"`
	CreatedByName pgtype.Text        `json:"created_by_name"`
}

func (q *Queries) ListInventoryTransactions(ctx context.Context, arg ListInventoryTransactionsParams) ([]ListInventoryTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listInventoryTransactions, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryTransactionsRow
	for rows.Next() {
		var i ListInventoryTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ItemID,
			&i.Type,
			&i.Quantity,
			&i.UnitPrice,
			&i.SupplierID,
			&i.ReferenceID,
			&i.ReferenceType,
			&i.Remarks,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ItemName,
			&i.CreatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseOrderItems = `-- name: ListPurchaseOrderItems :many
SELECT 
    poi.id, poi.po_id, poi.item_id, poi.quantity, poi.unit_price, poi.received_quantity, poi.created_at,
    i.name as item_name,
    i.sku as item_sku
FROM purchase_order_items poi
JOIN inventory_items i ON poi.item_id = i.id
WHERE poi.po_id = $1
ORDER BY poi.created_at
`

type ListPurchaseOrderItemsRow struct {
	ID               pgtype.UUID        `json:"id"`
	PoID             pgtype.UUID        `json:"po_id"`
	ItemID           pgtype.UUID        `json:"item_id"`
	Quantity         int32              `json:"quantity"`
	UnitPrice        pgtype.Numeric     `json:"unit_price"`
	ReceivedQuantity pgtype.Int4        `json:"received_quantity"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ItemName         string             `json:"item_name"`
	ItemSku          pgtype.Text        `json:"item_sku"`
}

func (q *Queries) ListPurchaseOrderItems(ctx context.Context, poID pgtype.UUID) ([]ListPurchaseOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrderItems, poID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPurchaseOrderItemsRow
	for rows.Next() {
		var i ListPurchaseOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.PoID,
			&i.ItemID,
			&i.Quantity,
			&i.UnitPrice,
			&i.ReceivedQuantity,
			&i.CreatedAt,
			&i.ItemName,
			&i.ItemSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseOrders = `-- name: ListPurchaseOrders :many
SELECT 
    po.id, po.tenant_id, po.po_number, po.supplier_id, po.status, po.total_amount, po.notes, po.created_by, po.approved_by, po.approved_at, po.received_at, po.created_at, po.updated_at,
    s.name as supplier_name,
    u.full_name as created_by_name
FROM purchase_orders po
LEFT JOIN inventory_suppliers s ON po.supplier_id = s.id
LEFT JOIN users u ON po.created_by = u.id
WHERE po.tenant_id = $1
ORDER BY po.created_at DESC
LIMIT $2 OFFSET $3
`

type ListPurchaseOrdersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListPurchaseOrdersRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	PoNumber      string             `json:"po_number"`
	SupplierID    pgtype.UUID        `json:"supplier_id"`
	Status        string             `json:"status"`
	TotalAmount   pgtype.Numeric     `json:"total_amount"`
	Notes         pgtype.Text        `json:"notes"`
	CreatedBy     pgtype.UUID        `json:"created_by"`
	ApprovedBy    pgtype.UUID        `json:"approved_by"`
	ApprovedAt    pgtype.Timestamptz `json:"approved_at"`
	ReceivedAt    pgtype.Timestamptz `json:"received_at"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	SupplierName  pgtype.Text        `json:"supplier_name"`
	CreatedByName pgtype.Text        `json:"created_by_name"`
}

func (q *Queries) ListPurchaseOrders(ctx context.Context, arg ListPurchaseOrdersParams) ([]ListPurchaseOrdersRow, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrders, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPurchaseOrdersRow
	for rows.Next() {
		var i ListPurchaseOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.PoNumber,
			&i.SupplierID,
			&i.Status,
			&i.TotalAmount,
			&i.Notes,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.ReceivedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupplierName,
			&i.CreatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppliers = `-- name: ListSuppliers :many
SELECT id, tenant_id, name, contact_person, phone, email, address, created_at, updated_at FROM inventory_suppliers
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListSuppliers(ctx context.Context, tenantID pgtype.UUID) ([]InventorySupplier, error) {
	rows, err := q.db.Query(ctx, listSuppliers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventorySupplier
	for rows.Next() {
		var i InventorySupplier
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.ContactPerson,
			&i.Phone,
			&i.Email,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const receivePurchaseOrder = `-- name: ReceivePurchaseOrder :one
UPDATE purchase_orders
SET status = 'received', received_at = NOW(), updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, po_number, supplier_id, status, total_amount, notes, created_by, approved_by, approved_at, received_at, created_at, updated_at
`

type ReceivePurchaseOrderParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ReceivePurchaseOrder(ctx context.Context, arg ReceivePurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, receivePurchaseOrder, arg.ID, arg.TenantID)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PoNumber,
		&i.SupplierID,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.ReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePOItemReceived = `-- name: UpdatePOItemReceived :exec
UPDATE purchase_order_items
SET received_quantity = $2
WHERE id = $1
`

type UpdatePOItemReceivedParams struct {
	ID               pgtype.UUID `json:"id"`
	ReceivedQuantity pgtype.Int4 `json:"received_quantity"`
}

func (q *Queries) UpdatePOItemReceived(ctx context.Context, arg UpdatePOItemReceivedParams) error {
	_, err := q.db.Exec(ctx, updatePOItemReceived, arg.ID, arg.ReceivedQuantity)
	return err
}

const updatePurchaseOrderStatus = `-- name: UpdatePurchaseOrderStatus :one
UPDATE purchase_orders
SET status = $3, approved_by = $4, approved_at = NOW(), updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, po_number, supplier_id, status, total_amount, notes, created_by, approved_by, approved_at, received_at, created_at, updated_at
`

type UpdatePurchaseOrderStatusParams struct {
	ID         pgtype.UUID `json:"id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
	Status     string      `json:"status"`
	ApprovedBy pgtype.UUID `json:"approved_by"`
}

func (q *Queries) UpdatePurchaseOrderStatus(ctx context.Context, arg UpdatePurchaseOrderStatusParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, updatePurchaseOrderStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ApprovedBy,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PoNumber,
		&i.SupplierID,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.ReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertStock = `-- name: UpsertStock :exec
INSERT INTO inventory_stocks (tenant_id, item_id, location, quantity)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id, item_id, location) 
DO UPDATE SET 
    quantity = inventory_stocks.quantity + $4,
    updated_at = NOW()
`

type UpsertStockParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ItemID   pgtype.UUID `json:"item_id"`
	Location pgtype.Text `json:"location"`
	Quantity int32       `json:"quantity"`
}

func (q *Queries) UpsertStock(ctx context.Context, arg UpsertStockParams) error {
	_, err := q.db.Exec(ctx, upsertStock,
		arg.TenantID,
		arg.ItemID,
		arg.Location,
		arg.Quantity,
	)
	return err
}
