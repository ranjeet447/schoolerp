// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notices.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acknowledgeNotice = `-- name: AcknowledgeNotice :one
INSERT INTO notice_acks (notice_id, user_id)
VALUES ($1, $2)
ON CONFLICT (notice_id, user_id) DO UPDATE SET ack_at = NOW()
RETURNING notice_id, user_id, ack_at
`

type AcknowledgeNoticeParams struct {
	NoticeID pgtype.UUID `json:"notice_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

func (q *Queries) AcknowledgeNotice(ctx context.Context, arg AcknowledgeNoticeParams) (NoticeAck, error) {
	row := q.db.QueryRow(ctx, acknowledgeNotice, arg.NoticeID, arg.UserID)
	var i NoticeAck
	err := row.Scan(&i.NoticeID, &i.UserID, &i.AckAt)
	return i, err
}

const createNotice = `-- name: CreateNotice :one
INSERT INTO notices (tenant_id, title, body, scope, attachments, publish_at, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, tenant_id, title, body, scope, attachments, publish_at, created_by, created_at, updated_at
`

type CreateNoticeParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Scope       []byte             `json:"scope"`
	Attachments []byte             `json:"attachments"`
	PublishAt   pgtype.Timestamptz `json:"publish_at"`
	CreatedBy   pgtype.UUID        `json:"created_by"`
}

func (q *Queries) CreateNotice(ctx context.Context, arg CreateNoticeParams) (Notice, error) {
	row := q.db.QueryRow(ctx, createNotice,
		arg.TenantID,
		arg.Title,
		arg.Body,
		arg.Scope,
		arg.Attachments,
		arg.PublishAt,
		arg.CreatedBy,
	)
	var i Notice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Body,
		&i.Scope,
		&i.Attachments,
		&i.PublishAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteNotice = `-- name: DeleteNotice :exec
DELETE FROM notices
WHERE id = $1 AND tenant_id = $2
`

type DeleteNoticeParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteNotice(ctx context.Context, arg DeleteNoticeParams) error {
	_, err := q.db.Exec(ctx, deleteNotice, arg.ID, arg.TenantID)
	return err
}

const getNotice = `-- name: GetNotice :one
SELECT id, tenant_id, title, body, scope, attachments, publish_at, created_by, created_at, updated_at FROM notices
WHERE id = $1 AND tenant_id = $2
`

type GetNoticeParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetNotice(ctx context.Context, arg GetNoticeParams) (Notice, error) {
	row := q.db.QueryRow(ctx, getNotice, arg.ID, arg.TenantID)
	var i Notice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Body,
		&i.Scope,
		&i.Attachments,
		&i.PublishAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNoticeAcks = `-- name: GetNoticeAcks :many
SELECT na.notice_id, na.user_id, na.ack_at, u.full_name as user_name
FROM notice_acks na
JOIN users u ON na.user_id = u.id
WHERE na.notice_id = $1
`

type GetNoticeAcksRow struct {
	NoticeID pgtype.UUID        `json:"notice_id"`
	UserID   pgtype.UUID        `json:"user_id"`
	AckAt    pgtype.Timestamptz `json:"ack_at"`
	UserName string             `json:"user_name"`
}

func (q *Queries) GetNoticeAcks(ctx context.Context, noticeID pgtype.UUID) ([]GetNoticeAcksRow, error) {
	rows, err := q.db.Query(ctx, getNoticeAcks, noticeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNoticeAcksRow
	for rows.Next() {
		var i GetNoticeAcksRow
		if err := rows.Scan(
			&i.NoticeID,
			&i.UserID,
			&i.AckAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotices = `-- name: ListNotices :many
SELECT n.id, n.tenant_id, n.title, n.body, n.scope, n.attachments, n.publish_at, n.created_by, n.created_at, n.updated_at, u.full_name as author_name
FROM notices n
LEFT JOIN users u ON n.created_by = u.id
WHERE n.tenant_id = $1
ORDER BY n.publish_at DESC, n.created_at DESC
`

type ListNoticesRow struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Scope       []byte             `json:"scope"`
	Attachments []byte             `json:"attachments"`
	PublishAt   pgtype.Timestamptz `json:"publish_at"`
	CreatedBy   pgtype.UUID        `json:"created_by"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	AuthorName  pgtype.Text        `json:"author_name"`
}

func (q *Queries) ListNotices(ctx context.Context, tenantID pgtype.UUID) ([]ListNoticesRow, error) {
	rows, err := q.db.Query(ctx, listNotices, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNoticesRow
	for rows.Next() {
		var i ListNoticesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Body,
			&i.Scope,
			&i.Attachments,
			&i.PublishAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNoticesForParent = `-- name: ListNoticesForParent :many
SELECT n.id, n.tenant_id, n.title, n.body, n.scope, n.attachments, n.publish_at, n.created_by, n.created_at, n.updated_at, na.ack_at
FROM notices n
LEFT JOIN notice_acks na ON n.id = na.notice_id AND na.user_id = $2
WHERE n.tenant_id = $1 AND n.publish_at <= NOW()
ORDER BY n.publish_at DESC
`

type ListNoticesForParentParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type ListNoticesForParentRow struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Title       string             `json:"title"`
	Body        string             `json:"body"`
	Scope       []byte             `json:"scope"`
	Attachments []byte             `json:"attachments"`
	PublishAt   pgtype.Timestamptz `json:"publish_at"`
	CreatedBy   pgtype.UUID        `json:"created_by"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	AckAt       pgtype.Timestamptz `json:"ack_at"`
}

// Fetch notices that are published (publish_at <= NOW())
func (q *Queries) ListNoticesForParent(ctx context.Context, arg ListNoticesForParentParams) ([]ListNoticesForParentRow, error) {
	rows, err := q.db.Query(ctx, listNoticesForParent, arg.TenantID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNoticesForParentRow
	for rows.Next() {
		var i ListNoticesForParentRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Body,
			&i.Scope,
			&i.Attachments,
			&i.PublishAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AckAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
