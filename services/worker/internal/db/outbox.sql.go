// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOutboxEvent = `-- name: CreateOutboxEvent :one
INSERT INTO outbox (tenant_id, event_type, payload, process_after)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, event_type, payload, status, retry_count, error_message, process_after, created_at, processed_at
`

type CreateOutboxEventParams struct {
	TenantID     pgtype.UUID        `json:"tenant_id"`
	EventType    string             `json:"event_type"`
	Payload      []byte             `json:"payload"`
	ProcessAfter pgtype.Timestamptz `json:"process_after"`
}

func (q *Queries) CreateOutboxEvent(ctx context.Context, arg CreateOutboxEventParams) (Outbox, error) {
	row := q.db.QueryRow(ctx, createOutboxEvent,
		arg.TenantID,
		arg.EventType,
		arg.Payload,
		arg.ProcessAfter,
	)
	var i Outbox
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.ErrorMessage,
		&i.ProcessAfter,
		&i.CreatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const getPendingOutboxEvents = `-- name: GetPendingOutboxEvents :many
SELECT id, tenant_id, event_type, payload, status, retry_count, error_message, process_after, created_at, processed_at FROM outbox
WHERE (status = 'pending' OR (status = 'failed' AND retry_count < 5))
  AND process_after <= NOW()
ORDER BY process_after ASC, created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingOutboxEvents(ctx context.Context, limitCount int32) ([]Outbox, error) {
	rows, err := q.db.Query(ctx, getPendingOutboxEvents, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outbox
	for rows.Next() {
		var i Outbox
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.ErrorMessage,
			&i.ProcessAfter,
			&i.CreatedAt,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutboxEvents = `-- name: ListOutboxEvents :many
SELECT id, tenant_id, event_type, payload, status, retry_count, error_message, process_after, created_at, processed_at FROM outbox
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListOutboxEventsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListOutboxEvents(ctx context.Context, arg ListOutboxEventsParams) ([]Outbox, error) {
	rows, err := q.db.Query(ctx, listOutboxEvents, arg.TenantID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outbox
	for rows.Next() {
		var i Outbox
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.ErrorMessage,
			&i.ProcessAfter,
			&i.CreatedAt,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOutboxEventStatus = `-- name: UpdateOutboxEventStatus :exec
UPDATE outbox
SET status = $1,
    retry_count = CASE WHEN $1 = 'failed' THEN retry_count + 1 ELSE retry_count END,
    error_message = $2,
    processed_at = CASE WHEN $1 = 'completed' THEN NOW() ELSE processed_at END,
    process_after = CASE WHEN $1 = 'failed' THEN NOW() + (POWER(2, retry_count) * INTERVAL '1 minute') ELSE process_after END
WHERE id = $3
`

type UpdateOutboxEventStatusParams struct {
	Status       string      `json:"status"`
	ErrorMessage pgtype.Text `json:"error_message"`
	ID           pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateOutboxEventStatus(ctx context.Context, arg UpdateOutboxEventStatusParams) error {
	_, err := q.db.Exec(ctx, updateOutboxEventStatus, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}
