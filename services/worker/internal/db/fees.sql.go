// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: fees.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignPlanToStudent = `-- name: AssignPlanToStudent :one
INSERT INTO student_fee_plans (student_id, plan_id)
VALUES ($1, $2)
ON CONFLICT (student_id, plan_id) DO NOTHING
RETURNING student_id, plan_id, assigned_at
`

type AssignPlanToStudentParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	PlanID    pgtype.UUID `json:"plan_id"`
}

func (q *Queries) AssignPlanToStudent(ctx context.Context, arg AssignPlanToStudentParams) (StudentFeePlan, error) {
	row := q.db.QueryRow(ctx, assignPlanToStudent, arg.StudentID, arg.PlanID)
	var i StudentFeePlan
	err := row.Scan(&i.StudentID, &i.PlanID, &i.AssignedAt)
	return i, err
}

const assignScholarship = `-- name: AssignScholarship :one
INSERT INTO student_scholarships (
    tenant_id, student_id, scholarship_id, academic_year_id, approved_by
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, student_id, scholarship_id, academic_year_id, approved_by, created_at
`

type AssignScholarshipParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	StudentID      pgtype.UUID `json:"student_id"`
	ScholarshipID  pgtype.UUID `json:"scholarship_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	ApprovedBy     pgtype.UUID `json:"approved_by"`
}

func (q *Queries) AssignScholarship(ctx context.Context, arg AssignScholarshipParams) (StudentScholarship, error) {
	row := q.db.QueryRow(ctx, assignScholarship,
		arg.TenantID,
		arg.StudentID,
		arg.ScholarshipID,
		arg.AcademicYearID,
		arg.ApprovedBy,
	)
	var i StudentScholarship
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.ScholarshipID,
		&i.AcademicYearID,
		&i.ApprovedBy,
		&i.CreatedAt,
	)
	return i, err
}

const cancelReceipt = `-- name: CancelReceipt :one
UPDATE receipts
SET status = 'cancelled', cancelled_by = $2, cancellation_reason = $3, updated_at = NOW()
WHERE id = $1 AND tenant_id = $4
RETURNING id, tenant_id, receipt_number, student_id, amount_paid, payment_mode, status, cancelled_by, cancellation_reason, transaction_ref, created_by, created_at, series_id
`

type CancelReceiptParams struct {
	ID                 pgtype.UUID `json:"id"`
	CancelledBy        pgtype.UUID `json:"cancelled_by"`
	CancellationReason pgtype.Text `json:"cancellation_reason"`
	TenantID           pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CancelReceipt(ctx context.Context, arg CancelReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, cancelReceipt,
		arg.ID,
		arg.CancelledBy,
		arg.CancellationReason,
		arg.TenantID,
	)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ReceiptNumber,
		&i.StudentID,
		&i.AmountPaid,
		&i.PaymentMode,
		&i.Status,
		&i.CancelledBy,
		&i.CancellationReason,
		&i.TransactionRef,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.SeriesID,
	)
	return i, err
}

const checkPaymentEventProcessed = `-- name: CheckPaymentEventProcessed :one
SELECT EXISTS (
    SELECT 1 FROM payment_events 
    WHERE tenant_id = $1 AND gateway_event_id = $2
) as processed
`

type CheckPaymentEventProcessedParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	GatewayEventID string      `json:"gateway_event_id"`
}

func (q *Queries) CheckPaymentEventProcessed(ctx context.Context, arg CheckPaymentEventProcessedParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPaymentEventProcessed, arg.TenantID, arg.GatewayEventID)
	var processed bool
	err := row.Scan(&processed)
	return processed, err
}

const createAutoDebitMandate = `-- name: CreateAutoDebitMandate :one
INSERT INTO auto_debit_mandates (
    tenant_id, student_id, provider, mandate_ref, max_amount, status, start_date, end_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tenant_id, student_id, provider, mandate_ref, max_amount, status, start_date, end_date, created_at, updated_at
`

type CreateAutoDebitMandateParams struct {
	TenantID   pgtype.UUID    `json:"tenant_id"`
	StudentID  pgtype.UUID    `json:"student_id"`
	Provider   string         `json:"provider"`
	MandateRef string         `json:"mandate_ref"`
	MaxAmount  pgtype.Numeric `json:"max_amount"`
	Status     string         `json:"status"`
	StartDate  pgtype.Date    `json:"start_date"`
	EndDate    pgtype.Date    `json:"end_date"`
}

func (q *Queries) CreateAutoDebitMandate(ctx context.Context, arg CreateAutoDebitMandateParams) (AutoDebitMandate, error) {
	row := q.db.QueryRow(ctx, createAutoDebitMandate,
		arg.TenantID,
		arg.StudentID,
		arg.Provider,
		arg.MandateRef,
		arg.MaxAmount,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var i AutoDebitMandate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Provider,
		&i.MandateRef,
		&i.MaxAmount,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFeeHead = `-- name: CreateFeeHead :one
INSERT INTO fee_heads (tenant_id, name, type)
VALUES ($1, $2, $3)
RETURNING id, tenant_id, name, type, created_at
`

type CreateFeeHeadParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Name     string      `json:"name"`
	Type     pgtype.Text `json:"type"`
}

func (q *Queries) CreateFeeHead(ctx context.Context, arg CreateFeeHeadParams) (FeeHead, error) {
	row := q.db.QueryRow(ctx, createFeeHead, arg.TenantID, arg.Name, arg.Type)
	var i FeeHead
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const createFeePlan = `-- name: CreateFeePlan :one
INSERT INTO fee_plans (tenant_id, name, academic_year_id, total_amount)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, name, academic_year_id, total_amount, created_at
`

type CreateFeePlanParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	Name           string      `json:"name"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	TotalAmount    pgtype.Int8 `json:"total_amount"`
}

func (q *Queries) CreateFeePlan(ctx context.Context, arg CreateFeePlanParams) (FeePlan, error) {
	row := q.db.QueryRow(ctx, createFeePlan,
		arg.TenantID,
		arg.Name,
		arg.AcademicYearID,
		arg.TotalAmount,
	)
	var i FeePlan
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.AcademicYearID,
		&i.TotalAmount,
		&i.CreatedAt,
	)
	return i, err
}

const createFeePlanItem = `-- name: CreateFeePlanItem :one
INSERT INTO fee_plan_items (plan_id, head_id, amount, due_date, info)
VALUES ($1, $2, $3, $4, $5)
RETURNING plan_id, head_id, amount, due_date, info
`

type CreateFeePlanItemParams struct {
	PlanID  pgtype.UUID `json:"plan_id"`
	HeadID  pgtype.UUID `json:"head_id"`
	Amount  int64       `json:"amount"`
	DueDate pgtype.Date `json:"due_date"`
	Info    pgtype.Text `json:"info"`
}

func (q *Queries) CreateFeePlanItem(ctx context.Context, arg CreateFeePlanItemParams) (FeePlanItem, error) {
	row := q.db.QueryRow(ctx, createFeePlanItem,
		arg.PlanID,
		arg.HeadID,
		arg.Amount,
		arg.DueDate,
		arg.Info,
	)
	var i FeePlanItem
	err := row.Scan(
		&i.PlanID,
		&i.HeadID,
		&i.Amount,
		&i.DueDate,
		&i.Info,
	)
	return i, err
}

const createPaymentOrder = `-- name: CreatePaymentOrder :one
INSERT INTO payment_orders (
    tenant_id, student_id, amount, mode, status, external_ref
) VALUES (
    $1, $2, $3, $4, 'pending', $5
) RETURNING id, tenant_id, student_id, amount, mode, status, external_ref, created_at
`

type CreatePaymentOrderParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	StudentID   pgtype.UUID `json:"student_id"`
	Amount      int64       `json:"amount"`
	Mode        string      `json:"mode"`
	ExternalRef pgtype.Text `json:"external_ref"`
}

func (q *Queries) CreatePaymentOrder(ctx context.Context, arg CreatePaymentOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, createPaymentOrder,
		arg.TenantID,
		arg.StudentID,
		arg.Amount,
		arg.Mode,
		arg.ExternalRef,
	)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Amount,
		&i.Mode,
		&i.Status,
		&i.ExternalRef,
		&i.CreatedAt,
	)
	return i, err
}

const createReceipt = `-- name: CreateReceipt :one
INSERT INTO receipts (
    tenant_id, receipt_number, student_id, amount_paid, 
    payment_mode, series_id, created_by, transaction_ref
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tenant_id, receipt_number, student_id, amount_paid, payment_mode, status, cancelled_by, cancellation_reason, transaction_ref, created_by, created_at, series_id
`

type CreateReceiptParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ReceiptNumber  string      `json:"receipt_number"`
	StudentID      pgtype.UUID `json:"student_id"`
	AmountPaid     int64       `json:"amount_paid"`
	PaymentMode    string      `json:"payment_mode"`
	SeriesID       pgtype.UUID `json:"series_id"`
	CreatedBy      pgtype.UUID `json:"created_by"`
	TransactionRef pgtype.Text `json:"transaction_ref"`
}

func (q *Queries) CreateReceipt(ctx context.Context, arg CreateReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, createReceipt,
		arg.TenantID,
		arg.ReceiptNumber,
		arg.StudentID,
		arg.AmountPaid,
		arg.PaymentMode,
		arg.SeriesID,
		arg.CreatedBy,
		arg.TransactionRef,
	)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ReceiptNumber,
		&i.StudentID,
		&i.AmountPaid,
		&i.PaymentMode,
		&i.Status,
		&i.CancelledBy,
		&i.CancellationReason,
		&i.TransactionRef,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.SeriesID,
	)
	return i, err
}

const createReceiptItem = `-- name: CreateReceiptItem :one
INSERT INTO receipt_items (receipt_id, fee_head_id, amount)
VALUES ($1, $2, $3)
RETURNING id, receipt_id, fee_head_id, amount, created_at
`

type CreateReceiptItemParams struct {
	ReceiptID pgtype.UUID `json:"receipt_id"`
	FeeHeadID pgtype.UUID `json:"fee_head_id"`
	Amount    int64       `json:"amount"`
}

func (q *Queries) CreateReceiptItem(ctx context.Context, arg CreateReceiptItemParams) (ReceiptItem, error) {
	row := q.db.QueryRow(ctx, createReceiptItem, arg.ReceiptID, arg.FeeHeadID, arg.Amount)
	var i ReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.FeeHeadID,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const createReceiptSeries = `-- name: CreateReceiptSeries :one
INSERT INTO receipt_series (tenant_id, branch_id, prefix, current_number, is_active)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, branch_id, prefix, current_number, is_active, created_at, updated_at
`

type CreateReceiptSeriesParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	BranchID      pgtype.UUID `json:"branch_id"`
	Prefix        string      `json:"prefix"`
	CurrentNumber pgtype.Int4 `json:"current_number"`
	IsActive      pgtype.Bool `json:"is_active"`
}

func (q *Queries) CreateReceiptSeries(ctx context.Context, arg CreateReceiptSeriesParams) (ReceiptSeries, error) {
	row := q.db.QueryRow(ctx, createReceiptSeries,
		arg.TenantID,
		arg.BranchID,
		arg.Prefix,
		arg.CurrentNumber,
		arg.IsActive,
	)
	var i ReceiptSeries
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.Prefix,
		&i.CurrentNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRefund = `-- name: CreateRefund :one
INSERT INTO fee_refunds (tenant_id, receipt_id, amount, reason)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, receipt_id, amount, reason, status, decided_by, decided_at, created_at
`

type CreateRefundParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	ReceiptID pgtype.UUID `json:"receipt_id"`
	Amount    int64       `json:"amount"`
	Reason    pgtype.Text `json:"reason"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (FeeRefund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.TenantID,
		arg.ReceiptID,
		arg.Amount,
		arg.Reason,
	)
	var i FeeRefund
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ReceiptID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.DecidedBy,
		&i.DecidedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveGatewayConfig = `-- name: GetActiveGatewayConfig :one
SELECT id, tenant_id, provider, api_key, api_secret, webhook_secret, is_active, settings, created_at, updated_at FROM payment_gateway_configs
WHERE tenant_id = $1 AND provider = $2 AND is_active = true
`

type GetActiveGatewayConfigParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Provider string      `json:"provider"`
}

func (q *Queries) GetActiveGatewayConfig(ctx context.Context, arg GetActiveGatewayConfigParams) (PaymentGatewayConfig, error) {
	row := q.db.QueryRow(ctx, getActiveGatewayConfig, arg.TenantID, arg.Provider)
	var i PaymentGatewayConfig
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Provider,
		&i.ApiKey,
		&i.ApiSecret,
		&i.WebhookSecret,
		&i.IsActive,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveSeries = `-- name: GetActiveSeries :one
SELECT id, tenant_id, branch_id, prefix, current_number, is_active, created_at, updated_at FROM receipt_series
WHERE tenant_id = $1 AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetActiveSeries(ctx context.Context, tenantID pgtype.UUID) (ReceiptSeries, error) {
	row := q.db.QueryRow(ctx, getActiveSeries, tenantID)
	var i ReceiptSeries
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.Prefix,
		&i.CurrentNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextReceiptNumber = `-- name: GetNextReceiptNumber :one
UPDATE receipt_series
SET current_number = current_number + 1, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING prefix || (current_number)::text as receipt_number
`

type GetNextReceiptNumberParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetNextReceiptNumber(ctx context.Context, arg GetNextReceiptNumberParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getNextReceiptNumber, arg.ID, arg.TenantID)
	var receipt_number interface{}
	err := row.Scan(&receipt_number)
	return receipt_number, err
}

const getPaymentOrder = `-- name: GetPaymentOrder :one
SELECT id, tenant_id, student_id, amount, mode, status, external_ref, created_at FROM payment_orders
WHERE id = $1 AND tenant_id = $2
`

type GetPaymentOrderParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetPaymentOrder(ctx context.Context, arg GetPaymentOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getPaymentOrder, arg.ID, arg.TenantID)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Amount,
		&i.Mode,
		&i.Status,
		&i.ExternalRef,
		&i.CreatedAt,
	)
	return i, err
}

const getStudentFeeSummary = `-- name: GetStudentFeeSummary :many
SELECT 
    fpi.plan_id, 
    fpi.head_id, 
    fpi.amount, 
    fpi.due_date, 
    fpi.info, 
    fh.name as head_name,
    COALESCE((
        SELECT SUM(ri.amount)
        FROM receipt_items ri
        JOIN receipts r ON ri.receipt_id = r.id
        WHERE r.student_id = sfp.student_id 
          AND ri.fee_head_id = fpi.head_id
          AND r.status != 'cancelled'
    ), 0)::BIGINT as paid_amount
FROM student_fee_plans sfp
JOIN fee_plan_items fpi ON sfp.plan_id = fpi.plan_id
JOIN fee_heads fh ON fpi.head_id = fh.id
WHERE sfp.student_id = $1
ORDER BY fpi.due_date ASC, fh.name ASC
`

type GetStudentFeeSummaryRow struct {
	PlanID     pgtype.UUID `json:"plan_id"`
	HeadID     pgtype.UUID `json:"head_id"`
	Amount     int64       `json:"amount"`
	DueDate    pgtype.Date `json:"due_date"`
	Info       pgtype.Text `json:"info"`
	HeadName   string      `json:"head_name"`
	PaidAmount int64       `json:"paid_amount"`
}

func (q *Queries) GetStudentFeeSummary(ctx context.Context, studentID pgtype.UUID) ([]GetStudentFeeSummaryRow, error) {
	rows, err := q.db.Query(ctx, getStudentFeeSummary, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentFeeSummaryRow
	for rows.Next() {
		var i GetStudentFeeSummaryRow
		if err := rows.Scan(
			&i.PlanID,
			&i.HeadID,
			&i.Amount,
			&i.DueDate,
			&i.Info,
			&i.HeadName,
			&i.PaidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTallyExportData = `-- name: GetTallyExportData :many
SELECT 
    r.id,
    r.receipt_number,
    r.amount_paid,
    r.created_at,
    r.payment_mode,
    s.admission_number,
    s.full_name as student_name,
    tlm.tally_ledger_name
FROM receipts r
JOIN students s ON r.student_id = s.id
LEFT JOIN student_fee_plans sfp ON s.id = sfp.student_id
LEFT JOIN fee_plans fp ON sfp.plan_id = fp.id
LEFT JOIN fee_plan_items fpi ON fp.id = fpi.plan_id
LEFT JOIN tally_ledger_mappings tlm ON fpi.head_id = tlm.fee_head_id AND r.tenant_id = tlm.tenant_id
WHERE r.tenant_id = $1 AND r.created_at BETWEEN $2 AND $3
ORDER BY r.created_at ASC
`

type GetTallyExportDataParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetTallyExportDataRow struct {
	ID              pgtype.UUID        `json:"id"`
	ReceiptNumber   string             `json:"receipt_number"`
	AmountPaid      int64              `json:"amount_paid"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	PaymentMode     string             `json:"payment_mode"`
	AdmissionNumber string             `json:"admission_number"`
	StudentName     string             `json:"student_name"`
	TallyLedgerName pgtype.Text        `json:"tally_ledger_name"`
}

// Simple mapping for demo: using the first head's mapping from the plan
func (q *Queries) GetTallyExportData(ctx context.Context, arg GetTallyExportDataParams) ([]GetTallyExportDataRow, error) {
	rows, err := q.db.Query(ctx, getTallyExportData, arg.TenantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTallyExportDataRow
	for rows.Next() {
		var i GetTallyExportDataRow
		if err := rows.Scan(
			&i.ID,
			&i.ReceiptNumber,
			&i.AmountPaid,
			&i.CreatedAt,
			&i.PaymentMode,
			&i.AdmissionNumber,
			&i.StudentName,
			&i.TallyLedgerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantActiveGateway = `-- name: GetTenantActiveGateway :one
SELECT id, tenant_id, provider, api_key, api_secret, webhook_secret, is_active, settings, created_at, updated_at FROM payment_gateway_configs
WHERE tenant_id = $1 AND is_active = true
LIMIT 1
`

func (q *Queries) GetTenantActiveGateway(ctx context.Context, tenantID pgtype.UUID) (PaymentGatewayConfig, error) {
	row := q.db.QueryRow(ctx, getTenantActiveGateway, tenantID)
	var i PaymentGatewayConfig
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Provider,
		&i.ApiKey,
		&i.ApiSecret,
		&i.WebhookSecret,
		&i.IsActive,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFeeClassConfigs = `-- name: ListFeeClassConfigs :many
SELECT fc.id, fc.tenant_id, fc.academic_year_id, fc.class_id, fc.fee_head_id, fc.amount, fc.due_date, fc.is_optional, fc.created_at, fc.updated_at, fh.name as fee_head_name, c.name as class_name
FROM fee_class_configurations fc
JOIN fee_heads fh ON fc.fee_head_id = fh.id
JOIN classes c ON fc.class_id = c.id
WHERE fc.tenant_id = $1 
  AND fc.academic_year_id = $2
  AND ($3::UUID IS NULL OR fc.class_id = $3::UUID)
ORDER BY c.level, fh.name
`

type ListFeeClassConfigsParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	ClassID        pgtype.UUID `json:"class_id"`
}

type ListFeeClassConfigsRow struct {
	ID             pgtype.UUID        `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	AcademicYearID pgtype.UUID        `json:"academic_year_id"`
	ClassID        pgtype.UUID        `json:"class_id"`
	FeeHeadID      pgtype.UUID        `json:"fee_head_id"`
	Amount         pgtype.Numeric     `json:"amount"`
	DueDate        pgtype.Date        `json:"due_date"`
	IsOptional     pgtype.Bool        `json:"is_optional"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	FeeHeadName    string             `json:"fee_head_name"`
	ClassName      string             `json:"class_name"`
}

func (q *Queries) ListFeeClassConfigs(ctx context.Context, arg ListFeeClassConfigsParams) ([]ListFeeClassConfigsRow, error) {
	rows, err := q.db.Query(ctx, listFeeClassConfigs, arg.TenantID, arg.AcademicYearID, arg.ClassID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeeClassConfigsRow
	for rows.Next() {
		var i ListFeeClassConfigsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AcademicYearID,
			&i.ClassID,
			&i.FeeHeadID,
			&i.Amount,
			&i.DueDate,
			&i.IsOptional,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FeeHeadName,
			&i.ClassName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeHeads = `-- name: ListFeeHeads :many
SELECT id, tenant_id, name, type, created_at FROM fee_heads WHERE tenant_id = $1
`

func (q *Queries) ListFeeHeads(ctx context.Context, tenantID pgtype.UUID) ([]FeeHead, error) {
	rows, err := q.db.Query(ctx, listFeeHeads, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeeHead
	for rows.Next() {
		var i FeeHead
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLedgerMappings = `-- name: ListLedgerMappings :many
SELECT lm.id, lm.tenant_id, lm.fee_head_id, lm.tally_ledger_name, lm.created_at, fh.name as fee_head_name
FROM tally_ledger_mappings lm
JOIN fee_heads fh ON lm.fee_head_id = fh.id
WHERE lm.tenant_id = $1
`

type ListLedgerMappingsRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	FeeHeadID       pgtype.UUID        `json:"fee_head_id"`
	TallyLedgerName string             `json:"tally_ledger_name"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FeeHeadName     string             `json:"fee_head_name"`
}

func (q *Queries) ListLedgerMappings(ctx context.Context, tenantID pgtype.UUID) ([]ListLedgerMappingsRow, error) {
	rows, err := q.db.Query(ctx, listLedgerMappings, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLedgerMappingsRow
	for rows.Next() {
		var i ListLedgerMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.FeeHeadID,
			&i.TallyLedgerName,
			&i.CreatedAt,
			&i.FeeHeadName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionalFeeItems = `-- name: ListOptionalFeeItems :many
SELECT id, tenant_id, name, amount, category, created_at FROM optional_fee_items
WHERE tenant_id = $1
ORDER BY category, name
`

func (q *Queries) ListOptionalFeeItems(ctx context.Context, tenantID pgtype.UUID) ([]OptionalFeeItem, error) {
	rows, err := q.db.Query(ctx, listOptionalFeeItems, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OptionalFeeItem
	for rows.Next() {
		var i OptionalFeeItem
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Amount,
			&i.Category,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceiptSeries = `-- name: ListReceiptSeries :many
SELECT id, tenant_id, branch_id, prefix, current_number, is_active, created_at, updated_at FROM receipt_series WHERE tenant_id = $1
`

func (q *Queries) ListReceiptSeries(ctx context.Context, tenantID pgtype.UUID) ([]ReceiptSeries, error) {
	rows, err := q.db.Query(ctx, listReceiptSeries, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReceiptSeries
	for rows.Next() {
		var i ReceiptSeries
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.BranchID,
			&i.Prefix,
			&i.CurrentNumber,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScholarships = `-- name: ListScholarships :many
SELECT id, tenant_id, name, type, value, description, is_active, created_at FROM fee_discounts_scholarships
WHERE tenant_id = $1 AND ($2::BOOLEAN = false OR is_active = $2::BOOLEAN)
ORDER BY created_at DESC
`

type ListScholarshipsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	IsActive bool        `json:"is_active"`
}

func (q *Queries) ListScholarships(ctx context.Context, arg ListScholarshipsParams) ([]FeeDiscountsScholarship, error) {
	rows, err := q.db.Query(ctx, listScholarships, arg.TenantID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeeDiscountsScholarship
	for rows.Next() {
		var i FeeDiscountsScholarship
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentReceipts = `-- name: ListStudentReceipts :many
SELECT id, tenant_id, receipt_number, student_id, amount_paid, payment_mode, status, cancelled_by, cancellation_reason, transaction_ref, created_by, created_at, series_id FROM receipts
WHERE student_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
`

type ListStudentReceiptsParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ListStudentReceipts(ctx context.Context, arg ListStudentReceiptsParams) ([]Receipt, error) {
	rows, err := q.db.Query(ctx, listStudentReceipts, arg.StudentID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Receipt
	for rows.Next() {
		var i Receipt
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ReceiptNumber,
			&i.StudentID,
			&i.AmountPaid,
			&i.PaymentMode,
			&i.Status,
			&i.CancelledBy,
			&i.CancellationReason,
			&i.TransactionRef,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.SeriesID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logPaymentEvent = `-- name: LogPaymentEvent :one
INSERT INTO payment_events (tenant_id, gateway_event_id, event_type)
VALUES ($1, $2, $3)
RETURNING id, tenant_id, gateway_event_id, event_type, processed_at
`

type LogPaymentEventParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	GatewayEventID string      `json:"gateway_event_id"`
	EventType      string      `json:"event_type"`
}

func (q *Queries) LogPaymentEvent(ctx context.Context, arg LogPaymentEventParams) (PaymentEvent, error) {
	row := q.db.QueryRow(ctx, logPaymentEvent, arg.TenantID, arg.GatewayEventID, arg.EventType)
	var i PaymentEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.GatewayEventID,
		&i.EventType,
		&i.ProcessedAt,
	)
	return i, err
}

const updatePaymentOrderStatus = `-- name: UpdatePaymentOrderStatus :one
UPDATE payment_orders
SET status = $3, external_ref = $4
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, student_id, amount, mode, status, external_ref, created_at
`

type UpdatePaymentOrderStatusParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Status      pgtype.Text `json:"status"`
	ExternalRef pgtype.Text `json:"external_ref"`
}

func (q *Queries) UpdatePaymentOrderStatus(ctx context.Context, arg UpdatePaymentOrderStatusParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, updatePaymentOrderStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ExternalRef,
	)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Amount,
		&i.Mode,
		&i.Status,
		&i.ExternalRef,
		&i.CreatedAt,
	)
	return i, err
}

const updateReceiptSeries = `-- name: UpdateReceiptSeries :one
UPDATE receipt_series
SET is_active = $3, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, branch_id, prefix, current_number, is_active, created_at, updated_at
`

type UpdateReceiptSeriesParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateReceiptSeries(ctx context.Context, arg UpdateReceiptSeriesParams) (ReceiptSeries, error) {
	row := q.db.QueryRow(ctx, updateReceiptSeries, arg.ID, arg.TenantID, arg.IsActive)
	var i ReceiptSeries
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.Prefix,
		&i.CurrentNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertFeeClassConfig = `-- name: UpsertFeeClassConfig :one
INSERT INTO fee_class_configurations (
    tenant_id, academic_year_id, class_id, fee_head_id, amount, due_date, is_optional
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (tenant_id, academic_year_id, class_id, fee_head_id) DO UPDATE
SET amount = EXCLUDED.amount, 
    due_date = EXCLUDED.due_date,
    is_optional = EXCLUDED.is_optional,
    updated_at = NOW()
RETURNING id, tenant_id, academic_year_id, class_id, fee_head_id, amount, due_date, is_optional, created_at, updated_at
`

type UpsertFeeClassConfigParams struct {
	TenantID       pgtype.UUID    `json:"tenant_id"`
	AcademicYearID pgtype.UUID    `json:"academic_year_id"`
	ClassID        pgtype.UUID    `json:"class_id"`
	FeeHeadID      pgtype.UUID    `json:"fee_head_id"`
	Amount         pgtype.Numeric `json:"amount"`
	DueDate        pgtype.Date    `json:"due_date"`
	IsOptional     pgtype.Bool    `json:"is_optional"`
}

func (q *Queries) UpsertFeeClassConfig(ctx context.Context, arg UpsertFeeClassConfigParams) (FeeClassConfiguration, error) {
	row := q.db.QueryRow(ctx, upsertFeeClassConfig,
		arg.TenantID,
		arg.AcademicYearID,
		arg.ClassID,
		arg.FeeHeadID,
		arg.Amount,
		arg.DueDate,
		arg.IsOptional,
	)
	var i FeeClassConfiguration
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.ClassID,
		&i.FeeHeadID,
		&i.Amount,
		&i.DueDate,
		&i.IsOptional,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertGatewayConfig = `-- name: UpsertGatewayConfig :one
INSERT INTO payment_gateway_configs (
    tenant_id, provider, api_key, api_secret, webhook_secret, is_active, settings
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (tenant_id, provider) DO UPDATE
SET api_key = EXCLUDED.api_key,
    api_secret = EXCLUDED.api_secret,
    webhook_secret = EXCLUDED.webhook_secret,
    is_active = EXCLUDED.is_active,
    settings = EXCLUDED.settings,
    updated_at = NOW()
RETURNING id, tenant_id, provider, api_key, api_secret, webhook_secret, is_active, settings, created_at, updated_at
`

type UpsertGatewayConfigParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	Provider      string      `json:"provider"`
	ApiKey        pgtype.Text `json:"api_key"`
	ApiSecret     pgtype.Text `json:"api_secret"`
	WebhookSecret pgtype.Text `json:"webhook_secret"`
	IsActive      pgtype.Bool `json:"is_active"`
	Settings      []byte      `json:"settings"`
}

func (q *Queries) UpsertGatewayConfig(ctx context.Context, arg UpsertGatewayConfigParams) (PaymentGatewayConfig, error) {
	row := q.db.QueryRow(ctx, upsertGatewayConfig,
		arg.TenantID,
		arg.Provider,
		arg.ApiKey,
		arg.ApiSecret,
		arg.WebhookSecret,
		arg.IsActive,
		arg.Settings,
	)
	var i PaymentGatewayConfig
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Provider,
		&i.ApiKey,
		&i.ApiSecret,
		&i.WebhookSecret,
		&i.IsActive,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertLedgerMapping = `-- name: UpsertLedgerMapping :one
INSERT INTO tally_ledger_mappings (tenant_id, fee_head_id, tally_ledger_name)
VALUES ($1, $2, $3)
ON CONFLICT (tenant_id, fee_head_id) DO UPDATE
SET tally_ledger_name = EXCLUDED.tally_ledger_name
RETURNING id, tenant_id, fee_head_id, tally_ledger_name, created_at
`

type UpsertLedgerMappingParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	FeeHeadID       pgtype.UUID `json:"fee_head_id"`
	TallyLedgerName string      `json:"tally_ledger_name"`
}

func (q *Queries) UpsertLedgerMapping(ctx context.Context, arg UpsertLedgerMappingParams) (TallyLedgerMapping, error) {
	row := q.db.QueryRow(ctx, upsertLedgerMapping, arg.TenantID, arg.FeeHeadID, arg.TallyLedgerName)
	var i TallyLedgerMapping
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FeeHeadID,
		&i.TallyLedgerName,
		&i.CreatedAt,
	)
	return i, err
}

const upsertScholarship = `-- name: UpsertScholarship :one
INSERT INTO fee_discounts_scholarships (
    tenant_id, name, type, value, description, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, name, type, value, description, is_active, created_at
`

type UpsertScholarshipParams struct {
	TenantID    pgtype.UUID    `json:"tenant_id"`
	Name        string         `json:"name"`
	Type        string         `json:"type"`
	Value       pgtype.Numeric `json:"value"`
	Description pgtype.Text    `json:"description"`
	IsActive    pgtype.Bool    `json:"is_active"`
}

func (q *Queries) UpsertScholarship(ctx context.Context, arg UpsertScholarshipParams) (FeeDiscountsScholarship, error) {
	row := q.db.QueryRow(ctx, upsertScholarship,
		arg.TenantID,
		arg.Name,
		arg.Type,
		arg.Value,
		arg.Description,
		arg.IsActive,
	)
	var i FeeDiscountsScholarship
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Type,
		&i.Value,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const upsertStudentOptionalFee = `-- name: UpsertStudentOptionalFee :one
INSERT INTO student_optional_fees (
    tenant_id, student_id, item_id, academic_year_id, status
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (tenant_id, student_id, item_id, academic_year_id) DO UPDATE
SET status = EXCLUDED.status
RETURNING id, tenant_id, student_id, item_id, academic_year_id, status, created_at
`

type UpsertStudentOptionalFeeParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	StudentID      pgtype.UUID `json:"student_id"`
	ItemID         pgtype.UUID `json:"item_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	Status         string      `json:"status"`
}

func (q *Queries) UpsertStudentOptionalFee(ctx context.Context, arg UpsertStudentOptionalFeeParams) (StudentOptionalFee, error) {
	row := q.db.QueryRow(ctx, upsertStudentOptionalFee,
		arg.TenantID,
		arg.StudentID,
		arg.ItemID,
		arg.AcademicYearID,
		arg.Status,
	)
	var i StudentOptionalFee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.ItemID,
		&i.AcademicYearID,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}
