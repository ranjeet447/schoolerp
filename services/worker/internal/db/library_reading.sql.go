// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: library_reading.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createReadingProgress = `-- name: CreateReadingProgress :one
INSERT INTO library_reading_progress (
    student_id, asset_id, pages_read, total_pages
) VALUES (
    $1, $2, $3, $4
) RETURNING id, student_id, asset_id, pages_read, total_pages, recorded_at
`

type CreateReadingProgressParams struct {
	StudentID  pgtype.UUID `json:"student_id"`
	AssetID    pgtype.UUID `json:"asset_id"`
	PagesRead  int32       `json:"pages_read"`
	TotalPages int32       `json:"total_pages"`
}

func (q *Queries) CreateReadingProgress(ctx context.Context, arg CreateReadingProgressParams) (LibraryReadingProgress, error) {
	row := q.db.QueryRow(ctx, createReadingProgress,
		arg.StudentID,
		arg.AssetID,
		arg.PagesRead,
		arg.TotalPages,
	)
	var i LibraryReadingProgress
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.AssetID,
		&i.PagesRead,
		&i.TotalPages,
		&i.RecordedAt,
	)
	return i, err
}

const getReadingVelocity = `-- name: GetReadingVelocity :many
SELECT 
    recorded_at,
    pages_read
FROM library_reading_progress
WHERE student_id = $1 AND asset_id = $2
ORDER BY recorded_at ASC
`

type GetReadingVelocityParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	AssetID   pgtype.UUID `json:"asset_id"`
}

type GetReadingVelocityRow struct {
	RecordedAt pgtype.Timestamptz `json:"recorded_at"`
	PagesRead  int32              `json:"pages_read"`
}

func (q *Queries) GetReadingVelocity(ctx context.Context, arg GetReadingVelocityParams) ([]GetReadingVelocityRow, error) {
	rows, err := q.db.Query(ctx, getReadingVelocity, arg.StudentID, arg.AssetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReadingVelocityRow
	for rows.Next() {
		var i GetReadingVelocityRow
		if err := rows.Scan(&i.RecordedAt, &i.PagesRead); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentReadingLogs = `-- name: GetStudentReadingLogs :many
SELECT 
    l.id, l.tenant_id, l.student_id, l.book_id, l.status, l.current_page, l.total_pages, l.rating, l.notes, l.created_at, l.updated_at, l.metadata,
    b.title as book_title,
    b.cover_image_url
FROM library_reading_logs l
JOIN library_books b ON l.book_id = b.id
WHERE l.tenant_id = $1 AND l.student_id = $2
ORDER BY l.updated_at DESC
`

type GetStudentReadingLogsParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	StudentID pgtype.UUID `json:"student_id"`
}

type GetStudentReadingLogsRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	StudentID     pgtype.UUID        `json:"student_id"`
	BookID        pgtype.UUID        `json:"book_id"`
	Status        string             `json:"status"`
	CurrentPage   pgtype.Int4        `json:"current_page"`
	TotalPages    pgtype.Int4        `json:"total_pages"`
	Rating        pgtype.Int4        `json:"rating"`
	Notes         pgtype.Text        `json:"notes"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Metadata      []byte             `json:"metadata"`
	BookTitle     string             `json:"book_title"`
	CoverImageUrl pgtype.Text        `json:"cover_image_url"`
}

func (q *Queries) GetStudentReadingLogs(ctx context.Context, arg GetStudentReadingLogsParams) ([]GetStudentReadingLogsRow, error) {
	rows, err := q.db.Query(ctx, getStudentReadingLogs, arg.TenantID, arg.StudentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentReadingLogsRow
	for rows.Next() {
		var i GetStudentReadingLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.BookID,
			&i.Status,
			&i.CurrentPage,
			&i.TotalPages,
			&i.Rating,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Metadata,
			&i.BookTitle,
			&i.CoverImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllReadingLogs = `-- name: ListAllReadingLogs :many
SELECT 
    l.id, l.tenant_id, l.student_id, l.book_id, l.status, l.current_page, l.total_pages, l.rating, l.notes, l.created_at, l.updated_at, l.metadata,
    b.title as book_title,
    b.cover_image_url,
    s.full_name as student_name
FROM library_reading_logs l
JOIN library_books b ON l.book_id = b.id
JOIN students s ON l.student_id = s.id
WHERE l.tenant_id = $1
ORDER BY l.updated_at DESC
`

type ListAllReadingLogsRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	StudentID     pgtype.UUID        `json:"student_id"`
	BookID        pgtype.UUID        `json:"book_id"`
	Status        string             `json:"status"`
	CurrentPage   pgtype.Int4        `json:"current_page"`
	TotalPages    pgtype.Int4        `json:"total_pages"`
	Rating        pgtype.Int4        `json:"rating"`
	Notes         pgtype.Text        `json:"notes"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Metadata      []byte             `json:"metadata"`
	BookTitle     string             `json:"book_title"`
	CoverImageUrl pgtype.Text        `json:"cover_image_url"`
	StudentName   string             `json:"student_name"`
}

func (q *Queries) ListAllReadingLogs(ctx context.Context, tenantID pgtype.UUID) ([]ListAllReadingLogsRow, error) {
	rows, err := q.db.Query(ctx, listAllReadingLogs, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllReadingLogsRow
	for rows.Next() {
		var i ListAllReadingLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.BookID,
			&i.Status,
			&i.CurrentPage,
			&i.TotalPages,
			&i.Rating,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Metadata,
			&i.BookTitle,
			&i.CoverImageUrl,
			&i.StudentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentReadingLogs = `-- name: ListRecentReadingLogs :many
SELECT 
    l.id, l.tenant_id, l.student_id, l.book_id, l.status, l.current_page, l.total_pages, l.rating, l.notes, l.created_at, l.updated_at, l.metadata,
    b.title as book_title,
    b.cover_image_url,
    s.full_name as student_name
FROM library_reading_logs l
JOIN library_books b ON l.book_id = b.id
JOIN students s ON l.student_id = s.id
WHERE l.tenant_id = $1
ORDER BY l.updated_at DESC
LIMIT $2
`

type ListRecentReadingLogsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
}

type ListRecentReadingLogsRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	StudentID     pgtype.UUID        `json:"student_id"`
	BookID        pgtype.UUID        `json:"book_id"`
	Status        string             `json:"status"`
	CurrentPage   pgtype.Int4        `json:"current_page"`
	TotalPages    pgtype.Int4        `json:"total_pages"`
	Rating        pgtype.Int4        `json:"rating"`
	Notes         pgtype.Text        `json:"notes"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Metadata      []byte             `json:"metadata"`
	BookTitle     string             `json:"book_title"`
	CoverImageUrl pgtype.Text        `json:"cover_image_url"`
	StudentName   string             `json:"student_name"`
}

func (q *Queries) ListRecentReadingLogs(ctx context.Context, arg ListRecentReadingLogsParams) ([]ListRecentReadingLogsRow, error) {
	rows, err := q.db.Query(ctx, listRecentReadingLogs, arg.TenantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentReadingLogsRow
	for rows.Next() {
		var i ListRecentReadingLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.BookID,
			&i.Status,
			&i.CurrentPage,
			&i.TotalPages,
			&i.Rating,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Metadata,
			&i.BookTitle,
			&i.CoverImageUrl,
			&i.StudentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertReadingLog = `-- name: UpsertReadingLog :one
INSERT INTO library_reading_logs (
    tenant_id, student_id, book_id, status, current_page, total_pages, rating, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (student_id, book_id) DO UPDATE SET
    status = EXCLUDED.status,
    current_page = EXCLUDED.current_page,
    total_pages = EXCLUDED.total_pages,
    rating = EXCLUDED.rating,
    notes = EXCLUDED.notes,
    updated_at = NOW()
RETURNING id, tenant_id, student_id, book_id, status, current_page, total_pages, rating, notes, created_at, updated_at, metadata
`

type UpsertReadingLogParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	StudentID   pgtype.UUID `json:"student_id"`
	BookID      pgtype.UUID `json:"book_id"`
	Status      string      `json:"status"`
	CurrentPage pgtype.Int4 `json:"current_page"`
	TotalPages  pgtype.Int4 `json:"total_pages"`
	Rating      pgtype.Int4 `json:"rating"`
	Notes       pgtype.Text `json:"notes"`
}

func (q *Queries) UpsertReadingLog(ctx context.Context, arg UpsertReadingLogParams) (LibraryReadingLog, error) {
	row := q.db.QueryRow(ctx, upsertReadingLog,
		arg.TenantID,
		arg.StudentID,
		arg.BookID,
		arg.Status,
		arg.CurrentPage,
		arg.TotalPages,
		arg.Rating,
		arg.Notes,
	)
	var i LibraryReadingLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.BookID,
		&i.Status,
		&i.CurrentPage,
		&i.TotalPages,
		&i.Rating,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}
