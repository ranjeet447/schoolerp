// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admission.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO admission_applications (
    tenant_id, enquiry_id, application_number, status, form_data, documents
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, enquiry_id, application_number, status, form_data, documents, reviewed_by, created_at, updated_at, processing_fee_amount, processing_fee_status, payment_reference
`

type CreateApplicationParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	EnquiryID         pgtype.UUID `json:"enquiry_id"`
	ApplicationNumber string      `json:"application_number"`
	Status            string      `json:"status"`
	FormData          []byte      `json:"form_data"`
	Documents         []byte      `json:"documents"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (AdmissionApplication, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.TenantID,
		arg.EnquiryID,
		arg.ApplicationNumber,
		arg.Status,
		arg.FormData,
		arg.Documents,
	)
	var i AdmissionApplication
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EnquiryID,
		&i.ApplicationNumber,
		&i.Status,
		&i.FormData,
		&i.Documents,
		&i.ReviewedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessingFeeAmount,
		&i.ProcessingFeeStatus,
		&i.PaymentReference,
	)
	return i, err
}

const createEnquiry = `-- name: CreateEnquiry :one
INSERT INTO admission_enquiries (
    tenant_id, parent_name, email, phone, student_name, grade_interested, academic_year, source, status, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tenant_id, parent_name, email, phone, student_name, grade_interested, academic_year, source, status, notes, created_at, updated_at
`

type CreateEnquiryParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	ParentName      string      `json:"parent_name"`
	Email           pgtype.Text `json:"email"`
	Phone           string      `json:"phone"`
	StudentName     string      `json:"student_name"`
	GradeInterested string      `json:"grade_interested"`
	AcademicYear    string      `json:"academic_year"`
	Source          pgtype.Text `json:"source"`
	Status          string      `json:"status"`
	Notes           pgtype.Text `json:"notes"`
}

func (q *Queries) CreateEnquiry(ctx context.Context, arg CreateEnquiryParams) (AdmissionEnquiry, error) {
	row := q.db.QueryRow(ctx, createEnquiry,
		arg.TenantID,
		arg.ParentName,
		arg.Email,
		arg.Phone,
		arg.StudentName,
		arg.GradeInterested,
		arg.AcademicYear,
		arg.Source,
		arg.Status,
		arg.Notes,
	)
	var i AdmissionEnquiry
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ParentName,
		&i.Email,
		&i.Phone,
		&i.StudentName,
		&i.GradeInterested,
		&i.AcademicYear,
		&i.Source,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplication = `-- name: GetApplication :one
SELECT id, tenant_id, enquiry_id, application_number, status, form_data, documents, reviewed_by, created_at, updated_at, processing_fee_amount, processing_fee_status, payment_reference FROM admission_applications WHERE id = $1 AND tenant_id = $2
`

type GetApplicationParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetApplication(ctx context.Context, arg GetApplicationParams) (AdmissionApplication, error) {
	row := q.db.QueryRow(ctx, getApplication, arg.ID, arg.TenantID)
	var i AdmissionApplication
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EnquiryID,
		&i.ApplicationNumber,
		&i.Status,
		&i.FormData,
		&i.Documents,
		&i.ReviewedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessingFeeAmount,
		&i.ProcessingFeeStatus,
		&i.PaymentReference,
	)
	return i, err
}

const getEnquiry = `-- name: GetEnquiry :one
SELECT id, tenant_id, parent_name, email, phone, student_name, grade_interested, academic_year, source, status, notes, created_at, updated_at FROM admission_enquiries WHERE id = $1 AND tenant_id = $2
`

type GetEnquiryParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetEnquiry(ctx context.Context, arg GetEnquiryParams) (AdmissionEnquiry, error) {
	row := q.db.QueryRow(ctx, getEnquiry, arg.ID, arg.TenantID)
	var i AdmissionEnquiry
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ParentName,
		&i.Email,
		&i.Phone,
		&i.StudentName,
		&i.GradeInterested,
		&i.AcademicYear,
		&i.Source,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listApplications = `-- name: ListApplications :many
SELECT 
    a.id, a.tenant_id, a.enquiry_id, a.application_number, a.status, a.form_data, a.documents, a.reviewed_by, a.created_at, a.updated_at, a.processing_fee_amount, a.processing_fee_status, a.payment_reference,
    e.parent_name,
    e.student_name,
    e.grade_interested
FROM admission_applications a
LEFT JOIN admission_enquiries e ON a.enquiry_id = e.id
WHERE a.tenant_id = $1
ORDER BY a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListApplicationsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListApplicationsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	EnquiryID           pgtype.UUID        `json:"enquiry_id"`
	ApplicationNumber   string             `json:"application_number"`
	Status              string             `json:"status"`
	FormData            []byte             `json:"form_data"`
	Documents           []byte             `json:"documents"`
	ReviewedBy          pgtype.UUID        `json:"reviewed_by"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	ProcessingFeeAmount pgtype.Int8        `json:"processing_fee_amount"`
	ProcessingFeeStatus pgtype.Text        `json:"processing_fee_status"`
	PaymentReference    pgtype.Text        `json:"payment_reference"`
	ParentName          pgtype.Text        `json:"parent_name"`
	StudentName         pgtype.Text        `json:"student_name"`
	GradeInterested     pgtype.Text        `json:"grade_interested"`
}

func (q *Queries) ListApplications(ctx context.Context, arg ListApplicationsParams) ([]ListApplicationsRow, error) {
	rows, err := q.db.Query(ctx, listApplications, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListApplicationsRow
	for rows.Next() {
		var i ListApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EnquiryID,
			&i.ApplicationNumber,
			&i.Status,
			&i.FormData,
			&i.Documents,
			&i.ReviewedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessingFeeAmount,
			&i.ProcessingFeeStatus,
			&i.PaymentReference,
			&i.ParentName,
			&i.StudentName,
			&i.GradeInterested,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnquiries = `-- name: ListEnquiries :many
SELECT id, tenant_id, parent_name, email, phone, student_name, grade_interested, academic_year, source, status, notes, created_at, updated_at FROM admission_enquiries
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEnquiriesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListEnquiries(ctx context.Context, arg ListEnquiriesParams) ([]AdmissionEnquiry, error) {
	rows, err := q.db.Query(ctx, listEnquiries, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdmissionEnquiry
	for rows.Next() {
		var i AdmissionEnquiry
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ParentName,
			&i.Email,
			&i.Phone,
			&i.StudentName,
			&i.GradeInterested,
			&i.AcademicYear,
			&i.Source,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplicationFee = `-- name: UpdateApplicationFee :exec
UPDATE admission_applications
SET processing_fee_amount = $3, 
    processing_fee_status = $4, 
    payment_reference = $5, 
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateApplicationFeeParams struct {
	ID                  pgtype.UUID `json:"id"`
	TenantID            pgtype.UUID `json:"tenant_id"`
	ProcessingFeeAmount pgtype.Int8 `json:"processing_fee_amount"`
	ProcessingFeeStatus pgtype.Text `json:"processing_fee_status"`
	PaymentReference    pgtype.Text `json:"payment_reference"`
}

func (q *Queries) UpdateApplicationFee(ctx context.Context, arg UpdateApplicationFeeParams) error {
	_, err := q.db.Exec(ctx, updateApplicationFee,
		arg.ID,
		arg.TenantID,
		arg.ProcessingFeeAmount,
		arg.ProcessingFeeStatus,
		arg.PaymentReference,
	)
	return err
}

const updateApplicationStatus = `-- name: UpdateApplicationStatus :exec
UPDATE admission_applications 
SET status = $3, reviewed_by = $4, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateApplicationStatusParams struct {
	ID         pgtype.UUID `json:"id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
	Status     string      `json:"status"`
	ReviewedBy pgtype.UUID `json:"reviewed_by"`
}

func (q *Queries) UpdateApplicationStatus(ctx context.Context, arg UpdateApplicationStatusParams) error {
	_, err := q.db.Exec(ctx, updateApplicationStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ReviewedBy,
	)
	return err
}

const updateEnquiryStatus = `-- name: UpdateEnquiryStatus :exec
UPDATE admission_enquiries 
SET status = $3, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateEnquiryStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

func (q *Queries) UpdateEnquiryStatus(ctx context.Context, arg UpdateEnquiryStatusParams) error {
	_, err := q.db.Exec(ctx, updateEnquiryStatus, arg.ID, arg.TenantID, arg.Status)
	return err
}
