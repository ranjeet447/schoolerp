// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reminders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveReminderConfigs = `-- name: GetActiveReminderConfigs :many
SELECT id, tenant_id, days_offset, reminder_type, is_active, created_at, updated_at FROM fee_reminder_configs
WHERE is_active = true
`

func (q *Queries) GetActiveReminderConfigs(ctx context.Context) ([]FeeReminderConfig, error) {
	rows, err := q.db.Query(ctx, getActiveReminderConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeeReminderConfig
	for rows.Next() {
		var i FeeReminderConfig
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.DaysOffset,
			&i.ReminderType,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentsForFeeReminder = `-- name: GetStudentsForFeeReminder :many
SELECT 
    s.id as student_id,
    s.tenant_id,
    s.full_name as student_name,
    fh.name as fee_head_name,
    fh.id as fee_head_id,
    fc.due_date,
    fc.amount as expected_amount,
    COALESCE(paid.amount, 0)::BIGINT as paid_amount
FROM fee_class_configurations fc
JOIN fee_heads fh ON fc.fee_head_id = fh.id
JOIN students s ON s.section_id IN (SELECT id FROM sections WHERE class_id = fc.class_id)
JOIN student_fee_plans sfp ON s.id = sfp.student_id AND sfp.plan_id IN (SELECT plan_id FROM fee_plan_items WHERE head_id = fc.fee_head_id)
LEFT JOIN (
    SELECT r.student_id, ri.fee_head_id, SUM(ri.amount) as amount
    FROM receipts r
    JOIN receipt_items ri ON r.id = ri.receipt_id
    WHERE r.status != 'cancelled'
    GROUP BY r.student_id, ri.fee_head_id
) paid ON s.id = paid.student_id AND fc.fee_head_id = paid.fee_head_id
WHERE fc.tenant_id = $1::UUID
  AND fc.academic_year_id = $2::UUID
  AND fc.due_date = $3::DATE
  AND (fc.amount - COALESCE(paid.amount, 0)) > 0
  AND NOT EXISTS (
      SELECT 1 FROM fee_reminder_logs frl
      WHERE frl.student_id = s.id 
        AND frl.fee_head_id = fc.fee_head_id
        AND frl.reminder_config_id = $4
  )
`

type GetStudentsForFeeReminderParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	AcademicYearID   pgtype.UUID `json:"academic_year_id"`
	TargetDueDate    pgtype.Date `json:"target_due_date"`
	ReminderConfigID pgtype.UUID `json:"reminder_config_id"`
}

type GetStudentsForFeeReminderRow struct {
	StudentID      pgtype.UUID    `json:"student_id"`
	TenantID       pgtype.UUID    `json:"tenant_id"`
	StudentName    string         `json:"student_name"`
	FeeHeadName    string         `json:"fee_head_name"`
	FeeHeadID      pgtype.UUID    `json:"fee_head_id"`
	DueDate        pgtype.Date    `json:"due_date"`
	ExpectedAmount pgtype.Numeric `json:"expected_amount"`
	PaidAmount     int64          `json:"paid_amount"`
}

func (q *Queries) GetStudentsForFeeReminder(ctx context.Context, arg GetStudentsForFeeReminderParams) ([]GetStudentsForFeeReminderRow, error) {
	rows, err := q.db.Query(ctx, getStudentsForFeeReminder,
		arg.TenantID,
		arg.AcademicYearID,
		arg.TargetDueDate,
		arg.ReminderConfigID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentsForFeeReminderRow
	for rows.Next() {
		var i GetStudentsForFeeReminderRow
		if err := rows.Scan(
			&i.StudentID,
			&i.TenantID,
			&i.StudentName,
			&i.FeeHeadName,
			&i.FeeHeadID,
			&i.DueDate,
			&i.ExpectedAmount,
			&i.PaidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeReminderConfigs = `-- name: ListFeeReminderConfigs :many
SELECT id, tenant_id, days_offset, reminder_type, is_active, created_at, updated_at FROM fee_reminder_configs
WHERE tenant_id = $1
ORDER BY reminder_type, days_offset
`

func (q *Queries) ListFeeReminderConfigs(ctx context.Context, tenantID pgtype.UUID) ([]FeeReminderConfig, error) {
	rows, err := q.db.Query(ctx, listFeeReminderConfigs, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeeReminderConfig
	for rows.Next() {
		var i FeeReminderConfig
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.DaysOffset,
			&i.ReminderType,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logFeeReminder = `-- name: LogFeeReminder :one
INSERT INTO fee_reminder_logs (tenant_id, student_id, fee_head_id, reminder_config_id)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, student_id, fee_head_id, reminder_config_id, reminded_at
`

type LogFeeReminderParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	StudentID        pgtype.UUID `json:"student_id"`
	FeeHeadID        pgtype.UUID `json:"fee_head_id"`
	ReminderConfigID pgtype.UUID `json:"reminder_config_id"`
}

func (q *Queries) LogFeeReminder(ctx context.Context, arg LogFeeReminderParams) (FeeReminderLog, error) {
	row := q.db.QueryRow(ctx, logFeeReminder,
		arg.TenantID,
		arg.StudentID,
		arg.FeeHeadID,
		arg.ReminderConfigID,
	)
	var i FeeReminderLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.FeeHeadID,
		&i.ReminderConfigID,
		&i.RemindedAt,
	)
	return i, err
}

const upsertFeeReminderConfig = `-- name: UpsertFeeReminderConfig :one

INSERT INTO fee_reminder_configs (tenant_id, days_offset, reminder_type, is_active)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id, days_offset, reminder_type) DO UPDATE
SET is_active = EXCLUDED.is_active, updated_at = NOW()
RETURNING id, tenant_id, days_offset, reminder_type, is_active, created_at, updated_at
`

type UpsertFeeReminderConfigParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	DaysOffset   int32       `json:"days_offset"`
	ReminderType string      `json:"reminder_type"`
	IsActive     pgtype.Bool `json:"is_active"`
}

// reminders.sql
func (q *Queries) UpsertFeeReminderConfig(ctx context.Context, arg UpsertFeeReminderConfigParams) (FeeReminderConfig, error) {
	row := q.db.QueryRow(ctx, upsertFeeReminderConfig,
		arg.TenantID,
		arg.DaysOffset,
		arg.ReminderType,
		arg.IsActive,
	)
	var i FeeReminderConfig
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.DaysOffset,
		&i.ReminderType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
