// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: homework.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHomework = `-- name: CreateHomework :one

INSERT INTO homework (
    tenant_id, subject_id, class_section_id, teacher_id, 
    title, description, due_date, attachments, resource_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, tenant_id, subject_id, class_section_id, teacher_id, title, description, due_date, submission_allowed, attachments, resource_id, created_at, updated_at
`

type CreateHomeworkParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	SubjectID      pgtype.UUID        `json:"subject_id"`
	ClassSectionID pgtype.UUID        `json:"class_section_id"`
	TeacherID      pgtype.UUID        `json:"teacher_id"`
	Title          string             `json:"title"`
	Description    pgtype.Text        `json:"description"`
	DueDate        pgtype.Timestamptz `json:"due_date"`
	Attachments    []byte             `json:"attachments"`
	ResourceID     pgtype.UUID        `json:"resource_id"`
}

// homework.sql
func (q *Queries) CreateHomework(ctx context.Context, arg CreateHomeworkParams) (Homework, error) {
	row := q.db.QueryRow(ctx, createHomework,
		arg.TenantID,
		arg.SubjectID,
		arg.ClassSectionID,
		arg.TeacherID,
		arg.Title,
		arg.Description,
		arg.DueDate,
		arg.Attachments,
		arg.ResourceID,
	)
	var i Homework
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubjectID,
		&i.ClassSectionID,
		&i.TeacherID,
		&i.Title,
		&i.Description,
		&i.DueDate,
		&i.SubmissionAllowed,
		&i.Attachments,
		&i.ResourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHomework = `-- name: GetHomework :one
SELECT id, tenant_id, subject_id, class_section_id, teacher_id, title, description, due_date, submission_allowed, attachments, resource_id, created_at, updated_at FROM homework WHERE id = $1 AND tenant_id = $2
`

type GetHomeworkParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetHomework(ctx context.Context, arg GetHomeworkParams) (Homework, error) {
	row := q.db.QueryRow(ctx, getHomework, arg.ID, arg.TenantID)
	var i Homework
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubjectID,
		&i.ClassSectionID,
		&i.TeacherID,
		&i.Title,
		&i.Description,
		&i.DueDate,
		&i.SubmissionAllowed,
		&i.Attachments,
		&i.ResourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHomeworkDueSoon = `-- name: GetHomeworkDueSoon :many
SELECT id, tenant_id, subject_id, class_section_id, teacher_id, title, description, due_date, submission_allowed, attachments, resource_id, created_at, updated_at FROM homework
WHERE due_date BETWEEN NOW() AND NOW() + INTERVAL '4 hours'
AND submission_allowed = TRUE
`

func (q *Queries) GetHomeworkDueSoon(ctx context.Context) ([]Homework, error) {
	rows, err := q.db.Query(ctx, getHomeworkDueSoon)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Homework
	for rows.Next() {
		var i Homework
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubjectID,
			&i.ClassSectionID,
			&i.TeacherID,
			&i.Title,
			&i.Description,
			&i.DueDate,
			&i.SubmissionAllowed,
			&i.Attachments,
			&i.ResourceID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHomeworkForStudent = `-- name: GetHomeworkForStudent :many
SELECT h.id, h.tenant_id, h.subject_id, h.class_section_id, h.teacher_id, h.title, h.description, h.due_date, h.submission_allowed, h.attachments, h.resource_id, h.created_at, h.updated_at, s.name as subject_name, hs.status as submission_status
FROM homework h
JOIN subjects s ON h.subject_id = s.id
JOIN students st ON h.class_section_id = st.section_id
LEFT JOIN homework_submissions hs ON h.id = hs.homework_id AND hs.student_id = st.id
WHERE st.id = $1 AND h.tenant_id = $2
ORDER BY h.due_date ASC
`

type GetHomeworkForStudentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetHomeworkForStudentRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	SubjectID         pgtype.UUID        `json:"subject_id"`
	ClassSectionID    pgtype.UUID        `json:"class_section_id"`
	TeacherID         pgtype.UUID        `json:"teacher_id"`
	Title             string             `json:"title"`
	Description       pgtype.Text        `json:"description"`
	DueDate           pgtype.Timestamptz `json:"due_date"`
	SubmissionAllowed pgtype.Bool        `json:"submission_allowed"`
	Attachments       []byte             `json:"attachments"`
	ResourceID        pgtype.UUID        `json:"resource_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	SubjectName       string             `json:"subject_name"`
	SubmissionStatus  pgtype.Text        `json:"submission_status"`
}

// This searches homework for the section the student is currently in
func (q *Queries) GetHomeworkForStudent(ctx context.Context, arg GetHomeworkForStudentParams) ([]GetHomeworkForStudentRow, error) {
	rows, err := q.db.Query(ctx, getHomeworkForStudent, arg.ID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHomeworkForStudentRow
	for rows.Next() {
		var i GetHomeworkForStudentRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubjectID,
			&i.ClassSectionID,
			&i.TeacherID,
			&i.Title,
			&i.Description,
			&i.DueDate,
			&i.SubmissionAllowed,
			&i.Attachments,
			&i.ResourceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
			&i.SubmissionStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentsMissingSubmissionForHomework = `-- name: GetStudentsMissingSubmissionForHomework :many
SELECT st.id as student_id, st.full_name
FROM students st
JOIN homework h ON st.section_id = h.class_section_id
LEFT JOIN homework_submissions hs ON h.id = hs.homework_id AND st.id = hs.student_id
WHERE h.id = $1 AND hs.id IS NULL
`

type GetStudentsMissingSubmissionForHomeworkRow struct {
	StudentID pgtype.UUID `json:"student_id"`
	FullName  string      `json:"full_name"`
}

func (q *Queries) GetStudentsMissingSubmissionForHomework(ctx context.Context, id pgtype.UUID) ([]GetStudentsMissingSubmissionForHomeworkRow, error) {
	rows, err := q.db.Query(ctx, getStudentsMissingSubmissionForHomework, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentsMissingSubmissionForHomeworkRow
	for rows.Next() {
		var i GetStudentsMissingSubmissionForHomeworkRow
		if err := rows.Scan(&i.StudentID, &i.FullName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyllabusLag = `-- name: GetSyllabusLag :many
SELECT lp.id, lp.tenant_id, lp.subject_id, lp.class_id, lp.week_number, lp.planned_topic, lp.covered_at, lp.review_status, lp.review_remarks, lp.created_at, lp.updated_at, s.name as subject_name, c.name as class_name
FROM lesson_plans lp
JOIN subjects s ON lp.subject_id = s.id
JOIN classes c ON lp.class_id = c.id
WHERE lp.tenant_id = $1 
AND lp.week_number < $2 -- current week number
AND lp.covered_at IS NULL
ORDER BY lp.week_number ASC
`

type GetSyllabusLagParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	WeekNumber int32       `json:"week_number"`
}

type GetSyllabusLagRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	SubjectID     pgtype.UUID        `json:"subject_id"`
	ClassID       pgtype.UUID        `json:"class_id"`
	WeekNumber    int32              `json:"week_number"`
	PlannedTopic  string             `json:"planned_topic"`
	CoveredAt     pgtype.Timestamptz `json:"covered_at"`
	ReviewStatus  string             `json:"review_status"`
	ReviewRemarks pgtype.Text        `json:"review_remarks"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	SubjectName   string             `json:"subject_name"`
	ClassName     string             `json:"class_name"`
}

func (q *Queries) GetSyllabusLag(ctx context.Context, arg GetSyllabusLagParams) ([]GetSyllabusLagRow, error) {
	rows, err := q.db.Query(ctx, getSyllabusLag, arg.TenantID, arg.WeekNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSyllabusLagRow
	for rows.Next() {
		var i GetSyllabusLagRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubjectID,
			&i.ClassID,
			&i.WeekNumber,
			&i.PlannedTopic,
			&i.CoveredAt,
			&i.ReviewStatus,
			&i.ReviewRemarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
			&i.ClassName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const gradeSubmission = `-- name: GradeSubmission :one
UPDATE homework_submissions
SET status = $2::TEXT, teacher_feedback = $3, updated_at = NOW()
WHERE id = $1 AND status != 'checked'
RETURNING id, homework_id, student_id, attachment_url, remarks, status, teacher_feedback, submitted_at, updated_at
`

type GradeSubmissionParams struct {
	ID              pgtype.UUID `json:"id"`
	Column2         string      `json:"column_2"`
	TeacherFeedback pgtype.Text `json:"teacher_feedback"`
}

func (q *Queries) GradeSubmission(ctx context.Context, arg GradeSubmissionParams) (HomeworkSubmission, error) {
	row := q.db.QueryRow(ctx, gradeSubmission, arg.ID, arg.Column2, arg.TeacherFeedback)
	var i HomeworkSubmission
	err := row.Scan(
		&i.ID,
		&i.HomeworkID,
		&i.StudentID,
		&i.AttachmentUrl,
		&i.Remarks,
		&i.Status,
		&i.TeacherFeedback,
		&i.SubmittedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listHomeworkForSection = `-- name: ListHomeworkForSection :many
SELECT h.id, h.tenant_id, h.subject_id, h.class_section_id, h.teacher_id, h.title, h.description, h.due_date, h.submission_allowed, h.attachments, h.resource_id, h.created_at, h.updated_at, s.name as subject_name, u.full_name as teacher_name
FROM homework h
JOIN subjects s ON h.subject_id = s.id
JOIN users u ON h.teacher_id = u.id
WHERE h.class_section_id = $1 AND h.tenant_id = $2
ORDER BY h.due_date DESC
`

type ListHomeworkForSectionParams struct {
	ClassSectionID pgtype.UUID `json:"class_section_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

type ListHomeworkForSectionRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	SubjectID         pgtype.UUID        `json:"subject_id"`
	ClassSectionID    pgtype.UUID        `json:"class_section_id"`
	TeacherID         pgtype.UUID        `json:"teacher_id"`
	Title             string             `json:"title"`
	Description       pgtype.Text        `json:"description"`
	DueDate           pgtype.Timestamptz `json:"due_date"`
	SubmissionAllowed pgtype.Bool        `json:"submission_allowed"`
	Attachments       []byte             `json:"attachments"`
	ResourceID        pgtype.UUID        `json:"resource_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	SubjectName       string             `json:"subject_name"`
	TeacherName       string             `json:"teacher_name"`
}

func (q *Queries) ListHomeworkForSection(ctx context.Context, arg ListHomeworkForSectionParams) ([]ListHomeworkForSectionRow, error) {
	rows, err := q.db.Query(ctx, listHomeworkForSection, arg.ClassSectionID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHomeworkForSectionRow
	for rows.Next() {
		var i ListHomeworkForSectionRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubjectID,
			&i.ClassSectionID,
			&i.TeacherID,
			&i.Title,
			&i.Description,
			&i.DueDate,
			&i.SubmissionAllowed,
			&i.Attachments,
			&i.ResourceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
			&i.TeacherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLessonPlans = `-- name: ListLessonPlans :many
SELECT lp.id, lp.tenant_id, lp.subject_id, lp.class_id, lp.week_number, lp.planned_topic, lp.covered_at, lp.review_status, lp.review_remarks, lp.created_at, lp.updated_at, s.name as subject_name, c.name as class_name
FROM lesson_plans lp
JOIN subjects s ON lp.subject_id = s.id
JOIN classes c ON lp.class_id = c.id
WHERE lp.tenant_id = $1 AND lp.subject_id = $2 AND lp.class_id = $3
ORDER BY lp.week_number ASC
`

type ListLessonPlansParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
	ClassID   pgtype.UUID `json:"class_id"`
}

type ListLessonPlansRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	SubjectID     pgtype.UUID        `json:"subject_id"`
	ClassID       pgtype.UUID        `json:"class_id"`
	WeekNumber    int32              `json:"week_number"`
	PlannedTopic  string             `json:"planned_topic"`
	CoveredAt     pgtype.Timestamptz `json:"covered_at"`
	ReviewStatus  string             `json:"review_status"`
	ReviewRemarks pgtype.Text        `json:"review_remarks"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	SubjectName   string             `json:"subject_name"`
	ClassName     string             `json:"class_name"`
}

func (q *Queries) ListLessonPlans(ctx context.Context, arg ListLessonPlansParams) ([]ListLessonPlansRow, error) {
	rows, err := q.db.Query(ctx, listLessonPlans, arg.TenantID, arg.SubjectID, arg.ClassID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLessonPlansRow
	for rows.Next() {
		var i ListLessonPlansRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubjectID,
			&i.ClassID,
			&i.WeekNumber,
			&i.PlannedTopic,
			&i.CoveredAt,
			&i.ReviewStatus,
			&i.ReviewRemarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
			&i.ClassName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmissions = `-- name: ListSubmissions :many
SELECT hs.id, hs.homework_id, hs.student_id, hs.attachment_url, hs.remarks, hs.status, hs.teacher_feedback, hs.submitted_at, hs.updated_at, st.full_name as student_name
FROM homework_submissions hs
JOIN students st ON hs.student_id = st.id
WHERE hs.homework_id = $1
ORDER BY hs.submitted_at DESC
`

type ListSubmissionsRow struct {
	ID              pgtype.UUID        `json:"id"`
	HomeworkID      pgtype.UUID        `json:"homework_id"`
	StudentID       pgtype.UUID        `json:"student_id"`
	AttachmentUrl   pgtype.Text        `json:"attachment_url"`
	Remarks         pgtype.Text        `json:"remarks"`
	Status          string             `json:"status"`
	TeacherFeedback pgtype.Text        `json:"teacher_feedback"`
	SubmittedAt     pgtype.Timestamptz `json:"submitted_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	StudentName     string             `json:"student_name"`
}

func (q *Queries) ListSubmissions(ctx context.Context, homeworkID pgtype.UUID) ([]ListSubmissionsRow, error) {
	rows, err := q.db.Query(ctx, listSubmissions, homeworkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubmissionsRow
	for rows.Next() {
		var i ListSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeworkID,
			&i.StudentID,
			&i.AttachmentUrl,
			&i.Remarks,
			&i.Status,
			&i.TeacherFeedback,
			&i.SubmittedAt,
			&i.UpdatedAt,
			&i.StudentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const submitHomework = `-- name: SubmitHomework :one
INSERT INTO homework_submissions (
    homework_id, student_id, attachment_url, remarks
) VALUES (
    $1, $2, $3, $4
) 
ON CONFLICT (homework_id, student_id) 
DO UPDATE SET 
    attachment_url = EXCLUDED.attachment_url,
    remarks = EXCLUDED.remarks,
    submitted_at = NOW(),
    status = 'pending'
RETURNING id, homework_id, student_id, attachment_url, remarks, status, teacher_feedback, submitted_at, updated_at
`

type SubmitHomeworkParams struct {
	HomeworkID    pgtype.UUID `json:"homework_id"`
	StudentID     pgtype.UUID `json:"student_id"`
	AttachmentUrl pgtype.Text `json:"attachment_url"`
	Remarks       pgtype.Text `json:"remarks"`
}

func (q *Queries) SubmitHomework(ctx context.Context, arg SubmitHomeworkParams) (HomeworkSubmission, error) {
	row := q.db.QueryRow(ctx, submitHomework,
		arg.HomeworkID,
		arg.StudentID,
		arg.AttachmentUrl,
		arg.Remarks,
	)
	var i HomeworkSubmission
	err := row.Scan(
		&i.ID,
		&i.HomeworkID,
		&i.StudentID,
		&i.AttachmentUrl,
		&i.Remarks,
		&i.Status,
		&i.TeacherFeedback,
		&i.SubmittedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLessonPlanStatus = `-- name: UpdateLessonPlanStatus :one
UPDATE lesson_plans
SET review_status = $3, review_remarks = $4, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, subject_id, class_id, week_number, planned_topic, covered_at, review_status, review_remarks, created_at, updated_at
`

type UpdateLessonPlanStatusParams struct {
	ID            pgtype.UUID `json:"id"`
	TenantID      pgtype.UUID `json:"tenant_id"`
	ReviewStatus  string      `json:"review_status"`
	ReviewRemarks pgtype.Text `json:"review_remarks"`
}

func (q *Queries) UpdateLessonPlanStatus(ctx context.Context, arg UpdateLessonPlanStatusParams) (LessonPlan, error) {
	row := q.db.QueryRow(ctx, updateLessonPlanStatus,
		arg.ID,
		arg.TenantID,
		arg.ReviewStatus,
		arg.ReviewRemarks,
	)
	var i LessonPlan
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubjectID,
		&i.ClassID,
		&i.WeekNumber,
		&i.PlannedTopic,
		&i.CoveredAt,
		&i.ReviewStatus,
		&i.ReviewRemarks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertLessonPlan = `-- name: UpsertLessonPlan :one
INSERT INTO lesson_plans (
    tenant_id, subject_id, class_id, week_number, planned_topic, covered_at, review_status, review_remarks
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
ON CONFLICT (tenant_id, subject_id, class_id, week_number)
DO UPDATE SET 
    planned_topic = EXCLUDED.planned_topic,
    covered_at = EXCLUDED.covered_at,
    review_status = COALESCE(NULLIF(EXCLUDED.review_status, ''), lesson_plans.review_status),
    review_remarks = EXCLUDED.review_remarks,
    updated_at = NOW()
RETURNING id, tenant_id, subject_id, class_id, week_number, planned_topic, covered_at, review_status, review_remarks, created_at, updated_at
`

type UpsertLessonPlanParams struct {
	TenantID      pgtype.UUID        `json:"tenant_id"`
	SubjectID     pgtype.UUID        `json:"subject_id"`
	ClassID       pgtype.UUID        `json:"class_id"`
	WeekNumber    int32              `json:"week_number"`
	PlannedTopic  string             `json:"planned_topic"`
	CoveredAt     pgtype.Timestamptz `json:"covered_at"`
	ReviewStatus  string             `json:"review_status"`
	ReviewRemarks pgtype.Text        `json:"review_remarks"`
}

func (q *Queries) UpsertLessonPlan(ctx context.Context, arg UpsertLessonPlanParams) (LessonPlan, error) {
	row := q.db.QueryRow(ctx, upsertLessonPlan,
		arg.TenantID,
		arg.SubjectID,
		arg.ClassID,
		arg.WeekNumber,
		arg.PlannedTopic,
		arg.CoveredAt,
		arg.ReviewStatus,
		arg.ReviewRemarks,
	)
	var i LessonPlan
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubjectID,
		&i.ClassID,
		&i.WeekNumber,
		&i.PlannedTopic,
		&i.CoveredAt,
		&i.ReviewStatus,
		&i.ReviewRemarks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
