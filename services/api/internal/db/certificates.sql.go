// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: certificates.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCertificate = `-- name: CreateCertificate :one
INSERT INTO certificates (
    tenant_id, student_id, template_id, certificate_type, 
    certificate_number, issuance_date, issued_by, reason, 
    metadata, file_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tenant_id, student_id, template_id, certificate_type, certificate_number, issuance_date, issued_by, status, reason, metadata, file_id, created_at, updated_at
`

type CreateCertificateParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	StudentID         pgtype.UUID `json:"student_id"`
	TemplateID        pgtype.UUID `json:"template_id"`
	CertificateType   string      `json:"certificate_type"`
	CertificateNumber string      `json:"certificate_number"`
	IssuanceDate      pgtype.Date `json:"issuance_date"`
	IssuedBy          pgtype.UUID `json:"issued_by"`
	Reason            pgtype.Text `json:"reason"`
	Metadata          []byte      `json:"metadata"`
	FileID            pgtype.UUID `json:"file_id"`
}

func (q *Queries) CreateCertificate(ctx context.Context, arg CreateCertificateParams) (Certificate, error) {
	row := q.db.QueryRow(ctx, createCertificate,
		arg.TenantID,
		arg.StudentID,
		arg.TemplateID,
		arg.CertificateType,
		arg.CertificateNumber,
		arg.IssuanceDate,
		arg.IssuedBy,
		arg.Reason,
		arg.Metadata,
		arg.FileID,
	)
	var i Certificate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.TemplateID,
		&i.CertificateType,
		&i.CertificateNumber,
		&i.IssuanceDate,
		&i.IssuedBy,
		&i.Status,
		&i.Reason,
		&i.Metadata,
		&i.FileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCertificate = `-- name: GetCertificate :one
SELECT id, tenant_id, student_id, template_id, certificate_type, certificate_number, issuance_date, issued_by, status, reason, metadata, file_id, created_at, updated_at FROM certificates WHERE id = $1 AND tenant_id = $2
`

type GetCertificateParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCertificate(ctx context.Context, arg GetCertificateParams) (Certificate, error) {
	row := q.db.QueryRow(ctx, getCertificate, arg.ID, arg.TenantID)
	var i Certificate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.TemplateID,
		&i.CertificateType,
		&i.CertificateNumber,
		&i.IssuanceDate,
		&i.IssuedBy,
		&i.Status,
		&i.Reason,
		&i.Metadata,
		&i.FileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLastCertificateNumber = `-- name: GetLastCertificateNumber :one
SELECT certificate_number 
FROM certificates 
WHERE tenant_id = $1 AND certificate_type = $2
ORDER BY created_at DESC 
LIMIT 1
`

type GetLastCertificateNumberParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	CertificateType string      `json:"certificate_type"`
}

func (q *Queries) GetLastCertificateNumber(ctx context.Context, arg GetLastCertificateNumberParams) (string, error) {
	row := q.db.QueryRow(ctx, getLastCertificateNumber, arg.TenantID, arg.CertificateType)
	var certificate_number string
	err := row.Scan(&certificate_number)
	return certificate_number, err
}

const listCertificatesByStudent = `-- name: ListCertificatesByStudent :many
SELECT id, tenant_id, student_id, template_id, certificate_type, certificate_number, issuance_date, issued_by, status, reason, metadata, file_id, created_at, updated_at FROM certificates 
WHERE student_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
`

type ListCertificatesByStudentParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ListCertificatesByStudent(ctx context.Context, arg ListCertificatesByStudentParams) ([]Certificate, error) {
	rows, err := q.db.Query(ctx, listCertificatesByStudent, arg.StudentID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Certificate
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.TemplateID,
			&i.CertificateType,
			&i.CertificateNumber,
			&i.IssuanceDate,
			&i.IssuedBy,
			&i.Status,
			&i.Reason,
			&i.Metadata,
			&i.FileID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificatesByTenant = `-- name: ListCertificatesByTenant :many
SELECT c.id, c.tenant_id, c.student_id, c.template_id, c.certificate_type, c.certificate_number, c.issuance_date, c.issued_by, c.status, c.reason, c.metadata, c.file_id, c.created_at, c.updated_at, s.full_name as student_name, s.admission_number, u.full_name as issued_by_name
FROM certificates c
JOIN students s ON c.student_id = s.id
JOIN users u ON c.issued_by = u.id
WHERE c.tenant_id = $1
ORDER BY c.created_at DESC
`

type ListCertificatesByTenantRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	StudentID         pgtype.UUID        `json:"student_id"`
	TemplateID        pgtype.UUID        `json:"template_id"`
	CertificateType   string             `json:"certificate_type"`
	CertificateNumber string             `json:"certificate_number"`
	IssuanceDate      pgtype.Date        `json:"issuance_date"`
	IssuedBy          pgtype.UUID        `json:"issued_by"`
	Status            string             `json:"status"`
	Reason            pgtype.Text        `json:"reason"`
	Metadata          []byte             `json:"metadata"`
	FileID            pgtype.UUID        `json:"file_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	StudentName       string             `json:"student_name"`
	AdmissionNumber   string             `json:"admission_number"`
	IssuedByName      string             `json:"issued_by_name"`
}

func (q *Queries) ListCertificatesByTenant(ctx context.Context, tenantID pgtype.UUID) ([]ListCertificatesByTenantRow, error) {
	rows, err := q.db.Query(ctx, listCertificatesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCertificatesByTenantRow
	for rows.Next() {
		var i ListCertificatesByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.TemplateID,
			&i.CertificateType,
			&i.CertificateNumber,
			&i.IssuanceDate,
			&i.IssuedBy,
			&i.Status,
			&i.Reason,
			&i.Metadata,
			&i.FileID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentName,
			&i.AdmissionNumber,
			&i.IssuedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeCertificate = `-- name: RevokeCertificate :exec
UPDATE certificates 
SET status = 'revoked', updated_at = NOW() 
WHERE id = $1 AND tenant_id = $2
`

type RevokeCertificateParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) RevokeCertificate(ctx context.Context, arg RevokeCertificateParams) error {
	_, err := q.db.Exec(ctx, revokeCertificate, arg.ID, arg.TenantID)
	return err
}
