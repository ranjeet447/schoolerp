// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exams.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addExamSubject = `-- name: AddExamSubject :exec
INSERT INTO exam_subjects (
    exam_id, subject_id, max_marks, exam_date
) VALUES (
    $1, $2, $3, $4
)
`

type AddExamSubjectParams struct {
	ExamID    pgtype.UUID `json:"exam_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
	MaxMarks  int32       `json:"max_marks"`
	ExamDate  pgtype.Date `json:"exam_date"`
}

func (q *Queries) AddExamSubject(ctx context.Context, arg AddExamSubjectParams) error {
	_, err := q.db.Exec(ctx, addExamSubject,
		arg.ExamID,
		arg.SubjectID,
		arg.MaxMarks,
		arg.ExamDate,
	)
	return err
}

const createExam = `-- name: CreateExam :one

INSERT INTO exams (
    tenant_id, academic_year_id, name, start_date, end_date
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at, type
`

type CreateExamParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	Name           string      `json:"name"`
	StartDate      pgtype.Date `json:"start_date"`
	EndDate        pgtype.Date `json:"end_date"`
}


func (q *Queries) CreateExam(ctx context.Context, arg CreateExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, createExam,
		arg.TenantID,
		arg.AcademicYearID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
	)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.Type,
	)
	return i, err
}

const getExam = `-- name: GetExam :one
SELECT id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at, type FROM exams WHERE id = $1 AND tenant_id = $2
`

type GetExamParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetExam(ctx context.Context, arg GetExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, getExam, arg.ID, arg.TenantID)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.Type,
	)
	return i, err
}

const getExamMarks = `-- name: GetExamMarks :many
SELECT 
    st.id as student_id,
    st.full_name as student_name,
    me.marks_obtained,
    me.remarks
FROM students st
LEFT JOIN marks_entries me ON st.id = me.student_id AND me.exam_id = $1 AND me.subject_id = $2
WHERE st.tenant_id = $3
ORDER BY st.full_name
`

type GetExamMarksParams struct {
	ExamID    pgtype.UUID `json:"exam_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type GetExamMarksRow struct {
	StudentID     pgtype.UUID    `json:"student_id"`
	StudentName   string         `json:"student_name"`
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	Remarks       pgtype.Text    `json:"remarks"`
}

func (q *Queries) GetExamMarks(ctx context.Context, arg GetExamMarksParams) ([]GetExamMarksRow, error) {
	rows, err := q.db.Query(ctx, getExamMarks, arg.ExamID, arg.SubjectID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamMarksRow
	for rows.Next() {
		var i GetExamMarksRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.MarksObtained,
			&i.Remarks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamResultsForStudent = `-- name: GetExamResultsForStudent :many
SELECT 
    me.marks_obtained,
    es.max_marks,
    s.name as subject_name,
    e.name as exam_name
FROM marks_entries me
JOIN exam_subjects es ON me.exam_id = es.exam_id AND me.subject_id = es.subject_id
JOIN exams e ON me.exam_id = e.id
JOIN subjects s ON me.subject_id = s.id
WHERE me.student_id = $1 AND e.tenant_id = $2 AND e.status = 'published'
`

type GetExamResultsForStudentParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type GetExamResultsForStudentRow struct {
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	MaxMarks      int32          `json:"max_marks"`
	SubjectName   string         `json:"subject_name"`
	ExamName      string         `json:"exam_name"`
}

func (q *Queries) GetExamResultsForStudent(ctx context.Context, arg GetExamResultsForStudentParams) ([]GetExamResultsForStudentRow, error) {
	rows, err := q.db.Query(ctx, getExamResultsForStudent, arg.StudentID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamResultsForStudentRow
	for rows.Next() {
		var i GetExamResultsForStudentRow
		if err := rows.Scan(
			&i.MarksObtained,
			&i.MaxMarks,
			&i.SubjectName,
			&i.ExamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMarksForAggregation = `-- name: GetMarksForAggregation :many
SELECT 
    me.student_id,
    me.subject_id,
    me.marks_obtained,
    es.max_marks,
    e.type as exam_type
FROM marks_entries me
JOIN exams e ON me.exam_id = e.id
JOIN exam_subjects es ON me.exam_id = es.exam_id AND me.subject_id = es.subject_id
WHERE e.tenant_id = $1 AND e.academic_year_id = $2 AND e.status = 'published'
`

type GetMarksForAggregationParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
}

type GetMarksForAggregationRow struct {
	StudentID     pgtype.UUID    `json:"student_id"`
	SubjectID     pgtype.UUID    `json:"subject_id"`
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	MaxMarks      int32          `json:"max_marks"`
	ExamType      string         `json:"exam_type"`
}

func (q *Queries) GetMarksForAggregation(ctx context.Context, arg GetMarksForAggregationParams) ([]GetMarksForAggregationRow, error) {
	rows, err := q.db.Query(ctx, getMarksForAggregation, arg.TenantID, arg.AcademicYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMarksForAggregationRow
	for rows.Next() {
		var i GetMarksForAggregationRow
		if err := rows.Scan(
			&i.StudentID,
			&i.SubjectID,
			&i.MarksObtained,
			&i.MaxMarks,
			&i.ExamType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExamSubjects = `-- name: ListExamSubjects :many
SELECT es.exam_id, es.subject_id, es.max_marks, es.exam_date, s.name as subject_name
FROM exam_subjects es
JOIN subjects s ON es.subject_id = s.id
WHERE es.exam_id = $1
`

type ListExamSubjectsRow struct {
	ExamID      pgtype.UUID `json:"exam_id"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	MaxMarks    int32       `json:"max_marks"`
	ExamDate    pgtype.Date `json:"exam_date"`
	SubjectName string      `json:"subject_name"`
}

func (q *Queries) ListExamSubjects(ctx context.Context, examID pgtype.UUID) ([]ListExamSubjectsRow, error) {
	rows, err := q.db.Query(ctx, listExamSubjects, examID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExamSubjectsRow
	for rows.Next() {
		var i ListExamSubjectsRow
		if err := rows.Scan(
			&i.ExamID,
			&i.SubjectID,
			&i.MaxMarks,
			&i.ExamDate,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExams = `-- name: ListExams :many
SELECT id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at, type FROM exams WHERE tenant_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListExams(ctx context.Context, tenantID pgtype.UUID) ([]Exam, error) {
	rows, err := q.db.Query(ctx, listExams, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exam
	for rows.Next() {
		var i Exam
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AcademicYearID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGradingScales = `-- name: ListGradingScales :many
SELECT id, tenant_id, min_percent, max_percent, grade_label, grade_point, created_at FROM grading_scales WHERE tenant_id = $1 ORDER BY min_percent DESC
`

func (q *Queries) ListGradingScales(ctx context.Context, tenantID pgtype.UUID) ([]GradingScale, error) {
	rows, err := q.db.Query(ctx, listGradingScales, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GradingScale
	for rows.Next() {
		var i GradingScale
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.MinPercent,
			&i.MaxPercent,
			&i.GradeLabel,
			&i.GradePoint,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWeightageConfigs = `-- name: ListWeightageConfigs :many
SELECT id, tenant_id, academic_year_id, exam_type, weight_percentage, created_at FROM exam_weightage_config WHERE tenant_id = $1 AND academic_year_id = $2
`

type ListWeightageConfigsParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
}

func (q *Queries) ListWeightageConfigs(ctx context.Context, arg ListWeightageConfigsParams) ([]ExamWeightageConfig, error) {
	rows, err := q.db.Query(ctx, listWeightageConfigs, arg.TenantID, arg.AcademicYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExamWeightageConfig
	for rows.Next() {
		var i ExamWeightageConfig
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AcademicYearID,
			&i.ExamType,
			&i.WeightPercentage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishExam = `-- name: PublishExam :one
UPDATE exams
SET status = 'published'
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at, type
`

type PublishExamParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) PublishExam(ctx context.Context, arg PublishExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, publishExam, arg.ID, arg.TenantID)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.Type,
	)
	return i, err
}

const upsertGradingScale = `-- name: UpsertGradingScale :one
INSERT INTO grading_scales (tenant_id, min_percent, max_percent, grade_label, grade_point)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (tenant_id, grade_label) DO UPDATE
SET min_percent = EXCLUDED.min_percent, 
    max_percent = EXCLUDED.max_percent,
    grade_point = EXCLUDED.grade_point
RETURNING id, tenant_id, min_percent, max_percent, grade_label, grade_point, created_at
`

type UpsertGradingScaleParams struct {
	TenantID   pgtype.UUID    `json:"tenant_id"`
	MinPercent pgtype.Numeric `json:"min_percent"`
	MaxPercent pgtype.Numeric `json:"max_percent"`
	GradeLabel string         `json:"grade_label"`
	GradePoint pgtype.Numeric `json:"grade_point"`
}

func (q *Queries) UpsertGradingScale(ctx context.Context, arg UpsertGradingScaleParams) (GradingScale, error) {
	row := q.db.QueryRow(ctx, upsertGradingScale,
		arg.TenantID,
		arg.MinPercent,
		arg.MaxPercent,
		arg.GradeLabel,
		arg.GradePoint,
	)
	var i GradingScale
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.MinPercent,
		&i.MaxPercent,
		&i.GradeLabel,
		&i.GradePoint,
		&i.CreatedAt,
	)
	return i, err
}

const upsertMarks = `-- name: UpsertMarks :exec
INSERT INTO marks_entries (
    exam_id, subject_id, student_id, marks_obtained, entered_by
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (exam_id, subject_id, student_id)
DO UPDATE SET marks_obtained = EXCLUDED.marks_obtained, entered_by = EXCLUDED.entered_by
`

type UpsertMarksParams struct {
	ExamID        pgtype.UUID    `json:"exam_id"`
	SubjectID     pgtype.UUID    `json:"subject_id"`
	StudentID     pgtype.UUID    `json:"student_id"`
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	EnteredBy     pgtype.UUID    `json:"entered_by"`
}

func (q *Queries) UpsertMarks(ctx context.Context, arg UpsertMarksParams) error {
	_, err := q.db.Exec(ctx, upsertMarks,
		arg.ExamID,
		arg.SubjectID,
		arg.StudentID,
		arg.MarksObtained,
		arg.EnteredBy,
	)
	return err
}

const upsertMarksAggregate = `-- name: UpsertMarksAggregate :one
INSERT INTO marks_aggregates (tenant_id, student_id, academic_year_id, subject_id, aggregate_marks, grade_label)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (student_id, academic_year_id, subject_id) DO UPDATE
SET aggregate_marks = EXCLUDED.aggregate_marks,
    grade_label = EXCLUDED.grade_label,
    calculated_at = NOW()
RETURNING id, tenant_id, student_id, academic_year_id, subject_id, aggregate_marks, grade_label, calculated_at
`

type UpsertMarksAggregateParams struct {
	TenantID       pgtype.UUID    `json:"tenant_id"`
	StudentID      pgtype.UUID    `json:"student_id"`
	AcademicYearID pgtype.UUID    `json:"academic_year_id"`
	SubjectID      pgtype.UUID    `json:"subject_id"`
	AggregateMarks pgtype.Numeric `json:"aggregate_marks"`
	GradeLabel     pgtype.Text    `json:"grade_label"`
}

func (q *Queries) UpsertMarksAggregate(ctx context.Context, arg UpsertMarksAggregateParams) (MarksAggregate, error) {
	row := q.db.QueryRow(ctx, upsertMarksAggregate,
		arg.TenantID,
		arg.StudentID,
		arg.AcademicYearID,
		arg.SubjectID,
		arg.AggregateMarks,
		arg.GradeLabel,
	)
	var i MarksAggregate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.AcademicYearID,
		&i.SubjectID,
		&i.AggregateMarks,
		&i.GradeLabel,
		&i.CalculatedAt,
	)
	return i, err
}

const upsertWeightageConfig = `-- name: UpsertWeightageConfig :one
INSERT INTO exam_weightage_config (tenant_id, academic_year_id, exam_type, weight_percentage)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id, academic_year_id, exam_type) DO UPDATE
SET weight_percentage = EXCLUDED.weight_percentage
RETURNING id, tenant_id, academic_year_id, exam_type, weight_percentage, created_at
`

type UpsertWeightageConfigParams struct {
	TenantID         pgtype.UUID    `json:"tenant_id"`
	AcademicYearID   pgtype.UUID    `json:"academic_year_id"`
	ExamType         string         `json:"exam_type"`
	WeightPercentage pgtype.Numeric `json:"weight_percentage"`
}

func (q *Queries) UpsertWeightageConfig(ctx context.Context, arg UpsertWeightageConfigParams) (ExamWeightageConfig, error) {
	row := q.db.QueryRow(ctx, upsertWeightageConfig,
		arg.TenantID,
		arg.AcademicYearID,
		arg.ExamType,
		arg.WeightPercentage,
	)
	var i ExamWeightageConfig
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.ExamType,
		&i.WeightPercentage,
		&i.CreatedAt,
	)
	return i, err
}
