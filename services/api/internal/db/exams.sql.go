// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: exams.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addExamSubject = `-- name: AddExamSubject :exec
INSERT INTO exam_subjects (
    exam_id, subject_id, max_marks, exam_date
) VALUES (
    $1, $2, $3, $4
)
`

type AddExamSubjectParams struct {
	ExamID    pgtype.UUID `json:"exam_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
	MaxMarks  int32       `json:"max_marks"`
	ExamDate  pgtype.Date `json:"exam_date"`
}

func (q *Queries) AddExamSubject(ctx context.Context, arg AddExamSubjectParams) error {
	_, err := q.db.Exec(ctx, addExamSubject,
		arg.ExamID,
		arg.SubjectID,
		arg.MaxMarks,
		arg.ExamDate,
	)
	return err
}

const createExam = `-- name: CreateExam :one
INSERT INTO exams (
    tenant_id, academic_year_id, name, start_date, end_date
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at
`

type CreateExamParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	Name           string      `json:"name"`
	StartDate      pgtype.Date `json:"start_date"`
	EndDate        pgtype.Date `json:"end_date"`
}

func (q *Queries) CreateExam(ctx context.Context, arg CreateExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, createExam,
		arg.TenantID,
		arg.AcademicYearID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
	)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getExam = `-- name: GetExam :one
SELECT id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at FROM exams WHERE id = $1 AND tenant_id = $2
`

type GetExamParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetExam(ctx context.Context, arg GetExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, getExam, arg.ID, arg.TenantID)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getExamMarks = `-- name: GetExamMarks :many
SELECT 
    st.id as student_id,
    st.full_name as student_name,
    me.marks_obtained,
    me.remarks
FROM students st
LEFT JOIN marks_entries me ON st.id = me.student_id AND me.exam_id = $1 AND me.subject_id = $2
WHERE st.tenant_id = $3
ORDER BY st.full_name
`

type GetExamMarksParams struct {
	ExamID    pgtype.UUID `json:"exam_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type GetExamMarksRow struct {
	StudentID     pgtype.UUID    `json:"student_id"`
	StudentName   string         `json:"student_name"`
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	Remarks       pgtype.Text    `json:"remarks"`
}

func (q *Queries) GetExamMarks(ctx context.Context, arg GetExamMarksParams) ([]GetExamMarksRow, error) {
	rows, err := q.db.Query(ctx, getExamMarks, arg.ExamID, arg.SubjectID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamMarksRow
	for rows.Next() {
		var i GetExamMarksRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.MarksObtained,
			&i.Remarks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamResultsForStudent = `-- name: GetExamResultsForStudent :many
SELECT 
    me.marks_obtained,
    es.max_marks,
    s.name as subject_name,
    e.name as exam_name
FROM marks_entries me
JOIN exam_subjects es ON me.exam_id = es.exam_id AND me.subject_id = es.subject_id
JOIN exams e ON me.exam_id = e.id
JOIN subjects s ON me.subject_id = s.id
WHERE me.student_id = $1 AND e.tenant_id = $2 AND e.status = 'published'
`

type GetExamResultsForStudentParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type GetExamResultsForStudentRow struct {
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	MaxMarks      int32          `json:"max_marks"`
	SubjectName   string         `json:"subject_name"`
	ExamName      string         `json:"exam_name"`
}

func (q *Queries) GetExamResultsForStudent(ctx context.Context, arg GetExamResultsForStudentParams) ([]GetExamResultsForStudentRow, error) {
	rows, err := q.db.Query(ctx, getExamResultsForStudent, arg.StudentID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamResultsForStudentRow
	for rows.Next() {
		var i GetExamResultsForStudentRow
		if err := rows.Scan(
			&i.MarksObtained,
			&i.MaxMarks,
			&i.SubjectName,
			&i.ExamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExamSubjects = `-- name: ListExamSubjects :many
SELECT es.exam_id, es.subject_id, es.max_marks, es.exam_date, s.name as subject_name
FROM exam_subjects es
JOIN subjects s ON es.subject_id = s.id
WHERE es.exam_id = $1
`

type ListExamSubjectsRow struct {
	ExamID      pgtype.UUID `json:"exam_id"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	MaxMarks    int32       `json:"max_marks"`
	ExamDate    pgtype.Date `json:"exam_date"`
	SubjectName string      `json:"subject_name"`
}

func (q *Queries) ListExamSubjects(ctx context.Context, examID pgtype.UUID) ([]ListExamSubjectsRow, error) {
	rows, err := q.db.Query(ctx, listExamSubjects, examID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExamSubjectsRow
	for rows.Next() {
		var i ListExamSubjectsRow
		if err := rows.Scan(
			&i.ExamID,
			&i.SubjectID,
			&i.MaxMarks,
			&i.ExamDate,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExams = `-- name: ListExams :many
SELECT id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at FROM exams WHERE tenant_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListExams(ctx context.Context, tenantID pgtype.UUID) ([]Exam, error) {
	rows, err := q.db.Query(ctx, listExams, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exam
	for rows.Next() {
		var i Exam
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AcademicYearID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishExam = `-- name: PublishExam :one
UPDATE exams
SET status = 'published'
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at
`

type PublishExamParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) PublishExam(ctx context.Context, arg PublishExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, publishExam, arg.ID, arg.TenantID)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const upsertMarks = `-- name: UpsertMarks :exec
INSERT INTO marks_entries (
    exam_id, subject_id, student_id, marks_obtained, entered_by
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (exam_id, subject_id, student_id)
DO UPDATE SET marks_obtained = EXCLUDED.marks_obtained, entered_by = EXCLUDED.entered_by
`

type UpsertMarksParams struct {
	ExamID        pgtype.UUID    `json:"exam_id"`
	SubjectID     pgtype.UUID    `json:"subject_id"`
	StudentID     pgtype.UUID    `json:"student_id"`
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	EnteredBy     pgtype.UUID    `json:"entered_by"`
}

func (q *Queries) UpsertMarks(ctx context.Context, arg UpsertMarksParams) error {
	_, err := q.db.Exec(ctx, upsertMarks,
		arg.ExamID,
		arg.SubjectID,
		arg.StudentID,
		arg.MarksObtained,
		arg.EnteredBy,
	)
	return err
}
