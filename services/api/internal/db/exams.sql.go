// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exams.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addExamSubject = `-- name: AddExamSubject :exec
INSERT INTO exam_subjects (
    exam_id, subject_id, max_marks, exam_date
) VALUES (
    $1, $2, $3, $4
)
`

type AddExamSubjectParams struct {
	ExamID    pgtype.UUID `json:"exam_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
	MaxMarks  int32       `json:"max_marks"`
	ExamDate  pgtype.Date `json:"exam_date"`
}

func (q *Queries) AddExamSubject(ctx context.Context, arg AddExamSubjectParams) error {
	_, err := q.db.Exec(ctx, addExamSubject,
		arg.ExamID,
		arg.SubjectID,
		arg.MaxMarks,
		arg.ExamDate,
	)
	return err
}

const addQuestionToPaper = `-- name: AddQuestionToPaper :exec
INSERT INTO exam_paper_questions (paper_id, question_id, sort_order)
VALUES ($1, $2, $3)
`

type AddQuestionToPaperParams struct {
	PaperID    pgtype.UUID `json:"paper_id"`
	QuestionID pgtype.UUID `json:"question_id"`
	SortOrder  pgtype.Int4 `json:"sort_order"`
}

func (q *Queries) AddQuestionToPaper(ctx context.Context, arg AddQuestionToPaperParams) error {
	_, err := q.db.Exec(ctx, addQuestionToPaper, arg.PaperID, arg.QuestionID, arg.SortOrder)
	return err
}

const createExam = `-- name: CreateExam :one
INSERT INTO exams (
    tenant_id, academic_year_id, name, start_date, end_date
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at, type
`

type CreateExamParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	Name           string      `json:"name"`
	StartDate      pgtype.Date `json:"start_date"`
	EndDate        pgtype.Date `json:"end_date"`
}

func (q *Queries) CreateExam(ctx context.Context, arg CreateExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, createExam,
		arg.TenantID,
		arg.AcademicYearID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
	)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.Type,
	)
	return i, err
}

const createQuestionBankEntry = `-- name: CreateQuestionBankEntry :one
INSERT INTO exam_question_bank (
    tenant_id, subject_id, topic, difficulty, question_type,
    question_text, options, correct_answer, marks
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, subject_id, topic, difficulty, question_type, question_text, options, correct_answer, marks, created_at, updated_at
`

type CreateQuestionBankEntryParams struct {
	TenantID      pgtype.UUID    `json:"tenant_id"`
	SubjectID     pgtype.UUID    `json:"subject_id"`
	Topic         pgtype.Text    `json:"topic"`
	Difficulty    string         `json:"difficulty"`
	QuestionType  string         `json:"question_type"`
	QuestionText  string         `json:"question_text"`
	Options       []byte         `json:"options"`
	CorrectAnswer pgtype.Text    `json:"correct_answer"`
	Marks         pgtype.Numeric `json:"marks"`
}

func (q *Queries) CreateQuestionBankEntry(ctx context.Context, arg CreateQuestionBankEntryParams) (ExamQuestionBank, error) {
	row := q.db.QueryRow(ctx, createQuestionBankEntry,
		arg.TenantID,
		arg.SubjectID,
		arg.Topic,
		arg.Difficulty,
		arg.QuestionType,
		arg.QuestionText,
		arg.Options,
		arg.CorrectAnswer,
		arg.Marks,
	)
	var i ExamQuestionBank
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubjectID,
		&i.Topic,
		&i.Difficulty,
		&i.QuestionType,
		&i.QuestionText,
		&i.Options,
		&i.CorrectAnswer,
		&i.Marks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQuestionPaper = `-- name: CreateQuestionPaper :one
INSERT INTO exam_question_papers (
    tenant_id, exam_id, subject_id, set_name, file_path, 
    is_encrypted, unlock_at, is_previous_year, academic_year_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, exam_id, subject_id, set_name, file_path, is_encrypted, unlock_at, is_previous_year, academic_year_id, created_at, updated_at
`

type CreateQuestionPaperParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ExamID         pgtype.UUID        `json:"exam_id"`
	SubjectID      pgtype.UUID        `json:"subject_id"`
	SetName        string             `json:"set_name"`
	FilePath       string             `json:"file_path"`
	IsEncrypted    pgtype.Bool        `json:"is_encrypted"`
	UnlockAt       pgtype.Timestamptz `json:"unlock_at"`
	IsPreviousYear pgtype.Bool        `json:"is_previous_year"`
	AcademicYearID pgtype.UUID        `json:"academic_year_id"`
}

// Question Paper Management
func (q *Queries) CreateQuestionPaper(ctx context.Context, arg CreateQuestionPaperParams) (ExamQuestionPaper, error) {
	row := q.db.QueryRow(ctx, createQuestionPaper,
		arg.TenantID,
		arg.ExamID,
		arg.SubjectID,
		arg.SetName,
		arg.FilePath,
		arg.IsEncrypted,
		arg.UnlockAt,
		arg.IsPreviousYear,
		arg.AcademicYearID,
	)
	var i ExamQuestionPaper
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ExamID,
		&i.SubjectID,
		&i.SetName,
		&i.FilePath,
		&i.IsEncrypted,
		&i.UnlockAt,
		&i.IsPreviousYear,
		&i.AcademicYearID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExam = `-- name: GetExam :one
SELECT id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at, type FROM exams WHERE id = $1 AND tenant_id = $2
`

type GetExamParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetExam(ctx context.Context, arg GetExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, getExam, arg.ID, arg.TenantID)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.Type,
	)
	return i, err
}

const getExamMarks = `-- name: GetExamMarks :many
SELECT 
    st.id as student_id,
    st.full_name as student_name,
    me.marks_obtained,
    me.remarks
FROM students st
LEFT JOIN marks_entries me ON st.id = me.student_id AND me.exam_id = $1 AND me.subject_id = $2
WHERE st.tenant_id = $3
ORDER BY st.full_name
`

type GetExamMarksParams struct {
	ExamID    pgtype.UUID `json:"exam_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type GetExamMarksRow struct {
	StudentID     pgtype.UUID    `json:"student_id"`
	StudentName   string         `json:"student_name"`
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	Remarks       pgtype.Text    `json:"remarks"`
}

func (q *Queries) GetExamMarks(ctx context.Context, arg GetExamMarksParams) ([]GetExamMarksRow, error) {
	rows, err := q.db.Query(ctx, getExamMarks, arg.ExamID, arg.SubjectID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamMarksRow
	for rows.Next() {
		var i GetExamMarksRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.MarksObtained,
			&i.Remarks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamResultsForStudent = `-- name: GetExamResultsForStudent :many
SELECT 
    me.marks_obtained,
    es.max_marks,
    s.name as subject_name,
    e.name as exam_name
FROM marks_entries me
JOIN exam_subjects es ON me.exam_id = es.exam_id AND me.subject_id = es.subject_id
JOIN exams e ON me.exam_id = e.id
JOIN subjects s ON me.subject_id = s.id
WHERE me.student_id = $1 AND e.tenant_id = $2 AND e.status = 'published'
`

type GetExamResultsForStudentParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type GetExamResultsForStudentRow struct {
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	MaxMarks      int32          `json:"max_marks"`
	SubjectName   string         `json:"subject_name"`
	ExamName      string         `json:"exam_name"`
}

func (q *Queries) GetExamResultsForStudent(ctx context.Context, arg GetExamResultsForStudentParams) ([]GetExamResultsForStudentRow, error) {
	rows, err := q.db.Query(ctx, getExamResultsForStudent, arg.StudentID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamResultsForStudentRow
	for rows.Next() {
		var i GetExamResultsForStudentRow
		if err := rows.Scan(
			&i.MarksObtained,
			&i.MaxMarks,
			&i.SubjectName,
			&i.ExamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMarksForAggregation = `-- name: GetMarksForAggregation :many
SELECT 
    me.student_id,
    me.subject_id,
    me.marks_obtained,
    es.max_marks,
    e.type as exam_type
FROM marks_entries me
JOIN exams e ON me.exam_id = e.id
JOIN exam_subjects es ON me.exam_id = es.exam_id AND me.subject_id = es.subject_id
WHERE e.tenant_id = $1 AND e.academic_year_id = $2 AND e.status = 'published'
`

type GetMarksForAggregationParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
}

type GetMarksForAggregationRow struct {
	StudentID     pgtype.UUID    `json:"student_id"`
	SubjectID     pgtype.UUID    `json:"subject_id"`
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	MaxMarks      int32          `json:"max_marks"`
	ExamType      string         `json:"exam_type"`
}

func (q *Queries) GetMarksForAggregation(ctx context.Context, arg GetMarksForAggregationParams) ([]GetMarksForAggregationRow, error) {
	rows, err := q.db.Query(ctx, getMarksForAggregation, arg.TenantID, arg.AcademicYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMarksForAggregationRow
	for rows.Next() {
		var i GetMarksForAggregationRow
		if err := rows.Scan(
			&i.StudentID,
			&i.SubjectID,
			&i.MarksObtained,
			&i.MaxMarks,
			&i.ExamType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaperQuestions = `-- name: GetPaperQuestions :many
SELECT qb.id, qb.tenant_id, qb.subject_id, qb.topic, qb.difficulty, qb.question_type, qb.question_text, qb.options, qb.correct_answer, qb.marks, qb.created_at, qb.updated_at, pq.sort_order
FROM exam_paper_questions pq
JOIN exam_question_bank qb ON pq.question_id = qb.id
WHERE pq.paper_id = $1
ORDER BY pq.sort_order
`

type GetPaperQuestionsRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	SubjectID     pgtype.UUID        `json:"subject_id"`
	Topic         pgtype.Text        `json:"topic"`
	Difficulty    string             `json:"difficulty"`
	QuestionType  string             `json:"question_type"`
	QuestionText  string             `json:"question_text"`
	Options       []byte             `json:"options"`
	CorrectAnswer pgtype.Text        `json:"correct_answer"`
	Marks         pgtype.Numeric     `json:"marks"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	SortOrder     pgtype.Int4        `json:"sort_order"`
}

func (q *Queries) GetPaperQuestions(ctx context.Context, paperID pgtype.UUID) ([]GetPaperQuestionsRow, error) {
	rows, err := q.db.Query(ctx, getPaperQuestions, paperID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaperQuestionsRow
	for rows.Next() {
		var i GetPaperQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubjectID,
			&i.Topic,
			&i.Difficulty,
			&i.QuestionType,
			&i.QuestionText,
			&i.Options,
			&i.CorrectAnswer,
			&i.Marks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionPaper = `-- name: GetQuestionPaper :one
SELECT id, tenant_id, exam_id, subject_id, set_name, file_path, is_encrypted, unlock_at, is_previous_year, academic_year_id, created_at, updated_at FROM exam_question_papers WHERE id = $1 AND tenant_id = $2
`

type GetQuestionPaperParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetQuestionPaper(ctx context.Context, arg GetQuestionPaperParams) (ExamQuestionPaper, error) {
	row := q.db.QueryRow(ctx, getQuestionPaper, arg.ID, arg.TenantID)
	var i ExamQuestionPaper
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ExamID,
		&i.SubjectID,
		&i.SetName,
		&i.FilePath,
		&i.IsEncrypted,
		&i.UnlockAt,
		&i.IsPreviousYear,
		&i.AcademicYearID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRandomQuestions = `-- name: GetRandomQuestions :many
SELECT id, tenant_id, subject_id, topic, difficulty, question_type, question_text, options, correct_answer, marks, created_at, updated_at FROM exam_question_bank
WHERE tenant_id = $1
  AND subject_id = $2
  AND ($3::TEXT = '' OR topic = $3)
  AND ($4::TEXT = '' OR difficulty = $4)
  AND ($5::TEXT = '' OR question_type = $5)
ORDER BY RANDOM()
LIMIT $6
`

type GetRandomQuestionsParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	SubjectID    pgtype.UUID `json:"subject_id"`
	Topic        string      `json:"topic"`
	Difficulty   string      `json:"difficulty"`
	QuestionType string      `json:"question_type"`
	LimitCount   int32       `json:"limit_count"`
}

func (q *Queries) GetRandomQuestions(ctx context.Context, arg GetRandomQuestionsParams) ([]ExamQuestionBank, error) {
	rows, err := q.db.Query(ctx, getRandomQuestions,
		arg.TenantID,
		arg.SubjectID,
		arg.Topic,
		arg.Difficulty,
		arg.QuestionType,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExamQuestionBank
	for rows.Next() {
		var i ExamQuestionBank
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubjectID,
			&i.Topic,
			&i.Difficulty,
			&i.QuestionType,
			&i.QuestionText,
			&i.Options,
			&i.CorrectAnswer,
			&i.Marks,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExamSubjects = `-- name: ListExamSubjects :many
SELECT es.exam_id, es.subject_id, es.max_marks, es.exam_date, s.name as subject_name
FROM exam_subjects es
JOIN subjects s ON es.subject_id = s.id
WHERE es.exam_id = $1
`

type ListExamSubjectsRow struct {
	ExamID      pgtype.UUID `json:"exam_id"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	MaxMarks    int32       `json:"max_marks"`
	ExamDate    pgtype.Date `json:"exam_date"`
	SubjectName string      `json:"subject_name"`
}

func (q *Queries) ListExamSubjects(ctx context.Context, examID pgtype.UUID) ([]ListExamSubjectsRow, error) {
	rows, err := q.db.Query(ctx, listExamSubjects, examID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExamSubjectsRow
	for rows.Next() {
		var i ListExamSubjectsRow
		if err := rows.Scan(
			&i.ExamID,
			&i.SubjectID,
			&i.MaxMarks,
			&i.ExamDate,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExams = `-- name: ListExams :many
SELECT id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at, type FROM exams WHERE tenant_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListExams(ctx context.Context, tenantID pgtype.UUID) ([]Exam, error) {
	rows, err := q.db.Query(ctx, listExams, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exam
	for rows.Next() {
		var i Exam
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AcademicYearID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGradingScales = `-- name: ListGradingScales :many
SELECT id, tenant_id, min_percent, max_percent, grade_label, grade_point, created_at FROM grading_scales WHERE tenant_id = $1 ORDER BY min_percent DESC
`

func (q *Queries) ListGradingScales(ctx context.Context, tenantID pgtype.UUID) ([]GradingScale, error) {
	rows, err := q.db.Query(ctx, listGradingScales, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GradingScale
	for rows.Next() {
		var i GradingScale
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.MinPercent,
			&i.MaxPercent,
			&i.GradeLabel,
			&i.GradePoint,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionBank = `-- name: ListQuestionBank :many
SELECT id, tenant_id, subject_id, topic, difficulty, question_type, question_text, options, correct_answer, marks, created_at, updated_at FROM exam_question_bank
WHERE tenant_id = $1 
AND ($2::BOOLEAN = false OR subject_id = $3::UUID)
AND ($4::BOOLEAN = false OR topic = $5::TEXT)
ORDER BY created_at DESC
`

type ListQuestionBankParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  bool        `json:"column_2"`
	Column3  pgtype.UUID `json:"column_3"`
	Column4  bool        `json:"column_4"`
	Column5  string      `json:"column_5"`
}

func (q *Queries) ListQuestionBank(ctx context.Context, arg ListQuestionBankParams) ([]ExamQuestionBank, error) {
	rows, err := q.db.Query(ctx, listQuestionBank,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExamQuestionBank
	for rows.Next() {
		var i ExamQuestionBank
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubjectID,
			&i.Topic,
			&i.Difficulty,
			&i.QuestionType,
			&i.QuestionText,
			&i.Options,
			&i.CorrectAnswer,
			&i.Marks,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionPapers = `-- name: ListQuestionPapers :many
SELECT qp.id, qp.tenant_id, qp.exam_id, qp.subject_id, qp.set_name, qp.file_path, qp.is_encrypted, qp.unlock_at, qp.is_previous_year, qp.academic_year_id, qp.created_at, qp.updated_at, s.name as subject_name, e.name as exam_name
FROM exam_question_papers qp
LEFT JOIN subjects s ON s.id = qp.subject_id
LEFT JOIN exams e ON e.id = qp.exam_id
WHERE qp.tenant_id = $1 
  AND ($2::BOOLEAN = false OR qp.exam_id = $3::UUID)
ORDER BY qp.created_at DESC
`

type ListQuestionPapersParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	FilterExam bool        `json:"filter_exam"`
	ExamID     pgtype.UUID `json:"exam_id"`
}

type ListQuestionPapersRow struct {
	ID             pgtype.UUID        `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ExamID         pgtype.UUID        `json:"exam_id"`
	SubjectID      pgtype.UUID        `json:"subject_id"`
	SetName        string             `json:"set_name"`
	FilePath       string             `json:"file_path"`
	IsEncrypted    pgtype.Bool        `json:"is_encrypted"`
	UnlockAt       pgtype.Timestamptz `json:"unlock_at"`
	IsPreviousYear pgtype.Bool        `json:"is_previous_year"`
	AcademicYearID pgtype.UUID        `json:"academic_year_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	SubjectName    pgtype.Text        `json:"subject_name"`
	ExamName       pgtype.Text        `json:"exam_name"`
}

func (q *Queries) ListQuestionPapers(ctx context.Context, arg ListQuestionPapersParams) ([]ListQuestionPapersRow, error) {
	rows, err := q.db.Query(ctx, listQuestionPapers, arg.TenantID, arg.FilterExam, arg.ExamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListQuestionPapersRow
	for rows.Next() {
		var i ListQuestionPapersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ExamID,
			&i.SubjectID,
			&i.SetName,
			&i.FilePath,
			&i.IsEncrypted,
			&i.UnlockAt,
			&i.IsPreviousYear,
			&i.AcademicYearID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubjectName,
			&i.ExamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWeightageConfigs = `-- name: ListWeightageConfigs :many
SELECT id, tenant_id, academic_year_id, exam_type, weight_percentage, created_at FROM exam_weightage_config WHERE tenant_id = $1 AND academic_year_id = $2
`

type ListWeightageConfigsParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
}

func (q *Queries) ListWeightageConfigs(ctx context.Context, arg ListWeightageConfigsParams) ([]ExamWeightageConfig, error) {
	rows, err := q.db.Query(ctx, listWeightageConfigs, arg.TenantID, arg.AcademicYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExamWeightageConfig
	for rows.Next() {
		var i ExamWeightageConfig
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AcademicYearID,
			&i.ExamType,
			&i.WeightPercentage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logPaperAccess = `-- name: LogPaperAccess :exec
INSERT INTO paper_access_logs (paper_id, user_id, ip_address, user_agent)
VALUES ($1, $2, $3, $4)
`

type LogPaperAccessParams struct {
	PaperID   pgtype.UUID `json:"paper_id"`
	UserID    pgtype.UUID `json:"user_id"`
	IpAddress pgtype.Text `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
}

func (q *Queries) LogPaperAccess(ctx context.Context, arg LogPaperAccessParams) error {
	_, err := q.db.Exec(ctx, logPaperAccess,
		arg.PaperID,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
	)
	return err
}

const publishExam = `-- name: PublishExam :one
UPDATE exams
SET status = 'published'
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, academic_year_id, name, start_date, end_date, status, created_at, type
`

type PublishExamParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) PublishExam(ctx context.Context, arg PublishExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, publishExam, arg.ID, arg.TenantID)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.Type,
	)
	return i, err
}

const upsertGradingScale = `-- name: UpsertGradingScale :one
INSERT INTO grading_scales (tenant_id, min_percent, max_percent, grade_label, grade_point)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (tenant_id, grade_label) DO UPDATE
SET min_percent = EXCLUDED.min_percent, 
    max_percent = EXCLUDED.max_percent,
    grade_point = EXCLUDED.grade_point
RETURNING id, tenant_id, min_percent, max_percent, grade_label, grade_point, created_at
`

type UpsertGradingScaleParams struct {
	TenantID   pgtype.UUID    `json:"tenant_id"`
	MinPercent pgtype.Numeric `json:"min_percent"`
	MaxPercent pgtype.Numeric `json:"max_percent"`
	GradeLabel string         `json:"grade_label"`
	GradePoint pgtype.Numeric `json:"grade_point"`
}

func (q *Queries) UpsertGradingScale(ctx context.Context, arg UpsertGradingScaleParams) (GradingScale, error) {
	row := q.db.QueryRow(ctx, upsertGradingScale,
		arg.TenantID,
		arg.MinPercent,
		arg.MaxPercent,
		arg.GradeLabel,
		arg.GradePoint,
	)
	var i GradingScale
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.MinPercent,
		&i.MaxPercent,
		&i.GradeLabel,
		&i.GradePoint,
		&i.CreatedAt,
	)
	return i, err
}

const upsertMarks = `-- name: UpsertMarks :exec
INSERT INTO marks_entries (
    exam_id, subject_id, student_id, marks_obtained, entered_by
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (exam_id, subject_id, student_id)
DO UPDATE SET marks_obtained = EXCLUDED.marks_obtained, entered_by = EXCLUDED.entered_by
`

type UpsertMarksParams struct {
	ExamID        pgtype.UUID    `json:"exam_id"`
	SubjectID     pgtype.UUID    `json:"subject_id"`
	StudentID     pgtype.UUID    `json:"student_id"`
	MarksObtained pgtype.Numeric `json:"marks_obtained"`
	EnteredBy     pgtype.UUID    `json:"entered_by"`
}

func (q *Queries) UpsertMarks(ctx context.Context, arg UpsertMarksParams) error {
	_, err := q.db.Exec(ctx, upsertMarks,
		arg.ExamID,
		arg.SubjectID,
		arg.StudentID,
		arg.MarksObtained,
		arg.EnteredBy,
	)
	return err
}

const upsertMarksAggregate = `-- name: UpsertMarksAggregate :one
INSERT INTO marks_aggregates (tenant_id, student_id, academic_year_id, subject_id, aggregate_marks, grade_label)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (student_id, academic_year_id, subject_id) DO UPDATE
SET aggregate_marks = EXCLUDED.aggregate_marks,
    grade_label = EXCLUDED.grade_label,
    calculated_at = NOW()
RETURNING id, tenant_id, student_id, academic_year_id, subject_id, aggregate_marks, grade_label, calculated_at
`

type UpsertMarksAggregateParams struct {
	TenantID       pgtype.UUID    `json:"tenant_id"`
	StudentID      pgtype.UUID    `json:"student_id"`
	AcademicYearID pgtype.UUID    `json:"academic_year_id"`
	SubjectID      pgtype.UUID    `json:"subject_id"`
	AggregateMarks pgtype.Numeric `json:"aggregate_marks"`
	GradeLabel     pgtype.Text    `json:"grade_label"`
}

func (q *Queries) UpsertMarksAggregate(ctx context.Context, arg UpsertMarksAggregateParams) (MarksAggregate, error) {
	row := q.db.QueryRow(ctx, upsertMarksAggregate,
		arg.TenantID,
		arg.StudentID,
		arg.AcademicYearID,
		arg.SubjectID,
		arg.AggregateMarks,
		arg.GradeLabel,
	)
	var i MarksAggregate
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.AcademicYearID,
		&i.SubjectID,
		&i.AggregateMarks,
		&i.GradeLabel,
		&i.CalculatedAt,
	)
	return i, err
}

const upsertWeightageConfig = `-- name: UpsertWeightageConfig :one
INSERT INTO exam_weightage_config (tenant_id, academic_year_id, exam_type, weight_percentage)
VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id, academic_year_id, exam_type) DO UPDATE
SET weight_percentage = EXCLUDED.weight_percentage
RETURNING id, tenant_id, academic_year_id, exam_type, weight_percentage, created_at
`

type UpsertWeightageConfigParams struct {
	TenantID         pgtype.UUID    `json:"tenant_id"`
	AcademicYearID   pgtype.UUID    `json:"academic_year_id"`
	ExamType         string         `json:"exam_type"`
	WeightPercentage pgtype.Numeric `json:"weight_percentage"`
}

func (q *Queries) UpsertWeightageConfig(ctx context.Context, arg UpsertWeightageConfigParams) (ExamWeightageConfig, error) {
	row := q.db.QueryRow(ctx, upsertWeightageConfig,
		arg.TenantID,
		arg.AcademicYearID,
		arg.ExamType,
		arg.WeightPercentage,
	)
	var i ExamWeightageConfig
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.ExamType,
		&i.WeightPercentage,
		&i.CreatedAt,
	)
	return i, err
}
