// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: alumni.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAlumni = `-- name: CreateAlumni :one
INSERT INTO alumni (
    tenant_id, student_id, user_id, full_name, graduation_year, batch, email, phone, 
    current_company, job_role, linkedin_url, bio, is_verified
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, tenant_id, student_id, user_id, full_name, graduation_year, batch, email, phone, current_company, job_role, linkedin_url, profile_picture_url, bio, is_verified, created_at, updated_at
`

type CreateAlumniParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	StudentID      pgtype.UUID `json:"student_id"`
	UserID         pgtype.UUID `json:"user_id"`
	FullName       string      `json:"full_name"`
	GraduationYear pgtype.Int4 `json:"graduation_year"`
	Batch          pgtype.Text `json:"batch"`
	Email          pgtype.Text `json:"email"`
	Phone          pgtype.Text `json:"phone"`
	CurrentCompany pgtype.Text `json:"current_company"`
	JobRole        pgtype.Text `json:"job_role"`
	LinkedinUrl    pgtype.Text `json:"linkedin_url"`
	Bio            pgtype.Text `json:"bio"`
	IsVerified     pgtype.Bool `json:"is_verified"`
}

func (q *Queries) CreateAlumni(ctx context.Context, arg CreateAlumniParams) (Alumni, error) {
	row := q.db.QueryRow(ctx, createAlumni,
		arg.TenantID,
		arg.StudentID,
		arg.UserID,
		arg.FullName,
		arg.GraduationYear,
		arg.Batch,
		arg.Email,
		arg.Phone,
		arg.CurrentCompany,
		arg.JobRole,
		arg.LinkedinUrl,
		arg.Bio,
		arg.IsVerified,
	)
	var i Alumni
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.UserID,
		&i.FullName,
		&i.GraduationYear,
		&i.Batch,
		&i.Email,
		&i.Phone,
		&i.CurrentCompany,
		&i.JobRole,
		&i.LinkedinUrl,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlacementApplication = `-- name: CreatePlacementApplication :one
INSERT INTO placement_applications (drive_id, alumni_id, resume_url, cover_letter, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, drive_id, alumni_id, resume_url, cover_letter, status, applied_at, updated_at
`

type CreatePlacementApplicationParams struct {
	DriveID     pgtype.UUID `json:"drive_id"`
	AlumniID    pgtype.UUID `json:"alumni_id"`
	ResumeUrl   pgtype.Text `json:"resume_url"`
	CoverLetter pgtype.Text `json:"cover_letter"`
	Status      string      `json:"status"`
}

func (q *Queries) CreatePlacementApplication(ctx context.Context, arg CreatePlacementApplicationParams) (PlacementApplication, error) {
	row := q.db.QueryRow(ctx, createPlacementApplication,
		arg.DriveID,
		arg.AlumniID,
		arg.ResumeUrl,
		arg.CoverLetter,
		arg.Status,
	)
	var i PlacementApplication
	err := row.Scan(
		&i.ID,
		&i.DriveID,
		&i.AlumniID,
		&i.ResumeUrl,
		&i.CoverLetter,
		&i.Status,
		&i.AppliedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlacementDrive = `-- name: CreatePlacementDrive :one
INSERT INTO placement_drives (
    tenant_id, company_name, role_title, description, drive_date, application_deadline, 
    min_graduation_year, max_graduation_year, status, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tenant_id, company_name, role_title, description, drive_date, application_deadline, min_graduation_year, max_graduation_year, status, created_by, created_at, updated_at
`

type CreatePlacementDriveParams struct {
	TenantID            pgtype.UUID `json:"tenant_id"`
	CompanyName         string      `json:"company_name"`
	RoleTitle           string      `json:"role_title"`
	Description         pgtype.Text `json:"description"`
	DriveDate           pgtype.Date `json:"drive_date"`
	ApplicationDeadline pgtype.Date `json:"application_deadline"`
	MinGraduationYear   pgtype.Int4 `json:"min_graduation_year"`
	MaxGraduationYear   pgtype.Int4 `json:"max_graduation_year"`
	Status              string      `json:"status"`
	CreatedBy           pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreatePlacementDrive(ctx context.Context, arg CreatePlacementDriveParams) (PlacementDrife, error) {
	row := q.db.QueryRow(ctx, createPlacementDrive,
		arg.TenantID,
		arg.CompanyName,
		arg.RoleTitle,
		arg.Description,
		arg.DriveDate,
		arg.ApplicationDeadline,
		arg.MinGraduationYear,
		arg.MaxGraduationYear,
		arg.Status,
		arg.CreatedBy,
	)
	var i PlacementDrife
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CompanyName,
		&i.RoleTitle,
		&i.Description,
		&i.DriveDate,
		&i.ApplicationDeadline,
		&i.MinGraduationYear,
		&i.MaxGraduationYear,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlumni = `-- name: GetAlumni :one
SELECT id, tenant_id, student_id, user_id, full_name, graduation_year, batch, email, phone, current_company, job_role, linkedin_url, profile_picture_url, bio, is_verified, created_at, updated_at FROM alumni WHERE id = $1 AND tenant_id = $2
`

type GetAlumniParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetAlumni(ctx context.Context, arg GetAlumniParams) (Alumni, error) {
	row := q.db.QueryRow(ctx, getAlumni, arg.ID, arg.TenantID)
	var i Alumni
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.UserID,
		&i.FullName,
		&i.GraduationYear,
		&i.Batch,
		&i.Email,
		&i.Phone,
		&i.CurrentCompany,
		&i.JobRole,
		&i.LinkedinUrl,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlumniApplications = `-- name: GetAlumniApplications :many
SELECT 
    pa.id, pa.drive_id, pa.alumni_id, pa.resume_url, pa.cover_letter, pa.status, pa.applied_at, pa.updated_at,
    pd.company_name,
    pd.role_title,
    pd.drive_date
FROM placement_applications pa
JOIN placement_drives pd ON pa.drive_id = pd.id
WHERE pa.alumni_id = $1
ORDER BY pa.applied_at DESC
`

type GetAlumniApplicationsRow struct {
	ID          pgtype.UUID        `json:"id"`
	DriveID     pgtype.UUID        `json:"drive_id"`
	AlumniID    pgtype.UUID        `json:"alumni_id"`
	ResumeUrl   pgtype.Text        `json:"resume_url"`
	CoverLetter pgtype.Text        `json:"cover_letter"`
	Status      string             `json:"status"`
	AppliedAt   pgtype.Timestamptz `json:"applied_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	CompanyName string             `json:"company_name"`
	RoleTitle   string             `json:"role_title"`
	DriveDate   pgtype.Date        `json:"drive_date"`
}

func (q *Queries) GetAlumniApplications(ctx context.Context, alumniID pgtype.UUID) ([]GetAlumniApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getAlumniApplications, alumniID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlumniApplicationsRow
	for rows.Next() {
		var i GetAlumniApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.DriveID,
			&i.AlumniID,
			&i.ResumeUrl,
			&i.CoverLetter,
			&i.Status,
			&i.AppliedAt,
			&i.UpdatedAt,
			&i.CompanyName,
			&i.RoleTitle,
			&i.DriveDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlacementDrive = `-- name: GetPlacementDrive :one
SELECT id, tenant_id, company_name, role_title, description, drive_date, application_deadline, min_graduation_year, max_graduation_year, status, created_by, created_at, updated_at FROM placement_drives WHERE id = $1 AND tenant_id = $2
`

type GetPlacementDriveParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetPlacementDrive(ctx context.Context, arg GetPlacementDriveParams) (PlacementDrife, error) {
	row := q.db.QueryRow(ctx, getPlacementDrive, arg.ID, arg.TenantID)
	var i PlacementDrife
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CompanyName,
		&i.RoleTitle,
		&i.Description,
		&i.DriveDate,
		&i.ApplicationDeadline,
		&i.MinGraduationYear,
		&i.MaxGraduationYear,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAlumni = `-- name: ListAlumni :many
SELECT id, tenant_id, student_id, user_id, full_name, graduation_year, batch, email, phone, current_company, job_role, linkedin_url, profile_picture_url, bio, is_verified, created_at, updated_at FROM alumni
WHERE tenant_id = $1
ORDER BY graduation_year DESC, full_name
LIMIT $2 OFFSET $3
`

type ListAlumniParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListAlumni(ctx context.Context, arg ListAlumniParams) ([]Alumni, error) {
	rows, err := q.db.Query(ctx, listAlumni, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Alumni
	for rows.Next() {
		var i Alumni
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.UserID,
			&i.FullName,
			&i.GraduationYear,
			&i.Batch,
			&i.Email,
			&i.Phone,
			&i.CurrentCompany,
			&i.JobRole,
			&i.LinkedinUrl,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDriveApplications = `-- name: ListDriveApplications :many
SELECT 
    pa.id, pa.drive_id, pa.alumni_id, pa.resume_url, pa.cover_letter, pa.status, pa.applied_at, pa.updated_at,
    a.full_name as alumni_name,
    a.graduation_year,
    a.current_company
FROM placement_applications pa
JOIN alumni a ON pa.alumni_id = a.id
WHERE pa.drive_id = $1
ORDER BY pa.applied_at DESC
`

type ListDriveApplicationsRow struct {
	ID             pgtype.UUID        `json:"id"`
	DriveID        pgtype.UUID        `json:"drive_id"`
	AlumniID       pgtype.UUID        `json:"alumni_id"`
	ResumeUrl      pgtype.Text        `json:"resume_url"`
	CoverLetter    pgtype.Text        `json:"cover_letter"`
	Status         string             `json:"status"`
	AppliedAt      pgtype.Timestamptz `json:"applied_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	AlumniName     string             `json:"alumni_name"`
	GraduationYear pgtype.Int4        `json:"graduation_year"`
	CurrentCompany pgtype.Text        `json:"current_company"`
}

func (q *Queries) ListDriveApplications(ctx context.Context, driveID pgtype.UUID) ([]ListDriveApplicationsRow, error) {
	rows, err := q.db.Query(ctx, listDriveApplications, driveID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDriveApplicationsRow
	for rows.Next() {
		var i ListDriveApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.DriveID,
			&i.AlumniID,
			&i.ResumeUrl,
			&i.CoverLetter,
			&i.Status,
			&i.AppliedAt,
			&i.UpdatedAt,
			&i.AlumniName,
			&i.GraduationYear,
			&i.CurrentCompany,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlacementDrives = `-- name: ListPlacementDrives :many
SELECT id, tenant_id, company_name, role_title, description, drive_date, application_deadline, min_graduation_year, max_graduation_year, status, created_by, created_at, updated_at FROM placement_drives
WHERE tenant_id = $1
ORDER BY drive_date DESC
LIMIT $2 OFFSET $3
`

type ListPlacementDrivesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListPlacementDrives(ctx context.Context, arg ListPlacementDrivesParams) ([]PlacementDrife, error) {
	rows, err := q.db.Query(ctx, listPlacementDrives, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlacementDrife
	for rows.Next() {
		var i PlacementDrife
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CompanyName,
			&i.RoleTitle,
			&i.Description,
			&i.DriveDate,
			&i.ApplicationDeadline,
			&i.MinGraduationYear,
			&i.MaxGraduationYear,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlumni = `-- name: UpdateAlumni :one
UPDATE alumni SET
    current_company = $3, job_role = $4, linkedin_url = $5, bio = $6, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, student_id, user_id, full_name, graduation_year, batch, email, phone, current_company, job_role, linkedin_url, profile_picture_url, bio, is_verified, created_at, updated_at
`

type UpdateAlumniParams struct {
	ID             pgtype.UUID `json:"id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
	CurrentCompany pgtype.Text `json:"current_company"`
	JobRole        pgtype.Text `json:"job_role"`
	LinkedinUrl    pgtype.Text `json:"linkedin_url"`
	Bio            pgtype.Text `json:"bio"`
}

func (q *Queries) UpdateAlumni(ctx context.Context, arg UpdateAlumniParams) (Alumni, error) {
	row := q.db.QueryRow(ctx, updateAlumni,
		arg.ID,
		arg.TenantID,
		arg.CurrentCompany,
		arg.JobRole,
		arg.LinkedinUrl,
		arg.Bio,
	)
	var i Alumni
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.UserID,
		&i.FullName,
		&i.GraduationYear,
		&i.Batch,
		&i.Email,
		&i.Phone,
		&i.CurrentCompany,
		&i.JobRole,
		&i.LinkedinUrl,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlacementApplicationStatus = `-- name: UpdatePlacementApplicationStatus :one
UPDATE placement_applications SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, drive_id, alumni_id, resume_url, cover_letter, status, applied_at, updated_at
`

type UpdatePlacementApplicationStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdatePlacementApplicationStatus(ctx context.Context, arg UpdatePlacementApplicationStatusParams) (PlacementApplication, error) {
	row := q.db.QueryRow(ctx, updatePlacementApplicationStatus, arg.ID, arg.Status)
	var i PlacementApplication
	err := row.Scan(
		&i.ID,
		&i.DriveID,
		&i.AlumniID,
		&i.ResumeUrl,
		&i.CoverLetter,
		&i.Status,
		&i.AppliedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlacementDriveStatus = `-- name: UpdatePlacementDriveStatus :one
UPDATE placement_drives SET status = $3, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, company_name, role_title, description, drive_date, application_deadline, min_graduation_year, max_graduation_year, status, created_by, created_at, updated_at
`

type UpdatePlacementDriveStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

func (q *Queries) UpdatePlacementDriveStatus(ctx context.Context, arg UpdatePlacementDriveStatusParams) (PlacementDrife, error) {
	row := q.db.QueryRow(ctx, updatePlacementDriveStatus, arg.ID, arg.TenantID, arg.Status)
	var i PlacementDrife
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CompanyName,
		&i.RoleTitle,
		&i.Description,
		&i.DriveDate,
		&i.ApplicationDeadline,
		&i.MinGraduationYear,
		&i.MaxGraduationYear,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
