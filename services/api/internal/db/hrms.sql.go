// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hrms.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (
    tenant_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at
`

type CreateEmployeeParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	EmployeeCode      string      `json:"employee_code"`
	FullName          string      `json:"full_name"`
	Email             pgtype.Text `json:"email"`
	Phone             pgtype.Text `json:"phone"`
	Department        pgtype.Text `json:"department"`
	Designation       pgtype.Text `json:"designation"`
	JoinDate          pgtype.Date `json:"join_date"`
	SalaryStructureID pgtype.UUID `json:"salary_structure_id"`
	BankDetails       []byte      `json:"bank_details"`
	Status            string      `json:"status"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.TenantID,
		arg.EmployeeCode,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.Department,
		arg.Designation,
		arg.JoinDate,
		arg.SalaryStructureID,
		arg.BankDetails,
		arg.Status,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayrollRun = `-- name: CreatePayrollRun :one
INSERT INTO payroll_runs (
    tenant_id, month, year, status, run_by
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, month, year, status, run_by, run_at, created_at
`

type CreatePayrollRunParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Month    int32       `json:"month"`
	Year     int32       `json:"year"`
	Status   string      `json:"status"`
	RunBy    pgtype.UUID `json:"run_by"`
}

func (q *Queries) CreatePayrollRun(ctx context.Context, arg CreatePayrollRunParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, createPayrollRun,
		arg.TenantID,
		arg.Month,
		arg.Year,
		arg.Status,
		arg.RunBy,
	)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}

const createPayslip = `-- name: CreatePayslip :one
INSERT INTO payslips (
    payroll_run_id, employee_id, gross_salary, total_deductions, net_salary, breakdown, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, payroll_run_id, employee_id, gross_salary, total_deductions, net_salary, breakdown, status, created_at
`

type CreatePayslipParams struct {
	PayrollRunID    pgtype.UUID    `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID    `json:"employee_id"`
	GrossSalary     pgtype.Numeric `json:"gross_salary"`
	TotalDeductions pgtype.Numeric `json:"total_deductions"`
	NetSalary       pgtype.Numeric `json:"net_salary"`
	Breakdown       []byte         `json:"breakdown"`
	Status          string         `json:"status"`
}

func (q *Queries) CreatePayslip(ctx context.Context, arg CreatePayslipParams) (Payslip, error) {
	row := q.db.QueryRow(ctx, createPayslip,
		arg.PayrollRunID,
		arg.EmployeeID,
		arg.GrossSalary,
		arg.TotalDeductions,
		arg.NetSalary,
		arg.Breakdown,
		arg.Status,
	)
	var i Payslip
	err := row.Scan(
		&i.ID,
		&i.PayrollRunID,
		&i.EmployeeID,
		&i.GrossSalary,
		&i.TotalDeductions,
		&i.NetSalary,
		&i.Breakdown,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createSalaryStructure = `-- name: CreateSalaryStructure :one
INSERT INTO salary_structures (
    tenant_id, name, basic, hra, da, other_allowances, deductions
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, name, basic, hra, da, other_allowances, deductions, created_at, updated_at
`

type CreateSalaryStructureParams struct {
	TenantID        pgtype.UUID    `json:"tenant_id"`
	Name            string         `json:"name"`
	Basic           pgtype.Numeric `json:"basic"`
	Hra             pgtype.Numeric `json:"hra"`
	Da              pgtype.Numeric `json:"da"`
	OtherAllowances []byte         `json:"other_allowances"`
	Deductions      []byte         `json:"deductions"`
}

func (q *Queries) CreateSalaryStructure(ctx context.Context, arg CreateSalaryStructureParams) (SalaryStructure, error) {
	row := q.db.QueryRow(ctx, createSalaryStructure,
		arg.TenantID,
		arg.Name,
		arg.Basic,
		arg.Hra,
		arg.Da,
		arg.OtherAllowances,
		arg.Deductions,
	)
	var i SalaryStructure
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Basic,
		&i.Hra,
		&i.Da,
		&i.OtherAllowances,
		&i.Deductions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployee = `-- name: GetEmployee :one
SELECT id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at FROM employees WHERE id = $1 AND tenant_id = $2
`

type GetEmployeeParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetEmployee(ctx context.Context, arg GetEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployee, arg.ID, arg.TenantID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeePayslips = `-- name: GetEmployeePayslips :many
SELECT 
    p.id, p.payroll_run_id, p.employee_id, p.gross_salary, p.total_deductions, p.net_salary, p.breakdown, p.status, p.created_at,
    pr.month,
    pr.year
FROM payslips p
JOIN payroll_runs pr ON p.payroll_run_id = pr.id
WHERE p.employee_id = $1
ORDER BY pr.year DESC, pr.month DESC
LIMIT $2 OFFSET $3
`

type GetEmployeePayslipsParams struct {
	EmployeeID pgtype.UUID `json:"employee_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetEmployeePayslipsRow struct {
	ID              pgtype.UUID        `json:"id"`
	PayrollRunID    pgtype.UUID        `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID        `json:"employee_id"`
	GrossSalary     pgtype.Numeric     `json:"gross_salary"`
	TotalDeductions pgtype.Numeric     `json:"total_deductions"`
	NetSalary       pgtype.Numeric     `json:"net_salary"`
	Breakdown       []byte             `json:"breakdown"`
	Status          string             `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	Month           int32              `json:"month"`
	Year            int32              `json:"year"`
}

func (q *Queries) GetEmployeePayslips(ctx context.Context, arg GetEmployeePayslipsParams) ([]GetEmployeePayslipsRow, error) {
	rows, err := q.db.Query(ctx, getEmployeePayslips, arg.EmployeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeePayslipsRow
	for rows.Next() {
		var i GetEmployeePayslipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollRunID,
			&i.EmployeeID,
			&i.GrossSalary,
			&i.TotalDeductions,
			&i.NetSalary,
			&i.Breakdown,
			&i.Status,
			&i.CreatedAt,
			&i.Month,
			&i.Year,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayrollRun = `-- name: GetPayrollRun :one
SELECT id, tenant_id, month, year, status, run_by, run_at, created_at FROM payroll_runs WHERE id = $1 AND tenant_id = $2
`

type GetPayrollRunParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetPayrollRun(ctx context.Context, arg GetPayrollRunParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, getPayrollRun, arg.ID, arg.TenantID)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}

const listEmployees = `-- name: ListEmployees :many
SELECT id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at FROM employees
WHERE tenant_id = $1
ORDER BY full_name
LIMIT $2 OFFSET $3
`

type ListEmployeesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListEmployees(ctx context.Context, arg ListEmployeesParams) ([]Employee, error) {
	rows, err := q.db.Query(ctx, listEmployees, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.EmployeeCode,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.Department,
			&i.Designation,
			&i.JoinDate,
			&i.SalaryStructureID,
			&i.BankDetails,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayrollRuns = `-- name: ListPayrollRuns :many
SELECT id, tenant_id, month, year, status, run_by, run_at, created_at FROM payroll_runs
WHERE tenant_id = $1
ORDER BY year DESC, month DESC
LIMIT $2 OFFSET $3
`

type ListPayrollRunsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListPayrollRuns(ctx context.Context, arg ListPayrollRunsParams) ([]PayrollRun, error) {
	rows, err := q.db.Query(ctx, listPayrollRuns, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayrollRun
	for rows.Next() {
		var i PayrollRun
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Month,
			&i.Year,
			&i.Status,
			&i.RunBy,
			&i.RunAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayslipsByRun = `-- name: ListPayslipsByRun :many
SELECT 
    p.id, p.payroll_run_id, p.employee_id, p.gross_salary, p.total_deductions, p.net_salary, p.breakdown, p.status, p.created_at,
    e.full_name as employee_name,
    e.employee_code
FROM payslips p
JOIN employees e ON p.employee_id = e.id
WHERE p.payroll_run_id = $1
ORDER BY e.full_name
`

type ListPayslipsByRunRow struct {
	ID              pgtype.UUID        `json:"id"`
	PayrollRunID    pgtype.UUID        `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID        `json:"employee_id"`
	GrossSalary     pgtype.Numeric     `json:"gross_salary"`
	TotalDeductions pgtype.Numeric     `json:"total_deductions"`
	NetSalary       pgtype.Numeric     `json:"net_salary"`
	Breakdown       []byte             `json:"breakdown"`
	Status          string             `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	EmployeeName    string             `json:"employee_name"`
	EmployeeCode    string             `json:"employee_code"`
}

func (q *Queries) ListPayslipsByRun(ctx context.Context, payrollRunID pgtype.UUID) ([]ListPayslipsByRunRow, error) {
	rows, err := q.db.Query(ctx, listPayslipsByRun, payrollRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPayslipsByRunRow
	for rows.Next() {
		var i ListPayslipsByRunRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollRunID,
			&i.EmployeeID,
			&i.GrossSalary,
			&i.TotalDeductions,
			&i.NetSalary,
			&i.Breakdown,
			&i.Status,
			&i.CreatedAt,
			&i.EmployeeName,
			&i.EmployeeCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalaryStructures = `-- name: ListSalaryStructures :many
SELECT id, tenant_id, name, basic, hra, da, other_allowances, deductions, created_at, updated_at FROM salary_structures
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListSalaryStructures(ctx context.Context, tenantID pgtype.UUID) ([]SalaryStructure, error) {
	rows, err := q.db.Query(ctx, listSalaryStructures, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalaryStructure
	for rows.Next() {
		var i SalaryStructure
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Basic,
			&i.Hra,
			&i.Da,
			&i.OtherAllowances,
			&i.Deductions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE employees SET
    full_name = $3, email = $4, phone = $5, department = $6, designation = $7, 
    salary_structure_id = $8, bank_details = $9, status = $10, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at
`

type UpdateEmployeeParams struct {
	ID                pgtype.UUID `json:"id"`
	TenantID          pgtype.UUID `json:"tenant_id"`
	FullName          string      `json:"full_name"`
	Email             pgtype.Text `json:"email"`
	Phone             pgtype.Text `json:"phone"`
	Department        pgtype.Text `json:"department"`
	Designation       pgtype.Text `json:"designation"`
	SalaryStructureID pgtype.UUID `json:"salary_structure_id"`
	BankDetails       []byte      `json:"bank_details"`
	Status            string      `json:"status"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, updateEmployee,
		arg.ID,
		arg.TenantID,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.Department,
		arg.Designation,
		arg.SalaryStructureID,
		arg.BankDetails,
		arg.Status,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePayrollRunStatus = `-- name: UpdatePayrollRunStatus :one
UPDATE payroll_runs SET status = $3, run_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, month, year, status, run_by, run_at, created_at
`

type UpdatePayrollRunStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

func (q *Queries) UpdatePayrollRunStatus(ctx context.Context, arg UpdatePayrollRunStatusParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, updatePayrollRunStatus, arg.ID, arg.TenantID, arg.Status)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}
