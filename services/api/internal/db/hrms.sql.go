// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hrms.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAdjustment = `-- name: CreateAdjustment :one
INSERT INTO payroll_adjustments (
    tenant_id, employee_id, type, amount, description, status
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, employee_id, payroll_run_id, type, amount, description, status, approved_by, approved_at, created_at, updated_at
`

type CreateAdjustmentParams struct {
	TenantID    pgtype.UUID    `json:"tenant_id"`
	EmployeeID  pgtype.UUID    `json:"employee_id"`
	Type        string         `json:"type"`
	Amount      pgtype.Numeric `json:"amount"`
	Description pgtype.Text    `json:"description"`
	Status      string         `json:"status"`
}

func (q *Queries) CreateAdjustment(ctx context.Context, arg CreateAdjustmentParams) (PayrollAdjustment, error) {
	row := q.db.QueryRow(ctx, createAdjustment,
		arg.TenantID,
		arg.EmployeeID,
		arg.Type,
		arg.Amount,
		arg.Description,
		arg.Status,
	)
	var i PayrollAdjustment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.PayrollRunID,
		&i.Type,
		&i.Amount,
		&i.Description,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createClassTeacherAssignment = `-- name: CreateClassTeacherAssignment :one
INSERT INTO class_teacher_assignments (tenant_id, academic_year_id, class_section_id, teacher_id, remarks)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, academic_year_id, class_section_id, teacher_id, is_active, remarks, assigned_at, created_at
`

type CreateClassTeacherAssignmentParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	ClassSectionID pgtype.UUID `json:"class_section_id"`
	TeacherID      pgtype.UUID `json:"teacher_id"`
	Remarks        pgtype.Text `json:"remarks"`
}

func (q *Queries) CreateClassTeacherAssignment(ctx context.Context, arg CreateClassTeacherAssignmentParams) (ClassTeacherAssignment, error) {
	row := q.db.QueryRow(ctx, createClassTeacherAssignment,
		arg.TenantID,
		arg.AcademicYearID,
		arg.ClassSectionID,
		arg.TeacherID,
		arg.Remarks,
	)
	var i ClassTeacherAssignment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AcademicYearID,
		&i.ClassSectionID,
		&i.TeacherID,
		&i.IsActive,
		&i.Remarks,
		&i.AssignedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (
    tenant_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at, rfid_tag, biometric_id
`

type CreateEmployeeParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	EmployeeCode      string      `json:"employee_code"`
	FullName          string      `json:"full_name"`
	Email             pgtype.Text `json:"email"`
	Phone             pgtype.Text `json:"phone"`
	Department        pgtype.Text `json:"department"`
	Designation       pgtype.Text `json:"designation"`
	JoinDate          pgtype.Date `json:"join_date"`
	SalaryStructureID pgtype.UUID `json:"salary_structure_id"`
	BankDetails       []byte      `json:"bank_details"`
	Status            string      `json:"status"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.TenantID,
		arg.EmployeeCode,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.Department,
		arg.Designation,
		arg.JoinDate,
		arg.SalaryStructureID,
		arg.BankDetails,
		arg.Status,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RfidTag,
		&i.BiometricID,
	)
	return i, err
}

const createLeaveType = `-- name: CreateLeaveType :one
INSERT INTO staff_leave_types (tenant_id, name, code, annual_allowance, carry_forward_limit, is_active)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, name, code, annual_allowance, carry_forward_limit, is_active, created_at
`

type CreateLeaveTypeParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	Name              string      `json:"name"`
	Code              string      `json:"code"`
	AnnualAllowance   pgtype.Int4 `json:"annual_allowance"`
	CarryForwardLimit pgtype.Int4 `json:"carry_forward_limit"`
	IsActive          pgtype.Bool `json:"is_active"`
}

// Leaves
func (q *Queries) CreateLeaveType(ctx context.Context, arg CreateLeaveTypeParams) (StaffLeaveType, error) {
	row := q.db.QueryRow(ctx, createLeaveType,
		arg.TenantID,
		arg.Name,
		arg.Code,
		arg.AnnualAllowance,
		arg.CarryForwardLimit,
		arg.IsActive,
	)
	var i StaffLeaveType
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.AnnualAllowance,
		&i.CarryForwardLimit,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createPayrollRun = `-- name: CreatePayrollRun :one
INSERT INTO payroll_runs (
    tenant_id, month, year, status, run_by
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, month, year, status, run_by, run_at, created_at
`

type CreatePayrollRunParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Month    int32       `json:"month"`
	Year     int32       `json:"year"`
	Status   string      `json:"status"`
	RunBy    pgtype.UUID `json:"run_by"`
}

func (q *Queries) CreatePayrollRun(ctx context.Context, arg CreatePayrollRunParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, createPayrollRun,
		arg.TenantID,
		arg.Month,
		arg.Year,
		arg.Status,
		arg.RunBy,
	)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}

const createPayslip = `-- name: CreatePayslip :one
INSERT INTO payslips (
    payroll_run_id, employee_id, gross_salary, total_deductions, net_salary, breakdown, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, payroll_run_id, employee_id, gross_salary, total_deductions, net_salary, breakdown, status, created_at
`

type CreatePayslipParams struct {
	PayrollRunID    pgtype.UUID    `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID    `json:"employee_id"`
	GrossSalary     pgtype.Numeric `json:"gross_salary"`
	TotalDeductions pgtype.Numeric `json:"total_deductions"`
	NetSalary       pgtype.Numeric `json:"net_salary"`
	Breakdown       []byte         `json:"breakdown"`
	Status          string         `json:"status"`
}

func (q *Queries) CreatePayslip(ctx context.Context, arg CreatePayslipParams) (Payslip, error) {
	row := q.db.QueryRow(ctx, createPayslip,
		arg.PayrollRunID,
		arg.EmployeeID,
		arg.GrossSalary,
		arg.TotalDeductions,
		arg.NetSalary,
		arg.Breakdown,
		arg.Status,
	)
	var i Payslip
	err := row.Scan(
		&i.ID,
		&i.PayrollRunID,
		&i.EmployeeID,
		&i.GrossSalary,
		&i.TotalDeductions,
		&i.NetSalary,
		&i.Breakdown,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createSalaryStructure = `-- name: CreateSalaryStructure :one
INSERT INTO salary_structures (
    tenant_id, name, basic, hra, da, other_allowances, deductions
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, name, basic, hra, da, other_allowances, deductions, created_at, updated_at
`

type CreateSalaryStructureParams struct {
	TenantID        pgtype.UUID    `json:"tenant_id"`
	Name            string         `json:"name"`
	Basic           pgtype.Numeric `json:"basic"`
	Hra             pgtype.Numeric `json:"hra"`
	Da              pgtype.Numeric `json:"da"`
	OtherAllowances []byte         `json:"other_allowances"`
	Deductions      []byte         `json:"deductions"`
}

func (q *Queries) CreateSalaryStructure(ctx context.Context, arg CreateSalaryStructureParams) (SalaryStructure, error) {
	row := q.db.QueryRow(ctx, createSalaryStructure,
		arg.TenantID,
		arg.Name,
		arg.Basic,
		arg.Hra,
		arg.Da,
		arg.OtherAllowances,
		arg.Deductions,
	)
	var i SalaryStructure
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Basic,
		&i.Hra,
		&i.Da,
		&i.OtherAllowances,
		&i.Deductions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStaffAward = `-- name: CreateStaffAward :one
INSERT INTO staff_awards (
    tenant_id, employee_id, award_name, category, awarded_date, awarded_by, description, bonus_amount
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tenant_id, employee_id, award_name, category, awarded_date, awarded_by, description, bonus_amount, created_at
`

type CreateStaffAwardParams struct {
	TenantID    pgtype.UUID    `json:"tenant_id"`
	EmployeeID  pgtype.UUID    `json:"employee_id"`
	AwardName   string         `json:"award_name"`
	Category    pgtype.Text    `json:"category"`
	AwardedDate pgtype.Date    `json:"awarded_date"`
	AwardedBy   pgtype.Text    `json:"awarded_by"`
	Description pgtype.Text    `json:"description"`
	BonusAmount pgtype.Numeric `json:"bonus_amount"`
}

// Awards
func (q *Queries) CreateStaffAward(ctx context.Context, arg CreateStaffAwardParams) (StaffAward, error) {
	row := q.db.QueryRow(ctx, createStaffAward,
		arg.TenantID,
		arg.EmployeeID,
		arg.AwardName,
		arg.Category,
		arg.AwardedDate,
		arg.AwardedBy,
		arg.Description,
		arg.BonusAmount,
	)
	var i StaffAward
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.AwardName,
		&i.Category,
		&i.AwardedDate,
		&i.AwardedBy,
		&i.Description,
		&i.BonusAmount,
		&i.CreatedAt,
	)
	return i, err
}

const createStaffBonus = `-- name: CreateStaffBonus :one
INSERT INTO staff_bonus_history (
    tenant_id, employee_id, amount, bonus_type, payment_date, payroll_run_id, remarks
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, employee_id, amount, bonus_type, payment_date, payroll_run_id, remarks, created_at
`

type CreateStaffBonusParams struct {
	TenantID     pgtype.UUID    `json:"tenant_id"`
	EmployeeID   pgtype.UUID    `json:"employee_id"`
	Amount       pgtype.Numeric `json:"amount"`
	BonusType    string         `json:"bonus_type"`
	PaymentDate  pgtype.Date    `json:"payment_date"`
	PayrollRunID pgtype.UUID    `json:"payroll_run_id"`
	Remarks      pgtype.Text    `json:"remarks"`
}

// Bonus History
func (q *Queries) CreateStaffBonus(ctx context.Context, arg CreateStaffBonusParams) (StaffBonusHistory, error) {
	row := q.db.QueryRow(ctx, createStaffBonus,
		arg.TenantID,
		arg.EmployeeID,
		arg.Amount,
		arg.BonusType,
		arg.PaymentDate,
		arg.PayrollRunID,
		arg.Remarks,
	)
	var i StaffBonusHistory
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.Amount,
		&i.BonusType,
		&i.PaymentDate,
		&i.PayrollRunID,
		&i.Remarks,
		&i.CreatedAt,
	)
	return i, err
}

const createStaffLeaveRequest = `-- name: CreateStaffLeaveRequest :one
INSERT INTO staff_leave_requests (
    tenant_id, employee_id, leave_type_id, start_date, end_date, reason, status
) VALUES (
    $1, $2, $3, $4, $5, $6, 'pending'
) RETURNING id, tenant_id, employee_id, leave_type_id, start_date, end_date, reason, status, reviewed_by, reviewed_at, remarks, created_at
`

type CreateStaffLeaveRequestParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	EmployeeID  pgtype.UUID `json:"employee_id"`
	LeaveTypeID pgtype.UUID `json:"leave_type_id"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	Reason      pgtype.Text `json:"reason"`
}

func (q *Queries) CreateStaffLeaveRequest(ctx context.Context, arg CreateStaffLeaveRequestParams) (StaffLeaveRequest, error) {
	row := q.db.QueryRow(ctx, createStaffLeaveRequest,
		arg.TenantID,
		arg.EmployeeID,
		arg.LeaveTypeID,
		arg.StartDate,
		arg.EndDate,
		arg.Reason,
	)
	var i StaffLeaveRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.LeaveTypeID,
		&i.StartDate,
		&i.EndDate,
		&i.Reason,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.Remarks,
		&i.CreatedAt,
	)
	return i, err
}

const createStaffTransfer = `-- name: CreateStaffTransfer :one
INSERT INTO staff_transfers (
    tenant_id, employee_id, from_branch_id, to_branch_id, transfer_date, reason, authorized_by, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tenant_id, employee_id, from_branch_id, to_branch_id, transfer_date, reason, authorized_by, status, created_at
`

type CreateStaffTransferParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	EmployeeID   pgtype.UUID `json:"employee_id"`
	FromBranchID pgtype.UUID `json:"from_branch_id"`
	ToBranchID   pgtype.UUID `json:"to_branch_id"`
	TransferDate pgtype.Date `json:"transfer_date"`
	Reason       pgtype.Text `json:"reason"`
	AuthorizedBy pgtype.UUID `json:"authorized_by"`
	Status       string      `json:"status"`
}

// Transfers
func (q *Queries) CreateStaffTransfer(ctx context.Context, arg CreateStaffTransferParams) (StaffTransfer, error) {
	row := q.db.QueryRow(ctx, createStaffTransfer,
		arg.TenantID,
		arg.EmployeeID,
		arg.FromBranchID,
		arg.ToBranchID,
		arg.TransferDate,
		arg.Reason,
		arg.AuthorizedBy,
		arg.Status,
	)
	var i StaffTransfer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.FromBranchID,
		&i.ToBranchID,
		&i.TransferDate,
		&i.Reason,
		&i.AuthorizedBy,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createTeacherSubjectSpecialization = `-- name: CreateTeacherSubjectSpecialization :one
INSERT INTO teacher_subject_specializations (tenant_id, teacher_id, subject_id)
VALUES ($1, $2, $3)
RETURNING id, tenant_id, teacher_id, subject_id, created_at
`

type CreateTeacherSubjectSpecializationParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	TeacherID pgtype.UUID `json:"teacher_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
}

func (q *Queries) CreateTeacherSubjectSpecialization(ctx context.Context, arg CreateTeacherSubjectSpecializationParams) (TeacherSubjectSpecialization, error) {
	row := q.db.QueryRow(ctx, createTeacherSubjectSpecialization, arg.TenantID, arg.TeacherID, arg.SubjectID)
	var i TeacherSubjectSpecialization
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TeacherID,
		&i.SubjectID,
		&i.CreatedAt,
	)
	return i, err
}

const getApprovedAdjustmentsForRun = `-- name: GetApprovedAdjustmentsForRun :many
SELECT id, tenant_id, employee_id, payroll_run_id, type, amount, description, status, approved_by, approved_at, created_at, updated_at FROM payroll_adjustments
WHERE tenant_id = $1 AND employee_id = $2 AND status = 'approved' AND payroll_run_id IS NULL
`

type GetApprovedAdjustmentsForRunParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	EmployeeID pgtype.UUID `json:"employee_id"`
}

// Adjustments that are approved but not yet processed in a run
func (q *Queries) GetApprovedAdjustmentsForRun(ctx context.Context, arg GetApprovedAdjustmentsForRunParams) ([]PayrollAdjustment, error) {
	rows, err := q.db.Query(ctx, getApprovedAdjustmentsForRun, arg.TenantID, arg.EmployeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayrollAdjustment
	for rows.Next() {
		var i PayrollAdjustment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeID,
			&i.PayrollRunID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployee = `-- name: GetEmployee :one
SELECT id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at, rfid_tag, biometric_id FROM employees WHERE id = $1 AND tenant_id = $2
`

type GetEmployeeParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetEmployee(ctx context.Context, arg GetEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployee, arg.ID, arg.TenantID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RfidTag,
		&i.BiometricID,
	)
	return i, err
}

const getEmployeeByUserID = `-- name: GetEmployeeByUserID :one
SELECT id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at, rfid_tag, biometric_id FROM employees WHERE user_id = $1 AND tenant_id = $2
`

type GetEmployeeByUserIDParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetEmployeeByUserID(ctx context.Context, arg GetEmployeeByUserIDParams) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployeeByUserID, arg.UserID, arg.TenantID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RfidTag,
		&i.BiometricID,
	)
	return i, err
}

const getEmployeePayslips = `-- name: GetEmployeePayslips :many
SELECT 
    p.id, p.payroll_run_id, p.employee_id, p.gross_salary, p.total_deductions, p.net_salary, p.breakdown, p.status, p.created_at,
    pr.month,
    pr.year
FROM payslips p
JOIN payroll_runs pr ON p.payroll_run_id = pr.id
WHERE p.employee_id = $1
ORDER BY pr.year DESC, pr.month DESC
LIMIT $2 OFFSET $3
`

type GetEmployeePayslipsParams struct {
	EmployeeID pgtype.UUID `json:"employee_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetEmployeePayslipsRow struct {
	ID              pgtype.UUID        `json:"id"`
	PayrollRunID    pgtype.UUID        `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID        `json:"employee_id"`
	GrossSalary     pgtype.Numeric     `json:"gross_salary"`
	TotalDeductions pgtype.Numeric     `json:"total_deductions"`
	NetSalary       pgtype.Numeric     `json:"net_salary"`
	Breakdown       []byte             `json:"breakdown"`
	Status          string             `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	Month           int32              `json:"month"`
	Year            int32              `json:"year"`
}

func (q *Queries) GetEmployeePayslips(ctx context.Context, arg GetEmployeePayslipsParams) ([]GetEmployeePayslipsRow, error) {
	rows, err := q.db.Query(ctx, getEmployeePayslips, arg.EmployeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeePayslipsRow
	for rows.Next() {
		var i GetEmployeePayslipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollRunID,
			&i.EmployeeID,
			&i.GrossSalary,
			&i.TotalDeductions,
			&i.NetSalary,
			&i.Breakdown,
			&i.Status,
			&i.CreatedAt,
			&i.Month,
			&i.Year,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeSalaryInfo = `-- name: GetEmployeeSalaryInfo :one
SELECT 
    e.id, e.tenant_id, e.user_id, e.employee_code, e.full_name, e.email, e.phone, e.department, e.designation, e.join_date, e.salary_structure_id, e.bank_details, e.status, e.created_at, e.updated_at, e.rfid_tag, e.biometric_id,
    ss.basic,
    ss.hra,
    ss.da,
    ss.other_allowances,
    ss.deductions
FROM employees e
JOIN salary_structures ss ON e.salary_structure_id = ss.id
WHERE e.id = $1 AND e.tenant_id = $2
`

type GetEmployeeSalaryInfoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetEmployeeSalaryInfoRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	EmployeeCode      string             `json:"employee_code"`
	FullName          string             `json:"full_name"`
	Email             pgtype.Text        `json:"email"`
	Phone             pgtype.Text        `json:"phone"`
	Department        pgtype.Text        `json:"department"`
	Designation       pgtype.Text        `json:"designation"`
	JoinDate          pgtype.Date        `json:"join_date"`
	SalaryStructureID pgtype.UUID        `json:"salary_structure_id"`
	BankDetails       []byte             `json:"bank_details"`
	Status            string             `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	RfidTag           pgtype.Text        `json:"rfid_tag"`
	BiometricID       pgtype.Text        `json:"biometric_id"`
	Basic             pgtype.Numeric     `json:"basic"`
	Hra               pgtype.Numeric     `json:"hra"`
	Da                pgtype.Numeric     `json:"da"`
	OtherAllowances   []byte             `json:"other_allowances"`
	Deductions        []byte             `json:"deductions"`
}

func (q *Queries) GetEmployeeSalaryInfo(ctx context.Context, arg GetEmployeeSalaryInfoParams) (GetEmployeeSalaryInfoRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeSalaryInfo, arg.ID, arg.TenantID)
	var i GetEmployeeSalaryInfoRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RfidTag,
		&i.BiometricID,
		&i.Basic,
		&i.Hra,
		&i.Da,
		&i.OtherAllowances,
		&i.Deductions,
	)
	return i, err
}

const getPayrollRun = `-- name: GetPayrollRun :one
SELECT id, tenant_id, month, year, status, run_by, run_at, created_at FROM payroll_runs WHERE id = $1 AND tenant_id = $2
`

type GetPayrollRunParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetPayrollRun(ctx context.Context, arg GetPayrollRunParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, getPayrollRun, arg.ID, arg.TenantID)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingAdjustments = `-- name: GetPendingAdjustments :many
SELECT id, tenant_id, employee_id, payroll_run_id, type, amount, description, status, approved_by, approved_at, created_at, updated_at FROM payroll_adjustments
WHERE tenant_id = $1 AND employee_id = $2 AND status = 'pending'
`

type GetPendingAdjustmentsParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	EmployeeID pgtype.UUID `json:"employee_id"`
}

func (q *Queries) GetPendingAdjustments(ctx context.Context, arg GetPendingAdjustmentsParams) ([]PayrollAdjustment, error) {
	rows, err := q.db.Query(ctx, getPendingAdjustments, arg.TenantID, arg.EmployeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayrollAdjustment
	for rows.Next() {
		var i PayrollAdjustment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeID,
			&i.PayrollRunID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkAdjustmentToRun = `-- name: LinkAdjustmentToRun :exec
UPDATE payroll_adjustments
SET payroll_run_id = $3, status = 'processed', updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type LinkAdjustmentToRunParams struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	PayrollRunID pgtype.UUID `json:"payroll_run_id"`
}

func (q *Queries) LinkAdjustmentToRun(ctx context.Context, arg LinkAdjustmentToRunParams) error {
	_, err := q.db.Exec(ctx, linkAdjustmentToRun, arg.ID, arg.TenantID, arg.PayrollRunID)
	return err
}

const listClassTeacherAssignments = `-- name: ListClassTeacherAssignments :many
SELECT ct.id, ct.tenant_id, ct.academic_year_id, ct.class_section_id, ct.teacher_id, ct.is_active, ct.remarks, ct.assigned_at, ct.created_at, e.full_name as teacher_name, s.name as section_name, c.name as class_name
FROM class_teacher_assignments ct
JOIN employees e ON ct.teacher_id = e.id
JOIN sections s ON ct.class_section_id = s.id
JOIN classes c ON s.class_id = c.id
WHERE ct.tenant_id = $1 AND ct.academic_year_id = $2
`

type ListClassTeacherAssignmentsParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
}

type ListClassTeacherAssignmentsRow struct {
	ID             pgtype.UUID        `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	AcademicYearID pgtype.UUID        `json:"academic_year_id"`
	ClassSectionID pgtype.UUID        `json:"class_section_id"`
	TeacherID      pgtype.UUID        `json:"teacher_id"`
	IsActive       pgtype.Bool        `json:"is_active"`
	Remarks        pgtype.Text        `json:"remarks"`
	AssignedAt     pgtype.Timestamptz `json:"assigned_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	TeacherName    string             `json:"teacher_name"`
	SectionName    string             `json:"section_name"`
	ClassName      string             `json:"class_name"`
}

func (q *Queries) ListClassTeacherAssignments(ctx context.Context, arg ListClassTeacherAssignmentsParams) ([]ListClassTeacherAssignmentsRow, error) {
	rows, err := q.db.Query(ctx, listClassTeacherAssignments, arg.TenantID, arg.AcademicYearID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClassTeacherAssignmentsRow
	for rows.Next() {
		var i ListClassTeacherAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AcademicYearID,
			&i.ClassSectionID,
			&i.TeacherID,
			&i.IsActive,
			&i.Remarks,
			&i.AssignedAt,
			&i.CreatedAt,
			&i.TeacherName,
			&i.SectionName,
			&i.ClassName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployees = `-- name: ListEmployees :many
SELECT id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at, rfid_tag, biometric_id FROM employees
WHERE tenant_id = $1
ORDER BY full_name
LIMIT $2 OFFSET $3
`

type ListEmployeesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListEmployees(ctx context.Context, arg ListEmployeesParams) ([]Employee, error) {
	rows, err := q.db.Query(ctx, listEmployees, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.EmployeeCode,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.Department,
			&i.Designation,
			&i.JoinDate,
			&i.SalaryStructureID,
			&i.BankDetails,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RfidTag,
			&i.BiometricID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeaveTypes = `-- name: ListLeaveTypes :many
SELECT id, tenant_id, name, code, annual_allowance, carry_forward_limit, is_active, created_at FROM staff_leave_types
WHERE tenant_id = $1 AND ($2::BOOLEAN = false OR is_active = $2::BOOLEAN)
`

type ListLeaveTypesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	IsActive bool        `json:"is_active"`
}

func (q *Queries) ListLeaveTypes(ctx context.Context, arg ListLeaveTypesParams) ([]StaffLeaveType, error) {
	rows, err := q.db.Query(ctx, listLeaveTypes, arg.TenantID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StaffLeaveType
	for rows.Next() {
		var i StaffLeaveType
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Code,
			&i.AnnualAllowance,
			&i.CarryForwardLimit,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayrollRuns = `-- name: ListPayrollRuns :many
SELECT id, tenant_id, month, year, status, run_by, run_at, created_at FROM payroll_runs
WHERE tenant_id = $1
ORDER BY year DESC, month DESC
LIMIT $2 OFFSET $3
`

type ListPayrollRunsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListPayrollRuns(ctx context.Context, arg ListPayrollRunsParams) ([]PayrollRun, error) {
	rows, err := q.db.Query(ctx, listPayrollRuns, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayrollRun
	for rows.Next() {
		var i PayrollRun
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Month,
			&i.Year,
			&i.Status,
			&i.RunBy,
			&i.RunAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayslipsByRun = `-- name: ListPayslipsByRun :many
SELECT 
    p.id, p.payroll_run_id, p.employee_id, p.gross_salary, p.total_deductions, p.net_salary, p.breakdown, p.status, p.created_at,
    e.full_name as employee_name,
    e.employee_code
FROM payslips p
JOIN employees e ON p.employee_id = e.id
WHERE p.payroll_run_id = $1
ORDER BY e.full_name
`

type ListPayslipsByRunRow struct {
	ID              pgtype.UUID        `json:"id"`
	PayrollRunID    pgtype.UUID        `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID        `json:"employee_id"`
	GrossSalary     pgtype.Numeric     `json:"gross_salary"`
	TotalDeductions pgtype.Numeric     `json:"total_deductions"`
	NetSalary       pgtype.Numeric     `json:"net_salary"`
	Breakdown       []byte             `json:"breakdown"`
	Status          string             `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	EmployeeName    string             `json:"employee_name"`
	EmployeeCode    string             `json:"employee_code"`
}

func (q *Queries) ListPayslipsByRun(ctx context.Context, payrollRunID pgtype.UUID) ([]ListPayslipsByRunRow, error) {
	rows, err := q.db.Query(ctx, listPayslipsByRun, payrollRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPayslipsByRunRow
	for rows.Next() {
		var i ListPayslipsByRunRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollRunID,
			&i.EmployeeID,
			&i.GrossSalary,
			&i.TotalDeductions,
			&i.NetSalary,
			&i.Breakdown,
			&i.Status,
			&i.CreatedAt,
			&i.EmployeeName,
			&i.EmployeeCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalaryStructures = `-- name: ListSalaryStructures :many
SELECT id, tenant_id, name, basic, hra, da, other_allowances, deductions, created_at, updated_at FROM salary_structures
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListSalaryStructures(ctx context.Context, tenantID pgtype.UUID) ([]SalaryStructure, error) {
	rows, err := q.db.Query(ctx, listSalaryStructures, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalaryStructure
	for rows.Next() {
		var i SalaryStructure
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Basic,
			&i.Hra,
			&i.Da,
			&i.OtherAllowances,
			&i.Deductions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffAwards = `-- name: ListStaffAwards :many
SELECT sa.id, sa.tenant_id, sa.employee_id, sa.award_name, sa.category, sa.awarded_date, sa.awarded_by, sa.description, sa.bonus_amount, sa.created_at, e.full_name as employee_name
FROM staff_awards sa
JOIN employees e ON sa.employee_id = e.id
WHERE sa.tenant_id = $1
ORDER BY sa.awarded_date DESC
`

type ListStaffAwardsRow struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	EmployeeID   pgtype.UUID        `json:"employee_id"`
	AwardName    string             `json:"award_name"`
	Category     pgtype.Text        `json:"category"`
	AwardedDate  pgtype.Date        `json:"awarded_date"`
	AwardedBy    pgtype.Text        `json:"awarded_by"`
	Description  pgtype.Text        `json:"description"`
	BonusAmount  pgtype.Numeric     `json:"bonus_amount"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	EmployeeName string             `json:"employee_name"`
}

func (q *Queries) ListStaffAwards(ctx context.Context, tenantID pgtype.UUID) ([]ListStaffAwardsRow, error) {
	rows, err := q.db.Query(ctx, listStaffAwards, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStaffAwardsRow
	for rows.Next() {
		var i ListStaffAwardsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeID,
			&i.AwardName,
			&i.Category,
			&i.AwardedDate,
			&i.AwardedBy,
			&i.Description,
			&i.BonusAmount,
			&i.CreatedAt,
			&i.EmployeeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffLeaveRequests = `-- name: ListStaffLeaveRequests :many
SELECT lr.id, lr.tenant_id, lr.employee_id, lr.leave_type_id, lr.start_date, lr.end_date, lr.reason, lr.status, lr.reviewed_by, lr.reviewed_at, lr.remarks, lr.created_at, lt.name as leave_name, e.full_name as employee_name
FROM staff_leave_requests lr
JOIN staff_leave_types lt ON lr.leave_type_id = lt.id
JOIN employees e ON lr.employee_id = e.id
WHERE lr.tenant_id = $1
  AND ($2::UUID IS NULL OR lr.employee_id = $2::UUID)
  AND ($3::TEXT = '' OR lr.status = $3::TEXT)
ORDER BY lr.created_at DESC
`

type ListStaffLeaveRequestsParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	EmployeeID pgtype.UUID `json:"employee_id"`
	Status     string      `json:"status"`
}

type ListStaffLeaveRequestsRow struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	EmployeeID   pgtype.UUID        `json:"employee_id"`
	LeaveTypeID  pgtype.UUID        `json:"leave_type_id"`
	StartDate    pgtype.Date        `json:"start_date"`
	EndDate      pgtype.Date        `json:"end_date"`
	Reason       pgtype.Text        `json:"reason"`
	Status       string             `json:"status"`
	ReviewedBy   pgtype.UUID        `json:"reviewed_by"`
	ReviewedAt   pgtype.Timestamptz `json:"reviewed_at"`
	Remarks      pgtype.Text        `json:"remarks"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	LeaveName    string             `json:"leave_name"`
	EmployeeName string             `json:"employee_name"`
}

func (q *Queries) ListStaffLeaveRequests(ctx context.Context, arg ListStaffLeaveRequestsParams) ([]ListStaffLeaveRequestsRow, error) {
	rows, err := q.db.Query(ctx, listStaffLeaveRequests, arg.TenantID, arg.EmployeeID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStaffLeaveRequestsRow
	for rows.Next() {
		var i ListStaffLeaveRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeID,
			&i.LeaveTypeID,
			&i.StartDate,
			&i.EndDate,
			&i.Reason,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.Remarks,
			&i.CreatedAt,
			&i.LeaveName,
			&i.EmployeeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffTransfers = `-- name: ListStaffTransfers :many
SELECT st.id, st.tenant_id, st.employee_id, st.from_branch_id, st.to_branch_id, st.transfer_date, st.reason, st.authorized_by, st.status, st.created_at, e.full_name as employee_name
FROM staff_transfers st
JOIN employees e ON st.employee_id = e.id
WHERE st.tenant_id = $1
ORDER BY st.transfer_date DESC
`

type ListStaffTransfersRow struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	EmployeeID   pgtype.UUID        `json:"employee_id"`
	FromBranchID pgtype.UUID        `json:"from_branch_id"`
	ToBranchID   pgtype.UUID        `json:"to_branch_id"`
	TransferDate pgtype.Date        `json:"transfer_date"`
	Reason       pgtype.Text        `json:"reason"`
	AuthorizedBy pgtype.UUID        `json:"authorized_by"`
	Status       string             `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	EmployeeName string             `json:"employee_name"`
}

func (q *Queries) ListStaffTransfers(ctx context.Context, tenantID pgtype.UUID) ([]ListStaffTransfersRow, error) {
	rows, err := q.db.Query(ctx, listStaffTransfers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStaffTransfersRow
	for rows.Next() {
		var i ListStaffTransfersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeID,
			&i.FromBranchID,
			&i.ToBranchID,
			&i.TransferDate,
			&i.Reason,
			&i.AuthorizedBy,
			&i.Status,
			&i.CreatedAt,
			&i.EmployeeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeacherSubjectSpecializations = `-- name: ListTeacherSubjectSpecializations :many
SELECT ts.id, ts.tenant_id, ts.teacher_id, ts.subject_id, ts.created_at, e.full_name as teacher_name, s.name as subject_name
FROM teacher_subject_specializations ts
JOIN employees e ON ts.teacher_id = e.id
JOIN subjects s ON ts.subject_id = s.id
WHERE ts.tenant_id = $1 
  AND ($2::BOOLEAN = false OR ts.teacher_id = $3::UUID)
`

type ListTeacherSubjectSpecializationsParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	FilterTeacher bool        `json:"filter_teacher"`
	TeacherID     pgtype.UUID `json:"teacher_id"`
}

type ListTeacherSubjectSpecializationsRow struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	TeacherID   pgtype.UUID        `json:"teacher_id"`
	SubjectID   pgtype.UUID        `json:"subject_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	TeacherName string             `json:"teacher_name"`
	SubjectName string             `json:"subject_name"`
}

func (q *Queries) ListTeacherSubjectSpecializations(ctx context.Context, arg ListTeacherSubjectSpecializationsParams) ([]ListTeacherSubjectSpecializationsRow, error) {
	rows, err := q.db.Query(ctx, listTeacherSubjectSpecializations, arg.TenantID, arg.FilterTeacher, arg.TeacherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeacherSubjectSpecializationsRow
	for rows.Next() {
		var i ListTeacherSubjectSpecializationsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TeacherID,
			&i.SubjectID,
			&i.CreatedAt,
			&i.TeacherName,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAdjustmentStatus = `-- name: UpdateAdjustmentStatus :exec
UPDATE payroll_adjustments
SET status = $3, approved_by = $4, approved_at = NOW(), updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateAdjustmentStatusParams struct {
	ID         pgtype.UUID `json:"id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
	Status     string      `json:"status"`
	ApprovedBy pgtype.UUID `json:"approved_by"`
}

func (q *Queries) UpdateAdjustmentStatus(ctx context.Context, arg UpdateAdjustmentStatusParams) error {
	_, err := q.db.Exec(ctx, updateAdjustmentStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ApprovedBy,
	)
	return err
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE employees SET
    full_name = $3, email = $4, phone = $5, department = $6, designation = $7, 
    salary_structure_id = $8, bank_details = $9, status = $10, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at, rfid_tag, biometric_id
`

type UpdateEmployeeParams struct {
	ID                pgtype.UUID `json:"id"`
	TenantID          pgtype.UUID `json:"tenant_id"`
	FullName          string      `json:"full_name"`
	Email             pgtype.Text `json:"email"`
	Phone             pgtype.Text `json:"phone"`
	Department        pgtype.Text `json:"department"`
	Designation       pgtype.Text `json:"designation"`
	SalaryStructureID pgtype.UUID `json:"salary_structure_id"`
	BankDetails       []byte      `json:"bank_details"`
	Status            string      `json:"status"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, updateEmployee,
		arg.ID,
		arg.TenantID,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.Department,
		arg.Designation,
		arg.SalaryStructureID,
		arg.BankDetails,
		arg.Status,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RfidTag,
		&i.BiometricID,
	)
	return i, err
}

const updateLeaveRequestStatus = `-- name: UpdateLeaveRequestStatus :one
UPDATE staff_leave_requests
SET status = $1, reviewed_by = $2, reviewed_at = NOW(), remarks = $3
WHERE id = $4 AND tenant_id = $5
RETURNING id, tenant_id, employee_id, leave_type_id, start_date, end_date, reason, status, reviewed_by, reviewed_at, remarks, created_at
`

type UpdateLeaveRequestStatusParams struct {
	Status     string      `json:"status"`
	ReviewedBy pgtype.UUID `json:"reviewed_by"`
	Remarks    pgtype.Text `json:"remarks"`
	ID         pgtype.UUID `json:"id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) UpdateLeaveRequestStatus(ctx context.Context, arg UpdateLeaveRequestStatusParams) (StaffLeaveRequest, error) {
	row := q.db.QueryRow(ctx, updateLeaveRequestStatus,
		arg.Status,
		arg.ReviewedBy,
		arg.Remarks,
		arg.ID,
		arg.TenantID,
	)
	var i StaffLeaveRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.LeaveTypeID,
		&i.StartDate,
		&i.EndDate,
		&i.Reason,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.Remarks,
		&i.CreatedAt,
	)
	return i, err
}

const updatePayrollRunStatus = `-- name: UpdatePayrollRunStatus :one
UPDATE payroll_runs SET status = $3, run_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, month, year, status, run_by, run_at, created_at
`

type UpdatePayrollRunStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

func (q *Queries) UpdatePayrollRunStatus(ctx context.Context, arg UpdatePayrollRunStatusParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, updatePayrollRunStatus, arg.ID, arg.TenantID, arg.Status)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}
