// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hrms.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAdjustment = `-- name: CreateAdjustment :one
INSERT INTO payroll_adjustments (
    tenant_id, employee_id, type, amount, description, status
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, employee_id, payroll_run_id, type, amount, description, status, approved_by, approved_at, created_at, updated_at
`

type CreateAdjustmentParams struct {
	TenantID    pgtype.UUID    `json:"tenant_id"`
	EmployeeID  pgtype.UUID    `json:"employee_id"`
	Type        string         `json:"type"`
	Amount      pgtype.Numeric `json:"amount"`
	Description pgtype.Text    `json:"description"`
	Status      string         `json:"status"`
}

func (q *Queries) CreateAdjustment(ctx context.Context, arg CreateAdjustmentParams) (PayrollAdjustment, error) {
	row := q.db.QueryRow(ctx, createAdjustment,
		arg.TenantID,
		arg.EmployeeID,
		arg.Type,
		arg.Amount,
		arg.Description,
		arg.Status,
	)
	var i PayrollAdjustment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.PayrollRunID,
		&i.Type,
		&i.Amount,
		&i.Description,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (
    tenant_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at
`

type CreateEmployeeParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	EmployeeCode      string      `json:"employee_code"`
	FullName          string      `json:"full_name"`
	Email             pgtype.Text `json:"email"`
	Phone             pgtype.Text `json:"phone"`
	Department        pgtype.Text `json:"department"`
	Designation       pgtype.Text `json:"designation"`
	JoinDate          pgtype.Date `json:"join_date"`
	SalaryStructureID pgtype.UUID `json:"salary_structure_id"`
	BankDetails       []byte      `json:"bank_details"`
	Status            string      `json:"status"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.TenantID,
		arg.EmployeeCode,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.Department,
		arg.Designation,
		arg.JoinDate,
		arg.SalaryStructureID,
		arg.BankDetails,
		arg.Status,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayrollRun = `-- name: CreatePayrollRun :one
INSERT INTO payroll_runs (
    tenant_id, month, year, status, run_by
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, month, year, status, run_by, run_at, created_at
`

type CreatePayrollRunParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Month    int32       `json:"month"`
	Year     int32       `json:"year"`
	Status   string      `json:"status"`
	RunBy    pgtype.UUID `json:"run_by"`
}

func (q *Queries) CreatePayrollRun(ctx context.Context, arg CreatePayrollRunParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, createPayrollRun,
		arg.TenantID,
		arg.Month,
		arg.Year,
		arg.Status,
		arg.RunBy,
	)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}

const createPayslip = `-- name: CreatePayslip :one
INSERT INTO payslips (
    payroll_run_id, employee_id, gross_salary, total_deductions, net_salary, breakdown, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, payroll_run_id, employee_id, gross_salary, total_deductions, net_salary, breakdown, status, created_at
`

type CreatePayslipParams struct {
	PayrollRunID    pgtype.UUID    `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID    `json:"employee_id"`
	GrossSalary     pgtype.Numeric `json:"gross_salary"`
	TotalDeductions pgtype.Numeric `json:"total_deductions"`
	NetSalary       pgtype.Numeric `json:"net_salary"`
	Breakdown       []byte         `json:"breakdown"`
	Status          string         `json:"status"`
}

func (q *Queries) CreatePayslip(ctx context.Context, arg CreatePayslipParams) (Payslip, error) {
	row := q.db.QueryRow(ctx, createPayslip,
		arg.PayrollRunID,
		arg.EmployeeID,
		arg.GrossSalary,
		arg.TotalDeductions,
		arg.NetSalary,
		arg.Breakdown,
		arg.Status,
	)
	var i Payslip
	err := row.Scan(
		&i.ID,
		&i.PayrollRunID,
		&i.EmployeeID,
		&i.GrossSalary,
		&i.TotalDeductions,
		&i.NetSalary,
		&i.Breakdown,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createSalaryStructure = `-- name: CreateSalaryStructure :one
INSERT INTO salary_structures (
    tenant_id, name, basic, hra, da, other_allowances, deductions
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, name, basic, hra, da, other_allowances, deductions, created_at, updated_at
`

type CreateSalaryStructureParams struct {
	TenantID        pgtype.UUID    `json:"tenant_id"`
	Name            string         `json:"name"`
	Basic           pgtype.Numeric `json:"basic"`
	Hra             pgtype.Numeric `json:"hra"`
	Da              pgtype.Numeric `json:"da"`
	OtherAllowances []byte         `json:"other_allowances"`
	Deductions      []byte         `json:"deductions"`
}

func (q *Queries) CreateSalaryStructure(ctx context.Context, arg CreateSalaryStructureParams) (SalaryStructure, error) {
	row := q.db.QueryRow(ctx, createSalaryStructure,
		arg.TenantID,
		arg.Name,
		arg.Basic,
		arg.Hra,
		arg.Da,
		arg.OtherAllowances,
		arg.Deductions,
	)
	var i SalaryStructure
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Basic,
		&i.Hra,
		&i.Da,
		&i.OtherAllowances,
		&i.Deductions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApprovedAdjustmentsForRun = `-- name: GetApprovedAdjustmentsForRun :many
SELECT id, tenant_id, employee_id, payroll_run_id, type, amount, description, status, approved_by, approved_at, created_at, updated_at FROM payroll_adjustments
WHERE tenant_id = $1 AND employee_id = $2 AND status = 'approved' AND payroll_run_id IS NULL
`

type GetApprovedAdjustmentsForRunParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	EmployeeID pgtype.UUID `json:"employee_id"`
}

// Adjustments that are approved but not yet processed in a run
func (q *Queries) GetApprovedAdjustmentsForRun(ctx context.Context, arg GetApprovedAdjustmentsForRunParams) ([]PayrollAdjustment, error) {
	rows, err := q.db.Query(ctx, getApprovedAdjustmentsForRun, arg.TenantID, arg.EmployeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayrollAdjustment
	for rows.Next() {
		var i PayrollAdjustment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeID,
			&i.PayrollRunID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployee = `-- name: GetEmployee :one
SELECT id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at FROM employees WHERE id = $1 AND tenant_id = $2
`

type GetEmployeeParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetEmployee(ctx context.Context, arg GetEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployee, arg.ID, arg.TenantID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeePayslips = `-- name: GetEmployeePayslips :many
SELECT 
    p.id, p.payroll_run_id, p.employee_id, p.gross_salary, p.total_deductions, p.net_salary, p.breakdown, p.status, p.created_at,
    pr.month,
    pr.year
FROM payslips p
JOIN payroll_runs pr ON p.payroll_run_id = pr.id
WHERE p.employee_id = $1
ORDER BY pr.year DESC, pr.month DESC
LIMIT $2 OFFSET $3
`

type GetEmployeePayslipsParams struct {
	EmployeeID pgtype.UUID `json:"employee_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetEmployeePayslipsRow struct {
	ID              pgtype.UUID        `json:"id"`
	PayrollRunID    pgtype.UUID        `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID        `json:"employee_id"`
	GrossSalary     pgtype.Numeric     `json:"gross_salary"`
	TotalDeductions pgtype.Numeric     `json:"total_deductions"`
	NetSalary       pgtype.Numeric     `json:"net_salary"`
	Breakdown       []byte             `json:"breakdown"`
	Status          string             `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	Month           int32              `json:"month"`
	Year            int32              `json:"year"`
}

func (q *Queries) GetEmployeePayslips(ctx context.Context, arg GetEmployeePayslipsParams) ([]GetEmployeePayslipsRow, error) {
	rows, err := q.db.Query(ctx, getEmployeePayslips, arg.EmployeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeePayslipsRow
	for rows.Next() {
		var i GetEmployeePayslipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollRunID,
			&i.EmployeeID,
			&i.GrossSalary,
			&i.TotalDeductions,
			&i.NetSalary,
			&i.Breakdown,
			&i.Status,
			&i.CreatedAt,
			&i.Month,
			&i.Year,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeSalaryInfo = `-- name: GetEmployeeSalaryInfo :one
SELECT 
    e.id, e.tenant_id, e.user_id, e.employee_code, e.full_name, e.email, e.phone, e.department, e.designation, e.join_date, e.salary_structure_id, e.bank_details, e.status, e.created_at, e.updated_at,
    ss.basic,
    ss.hra,
    ss.da,
    ss.other_allowances,
    ss.deductions
FROM employees e
JOIN salary_structures ss ON e.salary_structure_id = ss.id
WHERE e.id = $1 AND e.tenant_id = $2
`

type GetEmployeeSalaryInfoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetEmployeeSalaryInfoRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	EmployeeCode      string             `json:"employee_code"`
	FullName          string             `json:"full_name"`
	Email             pgtype.Text        `json:"email"`
	Phone             pgtype.Text        `json:"phone"`
	Department        pgtype.Text        `json:"department"`
	Designation       pgtype.Text        `json:"designation"`
	JoinDate          pgtype.Date        `json:"join_date"`
	SalaryStructureID pgtype.UUID        `json:"salary_structure_id"`
	BankDetails       []byte             `json:"bank_details"`
	Status            string             `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	Basic             pgtype.Numeric     `json:"basic"`
	Hra               pgtype.Numeric     `json:"hra"`
	Da                pgtype.Numeric     `json:"da"`
	OtherAllowances   []byte             `json:"other_allowances"`
	Deductions        []byte             `json:"deductions"`
}

func (q *Queries) GetEmployeeSalaryInfo(ctx context.Context, arg GetEmployeeSalaryInfoParams) (GetEmployeeSalaryInfoRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeSalaryInfo, arg.ID, arg.TenantID)
	var i GetEmployeeSalaryInfoRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Basic,
		&i.Hra,
		&i.Da,
		&i.OtherAllowances,
		&i.Deductions,
	)
	return i, err
}

const getPayrollRun = `-- name: GetPayrollRun :one
SELECT id, tenant_id, month, year, status, run_by, run_at, created_at FROM payroll_runs WHERE id = $1 AND tenant_id = $2
`

type GetPayrollRunParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetPayrollRun(ctx context.Context, arg GetPayrollRunParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, getPayrollRun, arg.ID, arg.TenantID)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingAdjustments = `-- name: GetPendingAdjustments :many
SELECT id, tenant_id, employee_id, payroll_run_id, type, amount, description, status, approved_by, approved_at, created_at, updated_at FROM payroll_adjustments
WHERE tenant_id = $1 AND employee_id = $2 AND status = 'pending'
`

type GetPendingAdjustmentsParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	EmployeeID pgtype.UUID `json:"employee_id"`
}

func (q *Queries) GetPendingAdjustments(ctx context.Context, arg GetPendingAdjustmentsParams) ([]PayrollAdjustment, error) {
	rows, err := q.db.Query(ctx, getPendingAdjustments, arg.TenantID, arg.EmployeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayrollAdjustment
	for rows.Next() {
		var i PayrollAdjustment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeID,
			&i.PayrollRunID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkAdjustmentToRun = `-- name: LinkAdjustmentToRun :exec
UPDATE payroll_adjustments
SET payroll_run_id = $3, status = 'processed', updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type LinkAdjustmentToRunParams struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	PayrollRunID pgtype.UUID `json:"payroll_run_id"`
}

func (q *Queries) LinkAdjustmentToRun(ctx context.Context, arg LinkAdjustmentToRunParams) error {
	_, err := q.db.Exec(ctx, linkAdjustmentToRun, arg.ID, arg.TenantID, arg.PayrollRunID)
	return err
}

const listEmployees = `-- name: ListEmployees :many
SELECT id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at FROM employees
WHERE tenant_id = $1
ORDER BY full_name
LIMIT $2 OFFSET $3
`

type ListEmployeesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListEmployees(ctx context.Context, arg ListEmployeesParams) ([]Employee, error) {
	rows, err := q.db.Query(ctx, listEmployees, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.EmployeeCode,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.Department,
			&i.Designation,
			&i.JoinDate,
			&i.SalaryStructureID,
			&i.BankDetails,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayrollRuns = `-- name: ListPayrollRuns :many
SELECT id, tenant_id, month, year, status, run_by, run_at, created_at FROM payroll_runs
WHERE tenant_id = $1
ORDER BY year DESC, month DESC
LIMIT $2 OFFSET $3
`

type ListPayrollRunsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListPayrollRuns(ctx context.Context, arg ListPayrollRunsParams) ([]PayrollRun, error) {
	rows, err := q.db.Query(ctx, listPayrollRuns, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayrollRun
	for rows.Next() {
		var i PayrollRun
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Month,
			&i.Year,
			&i.Status,
			&i.RunBy,
			&i.RunAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayslipsByRun = `-- name: ListPayslipsByRun :many
SELECT 
    p.id, p.payroll_run_id, p.employee_id, p.gross_salary, p.total_deductions, p.net_salary, p.breakdown, p.status, p.created_at,
    e.full_name as employee_name,
    e.employee_code
FROM payslips p
JOIN employees e ON p.employee_id = e.id
WHERE p.payroll_run_id = $1
ORDER BY e.full_name
`

type ListPayslipsByRunRow struct {
	ID              pgtype.UUID        `json:"id"`
	PayrollRunID    pgtype.UUID        `json:"payroll_run_id"`
	EmployeeID      pgtype.UUID        `json:"employee_id"`
	GrossSalary     pgtype.Numeric     `json:"gross_salary"`
	TotalDeductions pgtype.Numeric     `json:"total_deductions"`
	NetSalary       pgtype.Numeric     `json:"net_salary"`
	Breakdown       []byte             `json:"breakdown"`
	Status          string             `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	EmployeeName    string             `json:"employee_name"`
	EmployeeCode    string             `json:"employee_code"`
}

func (q *Queries) ListPayslipsByRun(ctx context.Context, payrollRunID pgtype.UUID) ([]ListPayslipsByRunRow, error) {
	rows, err := q.db.Query(ctx, listPayslipsByRun, payrollRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPayslipsByRunRow
	for rows.Next() {
		var i ListPayslipsByRunRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollRunID,
			&i.EmployeeID,
			&i.GrossSalary,
			&i.TotalDeductions,
			&i.NetSalary,
			&i.Breakdown,
			&i.Status,
			&i.CreatedAt,
			&i.EmployeeName,
			&i.EmployeeCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalaryStructures = `-- name: ListSalaryStructures :many
SELECT id, tenant_id, name, basic, hra, da, other_allowances, deductions, created_at, updated_at FROM salary_structures
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListSalaryStructures(ctx context.Context, tenantID pgtype.UUID) ([]SalaryStructure, error) {
	rows, err := q.db.Query(ctx, listSalaryStructures, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalaryStructure
	for rows.Next() {
		var i SalaryStructure
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Basic,
			&i.Hra,
			&i.Da,
			&i.OtherAllowances,
			&i.Deductions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAdjustmentStatus = `-- name: UpdateAdjustmentStatus :exec
UPDATE payroll_adjustments
SET status = $3, approved_by = $4, approved_at = NOW(), updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateAdjustmentStatusParams struct {
	ID         pgtype.UUID `json:"id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
	Status     string      `json:"status"`
	ApprovedBy pgtype.UUID `json:"approved_by"`
}

func (q *Queries) UpdateAdjustmentStatus(ctx context.Context, arg UpdateAdjustmentStatusParams) error {
	_, err := q.db.Exec(ctx, updateAdjustmentStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ApprovedBy,
	)
	return err
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE employees SET
    full_name = $3, email = $4, phone = $5, department = $6, designation = $7, 
    salary_structure_id = $8, bank_details = $9, status = $10, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, user_id, employee_code, full_name, email, phone, department, designation, join_date, salary_structure_id, bank_details, status, created_at, updated_at
`

type UpdateEmployeeParams struct {
	ID                pgtype.UUID `json:"id"`
	TenantID          pgtype.UUID `json:"tenant_id"`
	FullName          string      `json:"full_name"`
	Email             pgtype.Text `json:"email"`
	Phone             pgtype.Text `json:"phone"`
	Department        pgtype.Text `json:"department"`
	Designation       pgtype.Text `json:"designation"`
	SalaryStructureID pgtype.UUID `json:"salary_structure_id"`
	BankDetails       []byte      `json:"bank_details"`
	Status            string      `json:"status"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, updateEmployee,
		arg.ID,
		arg.TenantID,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.Department,
		arg.Designation,
		arg.SalaryStructureID,
		arg.BankDetails,
		arg.Status,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.EmployeeCode,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.Designation,
		&i.JoinDate,
		&i.SalaryStructureID,
		&i.BankDetails,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePayrollRunStatus = `-- name: UpdatePayrollRunStatus :one
UPDATE payroll_runs SET status = $3, run_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, month, year, status, run_by, run_at, created_at
`

type UpdatePayrollRunStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

func (q *Queries) UpdatePayrollRunStatus(ctx context.Context, arg UpdatePayrollRunStatusParams) (PayrollRun, error) {
	row := q.db.QueryRow(ctx, updatePayrollRunStatus, arg.ID, arg.TenantID, arg.Status)
	var i PayrollRun
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Month,
		&i.Year,
		&i.Status,
		&i.RunBy,
		&i.RunAt,
		&i.CreatedAt,
	)
	return i, err
}
