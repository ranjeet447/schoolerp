// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: safety.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkOutVisitor = `-- name: CheckOutVisitor :one
UPDATE visitor_logs
SET 
    check_out_at = NOW(),
    remarks = COALESCE($3, remarks)
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, visitor_id, purpose, contact_person_id, check_in_at, check_out_at, badge_number, remarks, created_at
`

type CheckOutVisitorParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Remarks  pgtype.Text `json:"remarks"`
}

func (q *Queries) CheckOutVisitor(ctx context.Context, arg CheckOutVisitorParams) (VisitorLog, error) {
	row := q.db.QueryRow(ctx, checkOutVisitor, arg.ID, arg.TenantID, arg.Remarks)
	var i VisitorLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.VisitorID,
		&i.Purpose,
		&i.ContactPersonID,
		&i.CheckInAt,
		&i.CheckOutAt,
		&i.BadgeNumber,
		&i.Remarks,
		&i.CreatedAt,
	)
	return i, err
}

const createDisciplineIncident = `-- name: CreateDisciplineIncident :one
INSERT INTO discipline_incidents (
    tenant_id, student_id, reporter_id, incident_date, category, title, description, action_taken, status, parent_visibility
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tenant_id, student_id, reporter_id, incident_date, category, title, description, action_taken, status, parent_visibility, created_at, updated_at
`

type CreateDisciplineIncidentParams struct {
	TenantID         pgtype.UUID        `json:"tenant_id"`
	StudentID        pgtype.UUID        `json:"student_id"`
	ReporterID       pgtype.UUID        `json:"reporter_id"`
	IncidentDate     pgtype.Timestamptz `json:"incident_date"`
	Category         string             `json:"category"`
	Title            string             `json:"title"`
	Description      pgtype.Text        `json:"description"`
	ActionTaken      pgtype.Text        `json:"action_taken"`
	Status           string             `json:"status"`
	ParentVisibility pgtype.Bool        `json:"parent_visibility"`
}

func (q *Queries) CreateDisciplineIncident(ctx context.Context, arg CreateDisciplineIncidentParams) (DisciplineIncident, error) {
	row := q.db.QueryRow(ctx, createDisciplineIncident,
		arg.TenantID,
		arg.StudentID,
		arg.ReporterID,
		arg.IncidentDate,
		arg.Category,
		arg.Title,
		arg.Description,
		arg.ActionTaken,
		arg.Status,
		arg.ParentVisibility,
	)
	var i DisciplineIncident
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.ReporterID,
		&i.IncidentDate,
		&i.Category,
		&i.Title,
		&i.Description,
		&i.ActionTaken,
		&i.Status,
		&i.ParentVisibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEmergencyBroadcast = `-- name: CreateEmergencyBroadcast :one
INSERT INTO emergency_broadcasts (
    tenant_id, message, channel, target_roles, status, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, message, channel, target_roles, status, created_by, created_at
`

type CreateEmergencyBroadcastParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Message     string      `json:"message"`
	Channel     string      `json:"channel"`
	TargetRoles []string    `json:"target_roles"`
	Status      string      `json:"status"`
	CreatedBy   pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateEmergencyBroadcast(ctx context.Context, arg CreateEmergencyBroadcastParams) (EmergencyBroadcast, error) {
	row := q.db.QueryRow(ctx, createEmergencyBroadcast,
		arg.TenantID,
		arg.Message,
		arg.Channel,
		arg.TargetRoles,
		arg.Status,
		arg.CreatedBy,
	)
	var i EmergencyBroadcast
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Message,
		&i.Channel,
		&i.TargetRoles,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createPickupAuthorization = `-- name: CreatePickupAuthorization :one
INSERT INTO pickup_authorizations (
    tenant_id, student_id, name, relationship, phone, photo_url
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, student_id, name, relationship, phone, photo_url, is_active, created_at, updated_at
`

type CreatePickupAuthorizationParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	StudentID    pgtype.UUID `json:"student_id"`
	Name         string      `json:"name"`
	Relationship string      `json:"relationship"`
	Phone        string      `json:"phone"`
	PhotoUrl     pgtype.Text `json:"photo_url"`
}

func (q *Queries) CreatePickupAuthorization(ctx context.Context, arg CreatePickupAuthorizationParams) (PickupAuthorization, error) {
	row := q.db.QueryRow(ctx, createPickupAuthorization,
		arg.TenantID,
		arg.StudentID,
		arg.Name,
		arg.Relationship,
		arg.Phone,
		arg.PhotoUrl,
	)
	var i PickupAuthorization
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Name,
		&i.Relationship,
		&i.Phone,
		&i.PhotoUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVisitor = `-- name: CreateVisitor :one
INSERT INTO visitors (
    tenant_id, full_name, phone, email, id_type, id_number, photo_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, full_name, phone, email, id_type, id_number, photo_url, created_at, updated_at
`

type CreateVisitorParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	FullName string      `json:"full_name"`
	Phone    string      `json:"phone"`
	Email    pgtype.Text `json:"email"`
	IDType   pgtype.Text `json:"id_type"`
	IDNumber pgtype.Text `json:"id_number"`
	PhotoUrl pgtype.Text `json:"photo_url"`
}

func (q *Queries) CreateVisitor(ctx context.Context, arg CreateVisitorParams) (Visitor, error) {
	row := q.db.QueryRow(ctx, createVisitor,
		arg.TenantID,
		arg.FullName,
		arg.Phone,
		arg.Email,
		arg.IDType,
		arg.IDNumber,
		arg.PhotoUrl,
	)
	var i Visitor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.IDType,
		&i.IDNumber,
		&i.PhotoUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVisitorLog = `-- name: CreateVisitorLog :one
INSERT INTO visitor_logs (
    tenant_id, visitor_id, purpose, contact_person_id, badge_number, remarks
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, visitor_id, purpose, contact_person_id, check_in_at, check_out_at, badge_number, remarks, created_at
`

type CreateVisitorLogParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	VisitorID       pgtype.UUID `json:"visitor_id"`
	Purpose         string      `json:"purpose"`
	ContactPersonID pgtype.UUID `json:"contact_person_id"`
	BadgeNumber     pgtype.Text `json:"badge_number"`
	Remarks         pgtype.Text `json:"remarks"`
}

func (q *Queries) CreateVisitorLog(ctx context.Context, arg CreateVisitorLogParams) (VisitorLog, error) {
	row := q.db.QueryRow(ctx, createVisitorLog,
		arg.TenantID,
		arg.VisitorID,
		arg.Purpose,
		arg.ContactPersonID,
		arg.BadgeNumber,
		arg.Remarks,
	)
	var i VisitorLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.VisitorID,
		&i.Purpose,
		&i.ContactPersonID,
		&i.CheckInAt,
		&i.CheckOutAt,
		&i.BadgeNumber,
		&i.Remarks,
		&i.CreatedAt,
	)
	return i, err
}

const deactivatePickupAuthorization = `-- name: DeactivatePickupAuthorization :exec
UPDATE pickup_authorizations
SET is_active = FALSE, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type DeactivatePickupAuthorizationParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeactivatePickupAuthorization(ctx context.Context, arg DeactivatePickupAuthorizationParams) error {
	_, err := q.db.Exec(ctx, deactivatePickupAuthorization, arg.ID, arg.TenantID)
	return err
}

const getDisciplineIncident = `-- name: GetDisciplineIncident :one
SELECT id, tenant_id, student_id, reporter_id, incident_date, category, title, description, action_taken, status, parent_visibility, created_at, updated_at FROM discipline_incidents WHERE id = $1 AND tenant_id = $2
`

type GetDisciplineIncidentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetDisciplineIncident(ctx context.Context, arg GetDisciplineIncidentParams) (DisciplineIncident, error) {
	row := q.db.QueryRow(ctx, getDisciplineIncident, arg.ID, arg.TenantID)
	var i DisciplineIncident
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.ReporterID,
		&i.IncidentDate,
		&i.Category,
		&i.Title,
		&i.Description,
		&i.ActionTaken,
		&i.Status,
		&i.ParentVisibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVisitorByPhone = `-- name: GetVisitorByPhone :one
SELECT id, tenant_id, full_name, phone, email, id_type, id_number, photo_url, created_at, updated_at FROM visitors WHERE tenant_id = $1 AND phone = $2
`

type GetVisitorByPhoneParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Phone    string      `json:"phone"`
}

func (q *Queries) GetVisitorByPhone(ctx context.Context, arg GetVisitorByPhoneParams) (Visitor, error) {
	row := q.db.QueryRow(ctx, getVisitorByPhone, arg.TenantID, arg.Phone)
	var i Visitor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.IDType,
		&i.IDNumber,
		&i.PhotoUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDisciplineIncidents = `-- name: ListDisciplineIncidents :many
SELECT 
    di.id, di.tenant_id, di.student_id, di.reporter_id, di.incident_date, di.category, di.title, di.description, di.action_taken, di.status, di.parent_visibility, di.created_at, di.updated_at,
    s.full_name as student_name,
    u.full_name as reporter_name
FROM discipline_incidents di
JOIN students s ON di.student_id = s.id
JOIN users u ON di.reporter_id = u.id
WHERE di.tenant_id = $1
ORDER BY di.incident_date DESC
LIMIT $2 OFFSET $3
`

type ListDisciplineIncidentsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListDisciplineIncidentsRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	StudentID        pgtype.UUID        `json:"student_id"`
	ReporterID       pgtype.UUID        `json:"reporter_id"`
	IncidentDate     pgtype.Timestamptz `json:"incident_date"`
	Category         string             `json:"category"`
	Title            string             `json:"title"`
	Description      pgtype.Text        `json:"description"`
	ActionTaken      pgtype.Text        `json:"action_taken"`
	Status           string             `json:"status"`
	ParentVisibility pgtype.Bool        `json:"parent_visibility"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	StudentName      string             `json:"student_name"`
	ReporterName     string             `json:"reporter_name"`
}

func (q *Queries) ListDisciplineIncidents(ctx context.Context, arg ListDisciplineIncidentsParams) ([]ListDisciplineIncidentsRow, error) {
	rows, err := q.db.Query(ctx, listDisciplineIncidents, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDisciplineIncidentsRow
	for rows.Next() {
		var i ListDisciplineIncidentsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.ReporterID,
			&i.IncidentDate,
			&i.Category,
			&i.Title,
			&i.Description,
			&i.ActionTaken,
			&i.Status,
			&i.ParentVisibility,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentName,
			&i.ReporterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmergencyBroadcasts = `-- name: ListEmergencyBroadcasts :many
SELECT 
    eb.id, eb.tenant_id, eb.message, eb.channel, eb.target_roles, eb.status, eb.created_by, eb.created_at,
    u.full_name as created_by_name
FROM emergency_broadcasts eb
JOIN users u ON eb.created_by = u.id
WHERE eb.tenant_id = $1
ORDER BY eb.created_at DESC
LIMIT $2 OFFSET $3
`

type ListEmergencyBroadcastsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListEmergencyBroadcastsRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	Message       string             `json:"message"`
	Channel       string             `json:"channel"`
	TargetRoles   []string           `json:"target_roles"`
	Status        string             `json:"status"`
	CreatedBy     pgtype.UUID        `json:"created_by"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CreatedByName string             `json:"created_by_name"`
}

func (q *Queries) ListEmergencyBroadcasts(ctx context.Context, arg ListEmergencyBroadcastsParams) ([]ListEmergencyBroadcastsRow, error) {
	rows, err := q.db.Query(ctx, listEmergencyBroadcasts, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmergencyBroadcastsRow
	for rows.Next() {
		var i ListEmergencyBroadcastsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Message,
			&i.Channel,
			&i.TargetRoles,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.CreatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPickupAuthorizations = `-- name: ListPickupAuthorizations :many
SELECT id, tenant_id, student_id, name, relationship, phone, photo_url, is_active, created_at, updated_at FROM pickup_authorizations
WHERE student_id = $1 AND tenant_id = $2 AND is_active = TRUE
`

type ListPickupAuthorizationsParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ListPickupAuthorizations(ctx context.Context, arg ListPickupAuthorizationsParams) ([]PickupAuthorization, error) {
	rows, err := q.db.Query(ctx, listPickupAuthorizations, arg.StudentID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PickupAuthorization
	for rows.Next() {
		var i PickupAuthorization
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.Name,
			&i.Relationship,
			&i.Phone,
			&i.PhotoUrl,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisitorLogs = `-- name: ListVisitorLogs :many
SELECT 
    vl.id, vl.tenant_id, vl.visitor_id, vl.purpose, vl.contact_person_id, vl.check_in_at, vl.check_out_at, vl.badge_number, vl.remarks, vl.created_at,
    v.full_name as visitor_name,
    v.phone as visitor_phone,
    u.full_name as contact_person_name
FROM visitor_logs vl
JOIN visitors v ON vl.visitor_id = v.id
LEFT JOIN users u ON vl.contact_person_id = u.id
WHERE vl.tenant_id = $1
ORDER BY vl.check_in_at DESC
LIMIT $2 OFFSET $3
`

type ListVisitorLogsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListVisitorLogsRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	VisitorID         pgtype.UUID        `json:"visitor_id"`
	Purpose           string             `json:"purpose"`
	ContactPersonID   pgtype.UUID        `json:"contact_person_id"`
	CheckInAt         pgtype.Timestamptz `json:"check_in_at"`
	CheckOutAt        pgtype.Timestamptz `json:"check_out_at"`
	BadgeNumber       pgtype.Text        `json:"badge_number"`
	Remarks           pgtype.Text        `json:"remarks"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	VisitorName       string             `json:"visitor_name"`
	VisitorPhone      string             `json:"visitor_phone"`
	ContactPersonName pgtype.Text        `json:"contact_person_name"`
}

func (q *Queries) ListVisitorLogs(ctx context.Context, arg ListVisitorLogsParams) ([]ListVisitorLogsRow, error) {
	rows, err := q.db.Query(ctx, listVisitorLogs, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVisitorLogsRow
	for rows.Next() {
		var i ListVisitorLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.VisitorID,
			&i.Purpose,
			&i.ContactPersonID,
			&i.CheckInAt,
			&i.CheckOutAt,
			&i.BadgeNumber,
			&i.Remarks,
			&i.CreatedAt,
			&i.VisitorName,
			&i.VisitorPhone,
			&i.ContactPersonName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDisciplineIncident = `-- name: UpdateDisciplineIncident :one
UPDATE discipline_incidents
SET 
    action_taken = $3,
    status = $4,
    parent_visibility = $5,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, student_id, reporter_id, incident_date, category, title, description, action_taken, status, parent_visibility, created_at, updated_at
`

type UpdateDisciplineIncidentParams struct {
	ID               pgtype.UUID `json:"id"`
	TenantID         pgtype.UUID `json:"tenant_id"`
	ActionTaken      pgtype.Text `json:"action_taken"`
	Status           string      `json:"status"`
	ParentVisibility pgtype.Bool `json:"parent_visibility"`
}

func (q *Queries) UpdateDisciplineIncident(ctx context.Context, arg UpdateDisciplineIncidentParams) (DisciplineIncident, error) {
	row := q.db.QueryRow(ctx, updateDisciplineIncident,
		arg.ID,
		arg.TenantID,
		arg.ActionTaken,
		arg.Status,
		arg.ParentVisibility,
	)
	var i DisciplineIncident
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.ReporterID,
		&i.IncidentDate,
		&i.Category,
		&i.Title,
		&i.Description,
		&i.ActionTaken,
		&i.Status,
		&i.ParentVisibility,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
