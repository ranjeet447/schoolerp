// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ai.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAIQueryLog = `-- name: CreateAIQueryLog :one
INSERT INTO ai_query_logs (
    tenant_id, user_id, provider, model, tokens_used, cost, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, user_id, provider, model, tokens_used, cost, metadata, created_at
`

type CreateAIQueryLogParams struct {
	TenantID   pgtype.UUID    `json:"tenant_id"`
	UserID     pgtype.UUID    `json:"user_id"`
	Provider   string         `json:"provider"`
	Model      string         `json:"model"`
	TokensUsed pgtype.Int4    `json:"tokens_used"`
	Cost       pgtype.Numeric `json:"cost"`
	Metadata   []byte         `json:"metadata"`
}

func (q *Queries) CreateAIQueryLog(ctx context.Context, arg CreateAIQueryLogParams) (AiQueryLog, error) {
	row := q.db.QueryRow(ctx, createAIQueryLog,
		arg.TenantID,
		arg.UserID,
		arg.Provider,
		arg.Model,
		arg.TokensUsed,
		arg.Cost,
		arg.Metadata,
	)
	var i AiQueryLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Provider,
		&i.Model,
		&i.TokensUsed,
		&i.Cost,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredAIChatSessions = `-- name: DeleteExpiredAIChatSessions :exec
DELETE FROM ai_chat_sessions WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredAIChatSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAIChatSessions)
	return err
}

const getAIChatSession = `-- name: GetAIChatSession :one
SELECT id, tenant_id, external_id, messages, metadata, expires_at, created_at, updated_at FROM ai_chat_sessions
WHERE tenant_id = $1 AND external_id = $2
`

type GetAIChatSessionParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	ExternalID string      `json:"external_id"`
}

func (q *Queries) GetAIChatSession(ctx context.Context, arg GetAIChatSessionParams) (AiChatSession, error) {
	row := q.db.QueryRow(ctx, getAIChatSession, arg.TenantID, arg.ExternalID)
	var i AiChatSession
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ExternalID,
		&i.Messages,
		&i.Metadata,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantAIUsage = `-- name: GetTenantAIUsage :many
SELECT 
    model,
    SUM(tokens_used) as total_tokens,
    SUM(cost) as total_cost,
    COUNT(*) as total_queries
FROM ai_query_logs
WHERE tenant_id = $1 AND created_at >= $2 AND created_at <= $3
GROUP BY model
`

type GetTenantAIUsageParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetTenantAIUsageRow struct {
	Model        string `json:"model"`
	TotalTokens  int64  `json:"total_tokens"`
	TotalCost    int64  `json:"total_cost"`
	TotalQueries int64  `json:"total_queries"`
}

func (q *Queries) GetTenantAIUsage(ctx context.Context, arg GetTenantAIUsageParams) ([]GetTenantAIUsageRow, error) {
	rows, err := q.db.Query(ctx, getTenantAIUsage, arg.TenantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTenantAIUsageRow
	for rows.Next() {
		var i GetTenantAIUsageRow
		if err := rows.Scan(
			&i.Model,
			&i.TotalTokens,
			&i.TotalCost,
			&i.TotalQueries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIQueryLogs = `-- name: ListAIQueryLogs :many
SELECT id, tenant_id, user_id, provider, model, tokens_used, cost, metadata, created_at FROM ai_query_logs
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAIQueryLogsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListAIQueryLogs(ctx context.Context, arg ListAIQueryLogsParams) ([]AiQueryLog, error) {
	rows, err := q.db.Query(ctx, listAIQueryLogs, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiQueryLog
	for rows.Next() {
		var i AiQueryLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.Provider,
			&i.Model,
			&i.TokensUsed,
			&i.Cost,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAIChatSession = `-- name: UpsertAIChatSession :one
INSERT INTO ai_chat_sessions (
    tenant_id, external_id, messages, metadata, expires_at
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (tenant_id, external_id) DO UPDATE
SET messages = $3,
    metadata = $4,
    expires_at = $5,
    updated_at = NOW()
RETURNING id, tenant_id, external_id, messages, metadata, expires_at, created_at, updated_at
`

type UpsertAIChatSessionParams struct {
	TenantID   pgtype.UUID        `json:"tenant_id"`
	ExternalID string             `json:"external_id"`
	Messages   []byte             `json:"messages"`
	Metadata   []byte             `json:"metadata"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) UpsertAIChatSession(ctx context.Context, arg UpsertAIChatSessionParams) (AiChatSession, error) {
	row := q.db.QueryRow(ctx, upsertAIChatSession,
		arg.TenantID,
		arg.ExternalID,
		arg.Messages,
		arg.Metadata,
		arg.ExpiresAt,
	)
	var i AiChatSession
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ExternalID,
		&i.Messages,
		&i.Metadata,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
