// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sis.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStudents = `-- name: CountStudents :one
SELECT count(*) FROM students
WHERE tenant_id = $1
`

func (q *Queries) CountStudents(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countStudents, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAcademicYear = `-- name: CreateAcademicYear :one

INSERT INTO academic_years (
    tenant_id, name, start_date, end_date, is_active
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, name, start_date, end_date, is_active, created_at
`

type CreateAcademicYearParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	Name      string      `json:"name"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	IsActive  pgtype.Bool `json:"is_active"`
}

// Academic Structure
func (q *Queries) CreateAcademicYear(ctx context.Context, arg CreateAcademicYearParams) (AcademicYear, error) {
	row := q.db.QueryRow(ctx, createAcademicYear,
		arg.TenantID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.IsActive,
	)
	var i AcademicYear
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createClass = `-- name: CreateClass :one
INSERT INTO classes (
    tenant_id, name, level, stream
) VALUES (
    $1, $2, $3, $4
) RETURNING id, tenant_id, name, level, stream, created_at
`

type CreateClassParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Name     string      `json:"name"`
	Level    pgtype.Int4 `json:"level"`
	Stream   pgtype.Text `json:"stream"`
}

func (q *Queries) CreateClass(ctx context.Context, arg CreateClassParams) (Class, error) {
	row := q.db.QueryRow(ctx, createClass,
		arg.TenantID,
		arg.Name,
		arg.Level,
		arg.Stream,
	)
	var i Class
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Level,
		&i.Stream,
		&i.CreatedAt,
	)
	return i, err
}

const createGuardian = `-- name: CreateGuardian :one
INSERT INTO guardians (
    tenant_id, full_name, phone, email, address
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, tenant_id, full_name, phone, email, address, created_at, user_id
`

type CreateGuardianParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	FullName string      `json:"full_name"`
	Phone    string      `json:"phone"`
	Email    pgtype.Text `json:"email"`
	Address  pgtype.Text `json:"address"`
}

func (q *Queries) CreateGuardian(ctx context.Context, arg CreateGuardianParams) (Guardian, error) {
	row := q.db.QueryRow(ctx, createGuardian,
		arg.TenantID,
		arg.FullName,
		arg.Phone,
		arg.Email,
		arg.Address,
	)
	var i Guardian
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Address,
		&i.CreatedAt,
		&i.UserID,
	)
	return i, err
}

const createSection = `-- name: CreateSection :one
INSERT INTO sections (
    tenant_id, class_id, name, capacity
) VALUES (
    $1, $2, $3, $4
) RETURNING id, tenant_id, class_id, name, capacity, created_at
`

type CreateSectionParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ClassID  pgtype.UUID `json:"class_id"`
	Name     string      `json:"name"`
	Capacity pgtype.Int4 `json:"capacity"`
}

func (q *Queries) CreateSection(ctx context.Context, arg CreateSectionParams) (Section, error) {
	row := q.db.QueryRow(ctx, createSection,
		arg.TenantID,
		arg.ClassID,
		arg.Name,
		arg.Capacity,
	)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ClassID,
		&i.Name,
		&i.Capacity,
		&i.CreatedAt,
	)
	return i, err
}

const createStudent = `-- name: CreateStudent :one

INSERT INTO students (
    tenant_id, admission_number, full_name, date_of_birth, gender, section_id, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, branch_id, admission_number, roll_number, full_name, date_of_birth, gender, address, section_id, status, created_at, updated_at
`

type CreateStudentParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	AdmissionNumber string      `json:"admission_number"`
	FullName        string      `json:"full_name"`
	DateOfBirth     pgtype.Date `json:"date_of_birth"`
	Gender          pgtype.Text `json:"gender"`
	SectionID       pgtype.UUID `json:"section_id"`
	Status          pgtype.Text `json:"status"`
}


func (q *Queries) CreateStudent(ctx context.Context, arg CreateStudentParams) (Student, error) {
	row := q.db.QueryRow(ctx, createStudent,
		arg.TenantID,
		arg.AdmissionNumber,
		arg.FullName,
		arg.DateOfBirth,
		arg.Gender,
		arg.SectionID,
		arg.Status,
	)
	var i Student
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.AdmissionNumber,
		&i.RollNumber,
		&i.FullName,
		&i.DateOfBirth,
		&i.Gender,
		&i.Address,
		&i.SectionID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubject = `-- name: CreateSubject :one
INSERT INTO subjects (
    tenant_id, name, code, type
) VALUES (
    $1, $2, $3, $4
) RETURNING id, tenant_id, name, code, type, created_at
`

type CreateSubjectParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Name     string      `json:"name"`
	Code     pgtype.Text `json:"code"`
	Type     pgtype.Text `json:"type"`
}

func (q *Queries) CreateSubject(ctx context.Context, arg CreateSubjectParams) (Subject, error) {
	row := q.db.QueryRow(ctx, createSubject,
		arg.TenantID,
		arg.Name,
		arg.Code,
		arg.Type,
	)
	var i Subject
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const deleteStudent = `-- name: DeleteStudent :exec
DELETE FROM students
WHERE id = $1 AND tenant_id = $2
`

type DeleteStudentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteStudent(ctx context.Context, arg DeleteStudentParams) error {
	_, err := q.db.Exec(ctx, deleteStudent, arg.ID, arg.TenantID)
	return err
}

const getChildrenByParentUser = `-- name: GetChildrenByParentUser :many
SELECT s.id, s.tenant_id, s.branch_id, s.admission_number, s.roll_number, s.full_name, s.date_of_birth, s.gender, s.address, s.section_id, s.status, s.created_at, s.updated_at, sec.name as section_name, c.name as class_name
FROM students s
JOIN student_guardians sg ON s.id = sg.student_id
JOIN guardians g ON sg.guardian_id = g.id
LEFT JOIN sections sec ON s.section_id = sec.id
LEFT JOIN classes c ON sec.class_id = c.id
WHERE g.user_id = $1 AND s.tenant_id = $2
`

type GetChildrenByParentUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetChildrenByParentUserRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	BranchID        pgtype.UUID        `json:"branch_id"`
	AdmissionNumber string             `json:"admission_number"`
	RollNumber      pgtype.Text        `json:"roll_number"`
	FullName        string             `json:"full_name"`
	DateOfBirth     pgtype.Date        `json:"date_of_birth"`
	Gender          pgtype.Text        `json:"gender"`
	Address         pgtype.Text        `json:"address"`
	SectionID       pgtype.UUID        `json:"section_id"`
	Status          pgtype.Text        `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	SectionName     pgtype.Text        `json:"section_name"`
	ClassName       pgtype.Text        `json:"class_name"`
}

func (q *Queries) GetChildrenByParentUser(ctx context.Context, arg GetChildrenByParentUserParams) ([]GetChildrenByParentUserRow, error) {
	rows, err := q.db.Query(ctx, getChildrenByParentUser, arg.UserID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChildrenByParentUserRow
	for rows.Next() {
		var i GetChildrenByParentUserRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.BranchID,
			&i.AdmissionNumber,
			&i.RollNumber,
			&i.FullName,
			&i.DateOfBirth,
			&i.Gender,
			&i.Address,
			&i.SectionID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SectionName,
			&i.ClassName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudent = `-- name: GetStudent :one
SELECT s.id, s.tenant_id, s.branch_id, s.admission_number, s.roll_number, s.full_name, s.date_of_birth, s.gender, s.address, s.section_id, s.status, s.created_at, s.updated_at, sec.name as section_name, c.name as class_name
FROM students s
LEFT JOIN sections sec ON s.section_id = sec.id
LEFT JOIN classes c ON sec.class_id = c.id
WHERE s.id = $1 AND s.tenant_id = $2
`

type GetStudentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetStudentRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	BranchID        pgtype.UUID        `json:"branch_id"`
	AdmissionNumber string             `json:"admission_number"`
	RollNumber      pgtype.Text        `json:"roll_number"`
	FullName        string             `json:"full_name"`
	DateOfBirth     pgtype.Date        `json:"date_of_birth"`
	Gender          pgtype.Text        `json:"gender"`
	Address         pgtype.Text        `json:"address"`
	SectionID       pgtype.UUID        `json:"section_id"`
	Status          pgtype.Text        `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	SectionName     pgtype.Text        `json:"section_name"`
	ClassName       pgtype.Text        `json:"class_name"`
}

func (q *Queries) GetStudent(ctx context.Context, arg GetStudentParams) (GetStudentRow, error) {
	row := q.db.QueryRow(ctx, getStudent, arg.ID, arg.TenantID)
	var i GetStudentRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.AdmissionNumber,
		&i.RollNumber,
		&i.FullName,
		&i.DateOfBirth,
		&i.Gender,
		&i.Address,
		&i.SectionID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SectionName,
		&i.ClassName,
	)
	return i, err
}

const getStudentGuardians = `-- name: GetStudentGuardians :many
SELECT g.id, g.tenant_id, g.full_name, g.phone, g.email, g.address, g.created_at, g.user_id, sg.relationship, sg.is_primary
FROM guardians g
JOIN student_guardians sg ON g.id = sg.guardian_id
WHERE sg.student_id = $1
`

type GetStudentGuardiansRow struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	FullName     string             `json:"full_name"`
	Phone        string             `json:"phone"`
	Email        pgtype.Text        `json:"email"`
	Address      pgtype.Text        `json:"address"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UserID       pgtype.UUID        `json:"user_id"`
	Relationship string             `json:"relationship"`
	IsPrimary    pgtype.Bool        `json:"is_primary"`
}

func (q *Queries) GetStudentGuardians(ctx context.Context, studentID pgtype.UUID) ([]GetStudentGuardiansRow, error) {
	rows, err := q.db.Query(ctx, getStudentGuardians, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentGuardiansRow
	for rows.Next() {
		var i GetStudentGuardiansRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.FullName,
			&i.Phone,
			&i.Email,
			&i.Address,
			&i.CreatedAt,
			&i.UserID,
			&i.Relationship,
			&i.IsPrimary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkStudentGuardian = `-- name: LinkStudentGuardian :exec
INSERT INTO student_guardians (
    student_id, guardian_id, relationship, is_primary
) VALUES (
    $1, $2, $3, $4
)
`

type LinkStudentGuardianParams struct {
	StudentID    pgtype.UUID `json:"student_id"`
	GuardianID   pgtype.UUID `json:"guardian_id"`
	Relationship string      `json:"relationship"`
	IsPrimary    pgtype.Bool `json:"is_primary"`
}

func (q *Queries) LinkStudentGuardian(ctx context.Context, arg LinkStudentGuardianParams) error {
	_, err := q.db.Exec(ctx, linkStudentGuardian,
		arg.StudentID,
		arg.GuardianID,
		arg.Relationship,
		arg.IsPrimary,
	)
	return err
}

const listAcademicYears = `-- name: ListAcademicYears :many
SELECT id, tenant_id, name, start_date, end_date, is_active, created_at FROM academic_years
WHERE tenant_id = $1
ORDER BY start_date DESC
`

func (q *Queries) ListAcademicYears(ctx context.Context, tenantID pgtype.UUID) ([]AcademicYear, error) {
	rows, err := q.db.Query(ctx, listAcademicYears, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AcademicYear
	for rows.Next() {
		var i AcademicYear
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClasses = `-- name: ListClasses :many
SELECT id, tenant_id, name, level, stream, created_at FROM classes
WHERE tenant_id = $1
ORDER BY level
`

func (q *Queries) ListClasses(ctx context.Context, tenantID pgtype.UUID) ([]Class, error) {
	rows, err := q.db.Query(ctx, listClasses, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Class
	for rows.Next() {
		var i Class
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Level,
			&i.Stream,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSectionsByClass = `-- name: ListSectionsByClass :many
SELECT id, tenant_id, class_id, name, capacity, created_at FROM sections
WHERE class_id = $1
ORDER BY name
`

func (q *Queries) ListSectionsByClass(ctx context.Context, classID pgtype.UUID) ([]Section, error) {
	rows, err := q.db.Query(ctx, listSectionsByClass, classID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Section
	for rows.Next() {
		var i Section
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClassID,
			&i.Name,
			&i.Capacity,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSectionsByTenant = `-- name: ListSectionsByTenant :many
SELECT id, tenant_id, class_id, name, capacity, created_at FROM sections
WHERE tenant_id = $1
ORDER BY class_id, name
`

func (q *Queries) ListSectionsByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Section, error) {
	rows, err := q.db.Query(ctx, listSectionsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Section
	for rows.Next() {
		var i Section
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClassID,
			&i.Name,
			&i.Capacity,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudents = `-- name: ListStudents :many
SELECT s.id, s.full_name, s.admission_number, s.status, s.section_id, sec.name as section_name, c.name as class_name
FROM students s
LEFT JOIN sections sec ON s.section_id = sec.id
LEFT JOIN classes c ON sec.class_id = c.id
WHERE s.tenant_id = $1 
LIMIT $2 OFFSET $3
`

type ListStudentsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListStudentsRow struct {
	ID              pgtype.UUID `json:"id"`
	FullName        string      `json:"full_name"`
	AdmissionNumber string      `json:"admission_number"`
	Status          pgtype.Text `json:"status"`
	SectionID       pgtype.UUID `json:"section_id"`
	SectionName     pgtype.Text `json:"section_name"`
	ClassName       pgtype.Text `json:"class_name"`
}

func (q *Queries) ListStudents(ctx context.Context, arg ListStudentsParams) ([]ListStudentsRow, error) {
	rows, err := q.db.Query(ctx, listStudents, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStudentsRow
	for rows.Next() {
		var i ListStudentsRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.AdmissionNumber,
			&i.Status,
			&i.SectionID,
			&i.SectionName,
			&i.ClassName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjects = `-- name: ListSubjects :many
SELECT id, tenant_id, name, code, type, created_at FROM subjects
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListSubjects(ctx context.Context, tenantID pgtype.UUID) ([]Subject, error) {
	rows, err := q.db.Query(ctx, listSubjects, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subject
	for rows.Next() {
		var i Subject
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Code,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStudent = `-- name: UpdateStudent :one
UPDATE students
SET 
    full_name = $3,
    date_of_birth = $4,
    gender = $5,
    section_id = $6,
    status = $7,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, branch_id, admission_number, roll_number, full_name, date_of_birth, gender, address, section_id, status, created_at, updated_at
`

type UpdateStudentParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	FullName    string      `json:"full_name"`
	DateOfBirth pgtype.Date `json:"date_of_birth"`
	Gender      pgtype.Text `json:"gender"`
	SectionID   pgtype.UUID `json:"section_id"`
	Status      pgtype.Text `json:"status"`
}

func (q *Queries) UpdateStudent(ctx context.Context, arg UpdateStudentParams) (Student, error) {
	row := q.db.QueryRow(ctx, updateStudent,
		arg.ID,
		arg.TenantID,
		arg.FullName,
		arg.DateOfBirth,
		arg.Gender,
		arg.SectionID,
		arg.Status,
	)
	var i Student
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.AdmissionNumber,
		&i.RollNumber,
		&i.FullName,
		&i.DateOfBirth,
		&i.Gender,
		&i.Address,
		&i.SectionID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
