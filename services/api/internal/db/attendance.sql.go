// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attendance.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchUpsertAttendanceEntriesParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	StudentID pgtype.UUID `json:"student_id"`
	Status    string      `json:"status"`
	Remarks   pgtype.Text `json:"remarks"`
}

const createAttendanceSession = `-- name: CreateAttendanceSession :one
INSERT INTO attendance_sessions (tenant_id, class_section_id, date, marked_by)
VALUES ($1, $2, $3, $4)
ON CONFLICT (class_section_id, date) DO UPDATE 
SET updated_at = NOW() 
RETURNING id, tenant_id, class_section_id, date, marked_by, created_at, updated_at
`

type CreateAttendanceSessionParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ClassSectionID pgtype.UUID `json:"class_section_id"`
	Date           pgtype.Date `json:"date"`
	MarkedBy       pgtype.UUID `json:"marked_by"`
}

func (q *Queries) CreateAttendanceSession(ctx context.Context, arg CreateAttendanceSessionParams) (AttendanceSession, error) {
	row := q.db.QueryRow(ctx, createAttendanceSession,
		arg.TenantID,
		arg.ClassSectionID,
		arg.Date,
		arg.MarkedBy,
	)
	var i AttendanceSession
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ClassSectionID,
		&i.Date,
		&i.MarkedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeaveRequest = `-- name: CreateLeaveRequest :one
INSERT INTO leave_requests (tenant_id, student_id, from_date, to_date, reason)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, student_id, from_date, to_date, reason, status, decided_by, decided_at, created_at
`

type CreateLeaveRequestParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	StudentID pgtype.UUID `json:"student_id"`
	FromDate  pgtype.Date `json:"from_date"`
	ToDate    pgtype.Date `json:"to_date"`
	Reason    pgtype.Text `json:"reason"`
}

func (q *Queries) CreateLeaveRequest(ctx context.Context, arg CreateLeaveRequestParams) (LeaveRequest, error) {
	row := q.db.QueryRow(ctx, createLeaveRequest,
		arg.TenantID,
		arg.StudentID,
		arg.FromDate,
		arg.ToDate,
		arg.Reason,
	)
	var i LeaveRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.FromDate,
		&i.ToDate,
		&i.Reason,
		&i.Status,
		&i.DecidedBy,
		&i.DecidedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAttendanceEntries = `-- name: DeleteAttendanceEntries :exec
DELETE FROM attendance_entries
WHERE session_id = $1
`

func (q *Queries) DeleteAttendanceEntries(ctx context.Context, sessionID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttendanceEntries, sessionID)
	return err
}

const getAttendanceEntries = `-- name: GetAttendanceEntries :many
SELECT e.session_id, e.student_id, e.status, e.remarks, e.updated_at, s.full_name, s.admission_number
FROM attendance_entries e
JOIN students s ON e.student_id = s.id
WHERE e.session_id = $1
`

type GetAttendanceEntriesRow struct {
	SessionID       pgtype.UUID        `json:"session_id"`
	StudentID       pgtype.UUID        `json:"student_id"`
	Status          string             `json:"status"`
	Remarks         pgtype.Text        `json:"remarks"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	FullName        string             `json:"full_name"`
	AdmissionNumber string             `json:"admission_number"`
}

func (q *Queries) GetAttendanceEntries(ctx context.Context, sessionID pgtype.UUID) ([]GetAttendanceEntriesRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceEntries, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAttendanceEntriesRow
	for rows.Next() {
		var i GetAttendanceEntriesRow
		if err := rows.Scan(
			&i.SessionID,
			&i.StudentID,
			&i.Status,
			&i.Remarks,
			&i.UpdatedAt,
			&i.FullName,
			&i.AdmissionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceSession = `-- name: GetAttendanceSession :one
SELECT id, tenant_id, class_section_id, date, marked_by, created_at, updated_at FROM attendance_sessions
WHERE tenant_id = $1 AND class_section_id = $2 AND date = $3
`

type GetAttendanceSessionParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ClassSectionID pgtype.UUID `json:"class_section_id"`
	Date           pgtype.Date `json:"date"`
}

func (q *Queries) GetAttendanceSession(ctx context.Context, arg GetAttendanceSessionParams) (AttendanceSession, error) {
	row := q.db.QueryRow(ctx, getAttendanceSession, arg.TenantID, arg.ClassSectionID, arg.Date)
	var i AttendanceSession
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ClassSectionID,
		&i.Date,
		&i.MarkedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDailyAttendanceStats = `-- name: GetDailyAttendanceStats :one
SELECT 
    (SELECT COUNT(*) FROM students st WHERE st.tenant_id = $1 AND st.status = 'active') as total_students,
    COUNT(CASE WHEN ae.status = 'present' THEN 1 END) as present_count,
    COUNT(CASE WHEN ae.status = 'absent' THEN 1 END) as absent_count,
    COUNT(CASE WHEN ae.status = 'late' THEN 1 END) as late_count,
    COUNT(CASE WHEN ae.status = 'excused' THEN 1 END) as excused_count
FROM attendance_entries ae
JOIN attendance_sessions s ON ae.session_id = s.id
WHERE s.tenant_id = $1 AND s.date = $2
`

type GetDailyAttendanceStatsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Date     pgtype.Date `json:"date"`
}

type GetDailyAttendanceStatsRow struct {
	TotalStudents int64 `json:"total_students"`
	PresentCount  int64 `json:"present_count"`
	AbsentCount   int64 `json:"absent_count"`
	LateCount     int64 `json:"late_count"`
	ExcusedCount  int64 `json:"excused_count"`
}

func (q *Queries) GetDailyAttendanceStats(ctx context.Context, arg GetDailyAttendanceStatsParams) (GetDailyAttendanceStatsRow, error) {
	row := q.db.QueryRow(ctx, getDailyAttendanceStats, arg.TenantID, arg.Date)
	var i GetDailyAttendanceStatsRow
	err := row.Scan(
		&i.TotalStudents,
		&i.PresentCount,
		&i.AbsentCount,
		&i.LateCount,
		&i.ExcusedCount,
	)
	return i, err
}

const listLeaveRequests = `-- name: ListLeaveRequests :many
SELECT lr.id, lr.tenant_id, lr.student_id, lr.from_date, lr.to_date, lr.reason, lr.status, lr.decided_by, lr.decided_at, lr.created_at, s.full_name, s.admission_number
FROM leave_requests lr
JOIN students s ON lr.student_id = s.id
WHERE lr.tenant_id = $1 AND (lr.status = $2 OR $2 = '')
`

type ListLeaveRequestsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   pgtype.Text `json:"status"`
}

type ListLeaveRequestsRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	StudentID       pgtype.UUID        `json:"student_id"`
	FromDate        pgtype.Date        `json:"from_date"`
	ToDate          pgtype.Date        `json:"to_date"`
	Reason          pgtype.Text        `json:"reason"`
	Status          pgtype.Text        `json:"status"`
	DecidedBy       pgtype.UUID        `json:"decided_by"`
	DecidedAt       pgtype.Timestamptz `json:"decided_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FullName        string             `json:"full_name"`
	AdmissionNumber string             `json:"admission_number"`
}

func (q *Queries) ListLeaveRequests(ctx context.Context, arg ListLeaveRequestsParams) ([]ListLeaveRequestsRow, error) {
	rows, err := q.db.Query(ctx, listLeaveRequests, arg.TenantID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLeaveRequestsRow
	for rows.Next() {
		var i ListLeaveRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.FromDate,
			&i.ToDate,
			&i.Reason,
			&i.Status,
			&i.DecidedBy,
			&i.DecidedAt,
			&i.CreatedAt,
			&i.FullName,
			&i.AdmissionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeaves = `-- name: ListLeaves :many
SELECT id, tenant_id, student_id, from_date, to_date, reason, status, decided_by, decided_at, created_at FROM leave_requests
WHERE tenant_id = $1 AND ($2::text = '' OR status = $2)
ORDER BY created_at DESC
`

type ListLeavesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

func (q *Queries) ListLeaves(ctx context.Context, arg ListLeavesParams) ([]LeaveRequest, error) {
	rows, err := q.db.Query(ctx, listLeaves, arg.TenantID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeaveRequest
	for rows.Next() {
		var i LeaveRequest
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.FromDate,
			&i.ToDate,
			&i.Reason,
			&i.Status,
			&i.DecidedBy,
			&i.DecidedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLeaveStatus = `-- name: UpdateLeaveStatus :one
UPDATE leave_requests
SET status = $2, decided_by = $3, decided_at = NOW()
WHERE id = $1 AND tenant_id = $4
RETURNING id, tenant_id, student_id, from_date, to_date, reason, status, decided_by, decided_at, created_at
`

type UpdateLeaveStatusParams struct {
	ID        pgtype.UUID `json:"id"`
	Status    pgtype.Text `json:"status"`
	DecidedBy pgtype.UUID `json:"decided_by"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) UpdateLeaveStatus(ctx context.Context, arg UpdateLeaveStatusParams) (LeaveRequest, error) {
	row := q.db.QueryRow(ctx, updateLeaveStatus,
		arg.ID,
		arg.Status,
		arg.DecidedBy,
		arg.TenantID,
	)
	var i LeaveRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.FromDate,
		&i.ToDate,
		&i.Reason,
		&i.Status,
		&i.DecidedBy,
		&i.DecidedAt,
		&i.CreatedAt,
	)
	return i, err
}
