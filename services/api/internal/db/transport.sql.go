// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transport.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRouteAllocations = `-- name: CountRouteAllocations :one
SELECT COUNT(*) FROM transport_allocations
WHERE route_id = $1 AND tenant_id = $2 AND status = 'active'
`

type CountRouteAllocationsParams struct {
	RouteID  pgtype.UUID `json:"route_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CountRouteAllocations(ctx context.Context, arg CountRouteAllocationsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRouteAllocations, arg.RouteID, arg.TenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAllocation = `-- name: CreateAllocation :one
INSERT INTO transport_allocations (tenant_id, student_id, route_id, stop_id, start_date, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, student_id, route_id, stop_id, start_date, end_date, status, created_at, updated_at
`

type CreateAllocationParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	StudentID pgtype.UUID `json:"student_id"`
	RouteID   pgtype.UUID `json:"route_id"`
	StopID    pgtype.UUID `json:"stop_id"`
	StartDate pgtype.Date `json:"start_date"`
	Status    string      `json:"status"`
}

func (q *Queries) CreateAllocation(ctx context.Context, arg CreateAllocationParams) (TransportAllocation, error) {
	row := q.db.QueryRow(ctx, createAllocation,
		arg.TenantID,
		arg.StudentID,
		arg.RouteID,
		arg.StopID,
		arg.StartDate,
		arg.Status,
	)
	var i TransportAllocation
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.RouteID,
		&i.StopID,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDriver = `-- name: CreateDriver :one
INSERT INTO transport_drivers (tenant_id, full_name, license_number, phone, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, user_id, full_name, license_number, phone, status, is_active, created_at, updated_at
`

type CreateDriverParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	FullName      string      `json:"full_name"`
	LicenseNumber pgtype.Text `json:"license_number"`
	Phone         pgtype.Text `json:"phone"`
	Status        string      `json:"status"`
}

func (q *Queries) CreateDriver(ctx context.Context, arg CreateDriverParams) (TransportDriver, error) {
	row := q.db.QueryRow(ctx, createDriver,
		arg.TenantID,
		arg.FullName,
		arg.LicenseNumber,
		arg.Phone,
		arg.Status,
	)
	var i TransportDriver
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.FullName,
		&i.LicenseNumber,
		&i.Phone,
		&i.Status,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRoute = `-- name: CreateRoute :one
INSERT INTO transport_routes (tenant_id, name, vehicle_id, driver_id, description)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, name, vehicle_id, driver_id, description, is_active, created_at, updated_at
`

type CreateRouteParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	VehicleID   pgtype.UUID `json:"vehicle_id"`
	DriverID    pgtype.UUID `json:"driver_id"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) (TransportRoute, error) {
	row := q.db.QueryRow(ctx, createRoute,
		arg.TenantID,
		arg.Name,
		arg.VehicleID,
		arg.DriverID,
		arg.Description,
	)
	var i TransportRoute
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.VehicleID,
		&i.DriverID,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRouteStop = `-- name: CreateRouteStop :one
INSERT INTO transport_route_stops (route_id, name, sequence_order, arrival_time, pickup_cost, drop_cost)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, route_id, name, sequence_order, arrival_time, pickup_cost, drop_cost, latitude, longitude, created_at, updated_at
`

type CreateRouteStopParams struct {
	RouteID       pgtype.UUID `json:"route_id"`
	Name          string      `json:"name"`
	SequenceOrder int32       `json:"sequence_order"`
	ArrivalTime   pgtype.Time `json:"arrival_time"`
	PickupCost    pgtype.Int8 `json:"pickup_cost"`
	DropCost      pgtype.Int8 `json:"drop_cost"`
}

func (q *Queries) CreateRouteStop(ctx context.Context, arg CreateRouteStopParams) (TransportRouteStop, error) {
	row := q.db.QueryRow(ctx, createRouteStop,
		arg.RouteID,
		arg.Name,
		arg.SequenceOrder,
		arg.ArrivalTime,
		arg.PickupCost,
		arg.DropCost,
	)
	var i TransportRouteStop
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.Name,
		&i.SequenceOrder,
		&i.ArrivalTime,
		&i.PickupCost,
		&i.DropCost,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO transport_vehicles (tenant_id, registration_number, capacity, type, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, registration_number, capacity, type, status, is_active, created_at, updated_at
`

type CreateVehicleParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	RegistrationNumber string      `json:"registration_number"`
	Capacity           int32       `json:"capacity"`
	Type               string      `json:"type"`
	Status             string      `json:"status"`
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (TransportVehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.TenantID,
		arg.RegistrationNumber,
		arg.Capacity,
		arg.Type,
		arg.Status,
	)
	var i TransportVehicle
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RegistrationNumber,
		&i.Capacity,
		&i.Type,
		&i.Status,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVehicle = `-- name: DeleteVehicle :exec
DELETE FROM transport_vehicles
WHERE id = $1 AND tenant_id = $2
`

type DeleteVehicleParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteVehicle(ctx context.Context, arg DeleteVehicleParams) error {
	_, err := q.db.Exec(ctx, deleteVehicle, arg.ID, arg.TenantID)
	return err
}

const getRoute = `-- name: GetRoute :one
SELECT id, tenant_id, name, vehicle_id, driver_id, description, is_active, created_at, updated_at FROM transport_routes
WHERE id = $1 AND tenant_id = $2
`

type GetRouteParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetRoute(ctx context.Context, arg GetRouteParams) (TransportRoute, error) {
	row := q.db.QueryRow(ctx, getRoute, arg.ID, arg.TenantID)
	var i TransportRoute
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.VehicleID,
		&i.DriverID,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRouteStop = `-- name: GetRouteStop :one
SELECT id, route_id, name, sequence_order, arrival_time, pickup_cost, drop_cost, latitude, longitude, created_at, updated_at FROM transport_route_stops
WHERE id = $1
`

func (q *Queries) GetRouteStop(ctx context.Context, id pgtype.UUID) (TransportRouteStop, error) {
	row := q.db.QueryRow(ctx, getRouteStop, id)
	var i TransportRouteStop
	err := row.Scan(
		&i.ID,
		&i.RouteID,
		&i.Name,
		&i.SequenceOrder,
		&i.ArrivalTime,
		&i.PickupCost,
		&i.DropCost,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVehicle = `-- name: GetVehicle :one
SELECT id, tenant_id, registration_number, capacity, type, status, is_active, created_at, updated_at FROM transport_vehicles
WHERE id = $1 AND tenant_id = $2
`

type GetVehicleParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetVehicle(ctx context.Context, arg GetVehicleParams) (TransportVehicle, error) {
	row := q.db.QueryRow(ctx, getVehicle, arg.ID, arg.TenantID)
	var i TransportVehicle
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RegistrationNumber,
		&i.Capacity,
		&i.Type,
		&i.Status,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllocations = `-- name: ListAllocations :many
SELECT ta.id, ta.tenant_id, ta.student_id, ta.route_id, ta.stop_id, ta.start_date, ta.end_date, ta.status, ta.created_at, ta.updated_at, s.full_name as student_name, tr.name as route_name, trs.name as stop_name
FROM transport_allocations ta
JOIN students s ON ta.student_id = s.id
JOIN transport_routes tr ON ta.route_id = tr.id
LEFT JOIN transport_route_stops trs ON ta.stop_id = trs.id
WHERE ta.tenant_id = $1
`

type ListAllocationsRow struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	StudentID   pgtype.UUID        `json:"student_id"`
	RouteID     pgtype.UUID        `json:"route_id"`
	StopID      pgtype.UUID        `json:"stop_id"`
	StartDate   pgtype.Date        `json:"start_date"`
	EndDate     pgtype.Date        `json:"end_date"`
	Status      string             `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	StudentName string             `json:"student_name"`
	RouteName   string             `json:"route_name"`
	StopName    pgtype.Text        `json:"stop_name"`
}

func (q *Queries) ListAllocations(ctx context.Context, tenantID pgtype.UUID) ([]ListAllocationsRow, error) {
	rows, err := q.db.Query(ctx, listAllocations, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllocationsRow
	for rows.Next() {
		var i ListAllocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.RouteID,
			&i.StopID,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentName,
			&i.RouteName,
			&i.StopName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDrivers = `-- name: ListDrivers :many
SELECT id, tenant_id, user_id, full_name, license_number, phone, status, is_active, created_at, updated_at FROM transport_drivers
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListDrivers(ctx context.Context, tenantID pgtype.UUID) ([]TransportDriver, error) {
	rows, err := q.db.Query(ctx, listDrivers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransportDriver
	for rows.Next() {
		var i TransportDriver
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.FullName,
			&i.LicenseNumber,
			&i.Phone,
			&i.Status,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRouteStops = `-- name: ListRouteStops :many
SELECT id, route_id, name, sequence_order, arrival_time, pickup_cost, drop_cost, latitude, longitude, created_at, updated_at FROM transport_route_stops
WHERE route_id = $1
ORDER BY sequence_order ASC
`

func (q *Queries) ListRouteStops(ctx context.Context, routeID pgtype.UUID) ([]TransportRouteStop, error) {
	rows, err := q.db.Query(ctx, listRouteStops, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransportRouteStop
	for rows.Next() {
		var i TransportRouteStop
		if err := rows.Scan(
			&i.ID,
			&i.RouteID,
			&i.Name,
			&i.SequenceOrder,
			&i.ArrivalTime,
			&i.PickupCost,
			&i.DropCost,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutes = `-- name: ListRoutes :many
SELECT tr.id, tr.tenant_id, tr.name, tr.vehicle_id, tr.driver_id, tr.description, tr.is_active, tr.created_at, tr.updated_at, tv.registration_number as vehicle_number, td.full_name as driver_name
FROM transport_routes tr
LEFT JOIN transport_vehicles tv ON tr.vehicle_id = tv.id
LEFT JOIN transport_drivers td ON tr.driver_id = td.id
WHERE tr.tenant_id = $1
`

type ListRoutesRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	Name          string             `json:"name"`
	VehicleID     pgtype.UUID        `json:"vehicle_id"`
	DriverID      pgtype.UUID        `json:"driver_id"`
	Description   pgtype.Text        `json:"description"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	VehicleNumber pgtype.Text        `json:"vehicle_number"`
	DriverName    pgtype.Text        `json:"driver_name"`
}

func (q *Queries) ListRoutes(ctx context.Context, tenantID pgtype.UUID) ([]ListRoutesRow, error) {
	rows, err := q.db.Query(ctx, listRoutes, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRoutesRow
	for rows.Next() {
		var i ListRoutesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.VehicleID,
			&i.DriverID,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.VehicleNumber,
			&i.DriverName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVehicles = `-- name: ListVehicles :many
SELECT id, tenant_id, registration_number, capacity, type, status, is_active, created_at, updated_at FROM transport_vehicles
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListVehicles(ctx context.Context, tenantID pgtype.UUID) ([]TransportVehicle, error) {
	rows, err := q.db.Query(ctx, listVehicles, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransportVehicle
	for rows.Next() {
		var i TransportVehicle
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RegistrationNumber,
			&i.Capacity,
			&i.Type,
			&i.Status,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVehicle = `-- name: UpdateVehicle :one
UPDATE transport_vehicles
SET registration_number = $3, capacity = $4, type = $5, status = $6, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, registration_number, capacity, type, status, is_active, created_at, updated_at
`

type UpdateVehicleParams struct {
	ID                 pgtype.UUID `json:"id"`
	TenantID           pgtype.UUID `json:"tenant_id"`
	RegistrationNumber string      `json:"registration_number"`
	Capacity           int32       `json:"capacity"`
	Type               string      `json:"type"`
	Status             string      `json:"status"`
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) (TransportVehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicle,
		arg.ID,
		arg.TenantID,
		arg.RegistrationNumber,
		arg.Capacity,
		arg.Type,
		arg.Status,
	)
	var i TransportVehicle
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RegistrationNumber,
		&i.Capacity,
		&i.Type,
		&i.Status,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
