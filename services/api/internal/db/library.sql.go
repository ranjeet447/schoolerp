// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: library.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuthor = `-- name: CreateAuthor :one
INSERT INTO library_authors (
    tenant_id, name, bio
) VALUES (
    $1, $2, $3
) RETURNING id, tenant_id, name, bio, created_at, updated_at
`

type CreateAuthorParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Name     string      `json:"name"`
	Bio      pgtype.Text `json:"bio"`
}

func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (LibraryAuthor, error) {
	row := q.db.QueryRow(ctx, createAuthor, arg.TenantID, arg.Name, arg.Bio)
	var i LibraryAuthor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO library_books (
    tenant_id, title, isbn, publisher, published_year, category_id, 
    total_copies, available_copies, shelf_location, cover_image_url, 
    price, language, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, tenant_id, title, isbn, publisher, published_year, category_id, total_copies, available_copies, shelf_location, cover_image_url, price, language, status, created_at, updated_at
`

type CreateBookParams struct {
	TenantID        pgtype.UUID    `json:"tenant_id"`
	Title           string         `json:"title"`
	Isbn            pgtype.Text    `json:"isbn"`
	Publisher       pgtype.Text    `json:"publisher"`
	PublishedYear   pgtype.Int4    `json:"published_year"`
	CategoryID      pgtype.UUID    `json:"category_id"`
	TotalCopies     int32          `json:"total_copies"`
	AvailableCopies int32          `json:"available_copies"`
	ShelfLocation   pgtype.Text    `json:"shelf_location"`
	CoverImageUrl   pgtype.Text    `json:"cover_image_url"`
	Price           pgtype.Numeric `json:"price"`
	Language        pgtype.Text    `json:"language"`
	Status          string         `json:"status"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (LibraryBook, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.TenantID,
		arg.Title,
		arg.Isbn,
		arg.Publisher,
		arg.PublishedYear,
		arg.CategoryID,
		arg.TotalCopies,
		arg.AvailableCopies,
		arg.ShelfLocation,
		arg.CoverImageUrl,
		arg.Price,
		arg.Language,
		arg.Status,
	)
	var i LibraryBook
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Isbn,
		&i.Publisher,
		&i.PublishedYear,
		&i.CategoryID,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ShelfLocation,
		&i.CoverImageUrl,
		&i.Price,
		&i.Language,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createBookAuthor = `-- name: CreateBookAuthor :exec
INSERT INTO library_book_authors (book_id, author_id) VALUES ($1, $2)
`

type CreateBookAuthorParams struct {
	BookID   pgtype.UUID `json:"book_id"`
	AuthorID pgtype.UUID `json:"author_id"`
}

func (q *Queries) CreateBookAuthor(ctx context.Context, arg CreateBookAuthorParams) error {
	_, err := q.db.Exec(ctx, createBookAuthor, arg.BookID, arg.AuthorID)
	return err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO library_categories (
    tenant_id, name, parent_id, description
) VALUES (
    $1, $2, $3, $4
) RETURNING id, tenant_id, name, parent_id, description, created_at, updated_at
`

type CreateCategoryParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	ParentID    pgtype.UUID `json:"parent_id"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (LibraryCategory, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.TenantID,
		arg.Name,
		arg.ParentID,
		arg.Description,
	)
	var i LibraryCategory
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.ParentID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBook = `-- name: GetBook :one
SELECT id, tenant_id, title, isbn, publisher, published_year, category_id, total_copies, available_copies, shelf_location, cover_image_url, price, language, status, created_at, updated_at FROM library_books WHERE id = $1 AND tenant_id = $2
`

type GetBookParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetBook(ctx context.Context, arg GetBookParams) (LibraryBook, error) {
	row := q.db.QueryRow(ctx, getBook, arg.ID, arg.TenantID)
	var i LibraryBook
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Isbn,
		&i.Publisher,
		&i.PublishedYear,
		&i.CategoryID,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ShelfLocation,
		&i.CoverImageUrl,
		&i.Price,
		&i.Language,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIssue = `-- name: GetIssue :one
SELECT id, tenant_id, book_id, student_id, user_id, issue_date, due_date, return_date, fine_amount, status, remarks, created_at, updated_at FROM library_issues WHERE id = $1 AND tenant_id = $2
`

type GetIssueParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetIssue(ctx context.Context, arg GetIssueParams) (LibraryIssue, error) {
	row := q.db.QueryRow(ctx, getIssue, arg.ID, arg.TenantID)
	var i LibraryIssue
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BookID,
		&i.StudentID,
		&i.UserID,
		&i.IssueDate,
		&i.DueDate,
		&i.ReturnDate,
		&i.FineAmount,
		&i.Status,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const issueBook = `-- name: IssueBook :one
INSERT INTO library_issues (
    tenant_id, book_id, student_id, user_id, issue_date, due_date, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, book_id, student_id, user_id, issue_date, due_date, return_date, fine_amount, status, remarks, created_at, updated_at
`

type IssueBookParams struct {
	TenantID  pgtype.UUID        `json:"tenant_id"`
	BookID    pgtype.UUID        `json:"book_id"`
	StudentID pgtype.UUID        `json:"student_id"`
	UserID    pgtype.UUID        `json:"user_id"`
	IssueDate pgtype.Timestamptz `json:"issue_date"`
	DueDate   pgtype.Timestamptz `json:"due_date"`
	Status    string             `json:"status"`
}

func (q *Queries) IssueBook(ctx context.Context, arg IssueBookParams) (LibraryIssue, error) {
	row := q.db.QueryRow(ctx, issueBook,
		arg.TenantID,
		arg.BookID,
		arg.StudentID,
		arg.UserID,
		arg.IssueDate,
		arg.DueDate,
		arg.Status,
	)
	var i LibraryIssue
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BookID,
		&i.StudentID,
		&i.UserID,
		&i.IssueDate,
		&i.DueDate,
		&i.ReturnDate,
		&i.FineAmount,
		&i.Status,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAuthors = `-- name: ListAuthors :many
SELECT id, tenant_id, name, bio, created_at, updated_at FROM library_authors
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListAuthors(ctx context.Context, tenantID pgtype.UUID) ([]LibraryAuthor, error) {
	rows, err := q.db.Query(ctx, listAuthors, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LibraryAuthor
	for rows.Next() {
		var i LibraryAuthor
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Bio,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooks = `-- name: ListBooks :many
SELECT id, tenant_id, title, isbn, publisher, published_year, category_id, total_copies, available_copies, shelf_location, cover_image_url, price, language, status, created_at, updated_at FROM library_books
WHERE tenant_id = $1
ORDER BY title
LIMIT $2 OFFSET $3
`

type ListBooksParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListBooks(ctx context.Context, arg ListBooksParams) ([]LibraryBook, error) {
	rows, err := q.db.Query(ctx, listBooks, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LibraryBook
	for rows.Next() {
		var i LibraryBook
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Isbn,
			&i.Publisher,
			&i.PublishedYear,
			&i.CategoryID,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.ShelfLocation,
			&i.CoverImageUrl,
			&i.Price,
			&i.Language,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategories = `-- name: ListCategories :many
SELECT id, tenant_id, name, parent_id, description, created_at, updated_at FROM library_categories
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListCategories(ctx context.Context, tenantID pgtype.UUID) ([]LibraryCategory, error) {
	rows, err := q.db.Query(ctx, listCategories, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LibraryCategory
	for rows.Next() {
		var i LibraryCategory
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.ParentID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssues = `-- name: ListIssues :many
SELECT 
    i.id, i.tenant_id, i.book_id, i.student_id, i.user_id, i.issue_date, i.due_date, i.return_date, i.fine_amount, i.status, i.remarks, i.created_at, i.updated_at,
    b.title as book_title,
    s.full_name as student_name,
    s.admission_number
FROM library_issues i
JOIN library_books b ON i.book_id = b.id
LEFT JOIN students s ON i.student_id = s.id
WHERE i.tenant_id = $1
ORDER BY i.created_at DESC
LIMIT $2 OFFSET $3
`

type ListIssuesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListIssuesRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	BookID          pgtype.UUID        `json:"book_id"`
	StudentID       pgtype.UUID        `json:"student_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	IssueDate       pgtype.Timestamptz `json:"issue_date"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	ReturnDate      pgtype.Timestamptz `json:"return_date"`
	FineAmount      pgtype.Numeric     `json:"fine_amount"`
	Status          string             `json:"status"`
	Remarks         pgtype.Text        `json:"remarks"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	BookTitle       string             `json:"book_title"`
	StudentName     pgtype.Text        `json:"student_name"`
	AdmissionNumber pgtype.Text        `json:"admission_number"`
}

func (q *Queries) ListIssues(ctx context.Context, arg ListIssuesParams) ([]ListIssuesRow, error) {
	rows, err := q.db.Query(ctx, listIssues, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIssuesRow
	for rows.Next() {
		var i ListIssuesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.BookID,
			&i.StudentID,
			&i.UserID,
			&i.IssueDate,
			&i.DueDate,
			&i.ReturnDate,
			&i.FineAmount,
			&i.Status,
			&i.Remarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BookTitle,
			&i.StudentName,
			&i.AdmissionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnBook = `-- name: ReturnBook :one
UPDATE library_issues
SET return_date = $3, fine_amount = $4, status = $5, remarks = $6
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, book_id, student_id, user_id, issue_date, due_date, return_date, fine_amount, status, remarks, created_at, updated_at
`

type ReturnBookParams struct {
	ID         pgtype.UUID        `json:"id"`
	TenantID   pgtype.UUID        `json:"tenant_id"`
	ReturnDate pgtype.Timestamptz `json:"return_date"`
	FineAmount pgtype.Numeric     `json:"fine_amount"`
	Status     string             `json:"status"`
	Remarks    pgtype.Text        `json:"remarks"`
}

func (q *Queries) ReturnBook(ctx context.Context, arg ReturnBookParams) (LibraryIssue, error) {
	row := q.db.QueryRow(ctx, returnBook,
		arg.ID,
		arg.TenantID,
		arg.ReturnDate,
		arg.FineAmount,
		arg.Status,
		arg.Remarks,
	)
	var i LibraryIssue
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BookID,
		&i.StudentID,
		&i.UserID,
		&i.IssueDate,
		&i.DueDate,
		&i.ReturnDate,
		&i.FineAmount,
		&i.Status,
		&i.Remarks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBookCopies = `-- name: UpdateBookCopies :exec
UPDATE library_books 
SET available_copies = available_copies + $2
WHERE id = $1
`

type UpdateBookCopiesParams struct {
	ID              pgtype.UUID `json:"id"`
	AvailableCopies int32       `json:"available_copies"`
}

func (q *Queries) UpdateBookCopies(ctx context.Context, arg UpdateBookCopiesParams) error {
	_, err := q.db.Exec(ctx, updateBookCopies, arg.ID, arg.AvailableCopies)
	return err
}
