// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: communication.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addChatParticipant = `-- name: AddChatParticipant :exec
INSERT INTO chat_participants (
    room_id, user_id, role
) VALUES (
    $1, $2, $3
)
`

type AddChatParticipantParams struct {
	RoomID pgtype.UUID `json:"room_id"`
	UserID pgtype.UUID `json:"user_id"`
	Role   string      `json:"role"`
}

func (q *Queries) AddChatParticipant(ctx context.Context, arg AddChatParticipantParams) error {
	_, err := q.db.Exec(ctx, addChatParticipant, arg.RoomID, arg.UserID, arg.Role)
	return err
}

const bookPTMSlot = `-- name: BookPTMSlot :one
UPDATE ptm_slots
SET 
    student_id = $3,
    status = 'booked',
    booking_remarks = $4,
    booked_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND event_id = $2 AND status = 'available'
RETURNING id, event_id, start_time, end_time, student_id, status, booking_remarks, booked_at, updated_at
`

type BookPTMSlotParams struct {
	ID             pgtype.UUID `json:"id"`
	EventID        pgtype.UUID `json:"event_id"`
	StudentID      pgtype.UUID `json:"student_id"`
	BookingRemarks pgtype.Text `json:"booking_remarks"`
}

func (q *Queries) BookPTMSlot(ctx context.Context, arg BookPTMSlotParams) (PtmSlot, error) {
	row := q.db.QueryRow(ctx, bookPTMSlot,
		arg.ID,
		arg.EventID,
		arg.StudentID,
		arg.BookingRemarks,
	)
	var i PtmSlot
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.StartTime,
		&i.EndTime,
		&i.StudentID,
		&i.Status,
		&i.BookingRemarks,
		&i.BookedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (
    room_id, sender_id, message, is_moderated, moderation_reason
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, room_id, sender_id, message, is_moderated, moderation_reason, created_at
`

type CreateChatMessageParams struct {
	RoomID           pgtype.UUID `json:"room_id"`
	SenderID         pgtype.UUID `json:"sender_id"`
	Message          string      `json:"message"`
	IsModerated      pgtype.Bool `json:"is_moderated"`
	ModerationReason pgtype.Text `json:"moderation_reason"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.RoomID,
		arg.SenderID,
		arg.Message,
		arg.IsModerated,
		arg.ModerationReason,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.SenderID,
		&i.Message,
		&i.IsModerated,
		&i.ModerationReason,
		&i.CreatedAt,
	)
	return i, err
}

const createChatRoom = `-- name: CreateChatRoom :one
INSERT INTO chat_rooms (
    tenant_id, student_id, title
) VALUES (
    $1, $2, $3
) RETURNING id, tenant_id, student_id, title, is_active, created_at, updated_at
`

type CreateChatRoomParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	StudentID pgtype.UUID `json:"student_id"`
	Title     pgtype.Text `json:"title"`
}

func (q *Queries) CreateChatRoom(ctx context.Context, arg CreateChatRoomParams) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, createChatRoom, arg.TenantID, arg.StudentID, arg.Title)
	var i ChatRoom
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Title,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPTMEvent = `-- name: CreatePTMEvent :one
INSERT INTO ptm_events (
    tenant_id, title, description, event_date, start_time, end_time, slot_duration_minutes, teacher_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tenant_id, title, description, event_date, start_time, end_time, slot_duration_minutes, teacher_id, created_at, updated_at
`

type CreatePTMEventParams struct {
	TenantID            pgtype.UUID `json:"tenant_id"`
	Title               string      `json:"title"`
	Description         pgtype.Text `json:"description"`
	EventDate           pgtype.Date `json:"event_date"`
	StartTime           pgtype.Time `json:"start_time"`
	EndTime             pgtype.Time `json:"end_time"`
	SlotDurationMinutes int32       `json:"slot_duration_minutes"`
	TeacherID           pgtype.UUID `json:"teacher_id"`
}

func (q *Queries) CreatePTMEvent(ctx context.Context, arg CreatePTMEventParams) (PtmEvent, error) {
	row := q.db.QueryRow(ctx, createPTMEvent,
		arg.TenantID,
		arg.Title,
		arg.Description,
		arg.EventDate,
		arg.StartTime,
		arg.EndTime,
		arg.SlotDurationMinutes,
		arg.TeacherID,
	)
	var i PtmEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Description,
		&i.EventDate,
		&i.StartTime,
		&i.EndTime,
		&i.SlotDurationMinutes,
		&i.TeacherID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPTMSlot = `-- name: CreatePTMSlot :one
INSERT INTO ptm_slots (
    event_id, start_time, end_time, status
) VALUES (
    $1, $2, $3, $4
) RETURNING id, event_id, start_time, end_time, student_id, status, booking_remarks, booked_at, updated_at
`

type CreatePTMSlotParams struct {
	EventID   pgtype.UUID `json:"event_id"`
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
	Status    string      `json:"status"`
}

func (q *Queries) CreatePTMSlot(ctx context.Context, arg CreatePTMSlotParams) (PtmSlot, error) {
	row := q.db.QueryRow(ctx, createPTMSlot,
		arg.EventID,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
	)
	var i PtmSlot
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.StartTime,
		&i.EndTime,
		&i.StudentID,
		&i.Status,
		&i.BookingRemarks,
		&i.BookedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatHistory = `-- name: GetChatHistory :many
SELECT 
    cm.id, cm.room_id, cm.sender_id, cm.message, cm.is_moderated, cm.moderation_reason, cm.created_at,
    u.full_name as sender_name
FROM chat_messages cm
JOIN users u ON cm.sender_id = u.id
WHERE cm.room_id = $1
ORDER BY cm.created_at ASC
LIMIT $2 OFFSET $3
`

type GetChatHistoryParams struct {
	RoomID pgtype.UUID `json:"room_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetChatHistoryRow struct {
	ID               pgtype.UUID        `json:"id"`
	RoomID           pgtype.UUID        `json:"room_id"`
	SenderID         pgtype.UUID        `json:"sender_id"`
	Message          string             `json:"message"`
	IsModerated      pgtype.Bool        `json:"is_moderated"`
	ModerationReason pgtype.Text        `json:"moderation_reason"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	SenderName       string             `json:"sender_name"`
}

func (q *Queries) GetChatHistory(ctx context.Context, arg GetChatHistoryParams) ([]GetChatHistoryRow, error) {
	rows, err := q.db.Query(ctx, getChatHistory, arg.RoomID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatHistoryRow
	for rows.Next() {
		var i GetChatHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.SenderID,
			&i.Message,
			&i.IsModerated,
			&i.ModerationReason,
			&i.CreatedAt,
			&i.SenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatModerationSettings = `-- name: GetChatModerationSettings :one
SELECT tenant_id, quiet_hours_start, quiet_hours_end, blocked_keywords, is_enabled, updated_at FROM chat_moderation_settings WHERE tenant_id = $1
`

func (q *Queries) GetChatModerationSettings(ctx context.Context, tenantID pgtype.UUID) (ChatModerationSetting, error) {
	row := q.db.QueryRow(ctx, getChatModerationSettings, tenantID)
	var i ChatModerationSetting
	err := row.Scan(
		&i.TenantID,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
		&i.BlockedKeywords,
		&i.IsEnabled,
		&i.UpdatedAt,
	)
	return i, err
}

const getPTMSlots = `-- name: GetPTMSlots :many
SELECT 
    ps.id, ps.event_id, ps.start_time, ps.end_time, ps.student_id, ps.status, ps.booking_remarks, ps.booked_at, ps.updated_at,
    s.full_name as student_name
FROM ptm_slots ps
LEFT JOIN students s ON ps.student_id = s.id
WHERE ps.event_id = $1
ORDER BY ps.start_time ASC
`

type GetPTMSlotsRow struct {
	ID             pgtype.UUID        `json:"id"`
	EventID        pgtype.UUID        `json:"event_id"`
	StartTime      pgtype.Time        `json:"start_time"`
	EndTime        pgtype.Time        `json:"end_time"`
	StudentID      pgtype.UUID        `json:"student_id"`
	Status         string             `json:"status"`
	BookingRemarks pgtype.Text        `json:"booking_remarks"`
	BookedAt       pgtype.Timestamptz `json:"booked_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	StudentName    pgtype.Text        `json:"student_name"`
}

func (q *Queries) GetPTMSlots(ctx context.Context, eventID pgtype.UUID) ([]GetPTMSlotsRow, error) {
	rows, err := q.db.Query(ctx, getPTMSlots, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPTMSlotsRow
	for rows.Next() {
		var i GetPTMSlotsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.StartTime,
			&i.EndTime,
			&i.StudentID,
			&i.Status,
			&i.BookingRemarks,
			&i.BookedAt,
			&i.UpdatedAt,
			&i.StudentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPTMEvents = `-- name: ListPTMEvents :many
SELECT 
    pe.id, pe.tenant_id, pe.title, pe.description, pe.event_date, pe.start_time, pe.end_time, pe.slot_duration_minutes, pe.teacher_id, pe.created_at, pe.updated_at,
    u.full_name as teacher_name
FROM ptm_events pe
JOIN users u ON pe.teacher_id = u.id
WHERE pe.tenant_id = $1
ORDER BY pe.event_date DESC, pe.start_time DESC
`

type ListPTMEventsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	Title               string             `json:"title"`
	Description         pgtype.Text        `json:"description"`
	EventDate           pgtype.Date        `json:"event_date"`
	StartTime           pgtype.Time        `json:"start_time"`
	EndTime             pgtype.Time        `json:"end_time"`
	SlotDurationMinutes int32              `json:"slot_duration_minutes"`
	TeacherID           pgtype.UUID        `json:"teacher_id"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	TeacherName         string             `json:"teacher_name"`
}

func (q *Queries) ListPTMEvents(ctx context.Context, tenantID pgtype.UUID) ([]ListPTMEventsRow, error) {
	rows, err := q.db.Query(ctx, listPTMEvents, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPTMEventsRow
	for rows.Next() {
		var i ListPTMEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.StartTime,
			&i.EndTime,
			&i.SlotDurationMinutes,
			&i.TeacherID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TeacherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentChatRooms = `-- name: ListStudentChatRooms :many
SELECT 
    cr.id, cr.tenant_id, cr.student_id, cr.title, cr.is_active, cr.created_at, cr.updated_at,
    s.full_name as student_name
FROM chat_rooms cr
JOIN students s ON cr.student_id = s.id
JOIN chat_participants cp ON cr.id = cp.room_id
WHERE cp.user_id = $1 AND cr.tenant_id = $2
`

type ListStudentChatRoomsParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type ListStudentChatRoomsRow struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	StudentID   pgtype.UUID        `json:"student_id"`
	Title       pgtype.Text        `json:"title"`
	IsActive    pgtype.Bool        `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	StudentName string             `json:"student_name"`
}

func (q *Queries) ListStudentChatRooms(ctx context.Context, arg ListStudentChatRoomsParams) ([]ListStudentChatRoomsRow, error) {
	rows, err := q.db.Query(ctx, listStudentChatRooms, arg.UserID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStudentChatRoomsRow
	for rows.Next() {
		var i ListStudentChatRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.StudentID,
			&i.Title,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertChatModerationSettings = `-- name: UpsertChatModerationSettings :one
INSERT INTO chat_moderation_settings (
    tenant_id, quiet_hours_start, quiet_hours_end, blocked_keywords, is_enabled
) VALUES (
    $1, $2, $3, $4, $5
) ON CONFLICT (tenant_id) DO UPDATE SET
    quiet_hours_start = EXCLUDED.quiet_hours_start,
    quiet_hours_end = EXCLUDED.quiet_hours_end,
    blocked_keywords = EXCLUDED.blocked_keywords,
    is_enabled = EXCLUDED.is_enabled,
    updated_at = NOW()
RETURNING tenant_id, quiet_hours_start, quiet_hours_end, blocked_keywords, is_enabled, updated_at
`

type UpsertChatModerationSettingsParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	QuietHoursStart pgtype.Time `json:"quiet_hours_start"`
	QuietHoursEnd   pgtype.Time `json:"quiet_hours_end"`
	BlockedKeywords []string    `json:"blocked_keywords"`
	IsEnabled       pgtype.Bool `json:"is_enabled"`
}

func (q *Queries) UpsertChatModerationSettings(ctx context.Context, arg UpsertChatModerationSettingsParams) (ChatModerationSetting, error) {
	row := q.db.QueryRow(ctx, upsertChatModerationSettings,
		arg.TenantID,
		arg.QuietHoursStart,
		arg.QuietHoursEnd,
		arg.BlockedKeywords,
		arg.IsEnabled,
	)
	var i ChatModerationSetting
	err := row.Scan(
		&i.TenantID,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
		&i.BlockedKeywords,
		&i.IsEnabled,
		&i.UpdatedAt,
	)
	return i, err
}
