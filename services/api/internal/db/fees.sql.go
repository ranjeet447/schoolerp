// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: fees.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignPlanToStudent = `-- name: AssignPlanToStudent :one
INSERT INTO student_fee_plans (student_id, plan_id)
VALUES ($1, $2)
ON CONFLICT (student_id, plan_id) DO NOTHING
RETURNING student_id, plan_id, assigned_at
`

type AssignPlanToStudentParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	PlanID    pgtype.UUID `json:"plan_id"`
}

func (q *Queries) AssignPlanToStudent(ctx context.Context, arg AssignPlanToStudentParams) (StudentFeePlan, error) {
	row := q.db.QueryRow(ctx, assignPlanToStudent, arg.StudentID, arg.PlanID)
	var i StudentFeePlan
	err := row.Scan(&i.StudentID, &i.PlanID, &i.AssignedAt)
	return i, err
}

const cancelReceipt = `-- name: CancelReceipt :one
UPDATE receipts
SET status = 'cancelled', cancelled_by = $2, cancellation_reason = $3, updated_at = NOW()
WHERE id = $1 AND tenant_id = $4
RETURNING id, tenant_id, receipt_number, student_id, amount_paid, payment_mode, status, cancelled_by, cancellation_reason, transaction_ref, created_by, created_at, series_id
`

type CancelReceiptParams struct {
	ID                 pgtype.UUID `json:"id"`
	CancelledBy        pgtype.UUID `json:"cancelled_by"`
	CancellationReason pgtype.Text `json:"cancellation_reason"`
	TenantID           pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CancelReceipt(ctx context.Context, arg CancelReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, cancelReceipt,
		arg.ID,
		arg.CancelledBy,
		arg.CancellationReason,
		arg.TenantID,
	)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ReceiptNumber,
		&i.StudentID,
		&i.AmountPaid,
		&i.PaymentMode,
		&i.Status,
		&i.CancelledBy,
		&i.CancellationReason,
		&i.TransactionRef,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.SeriesID,
	)
	return i, err
}

const checkPaymentEventProcessed = `-- name: CheckPaymentEventProcessed :one
SELECT EXISTS (
    SELECT 1 FROM payment_events 
    WHERE tenant_id = $1 AND gateway_event_id = $2
) as processed
`

type CheckPaymentEventProcessedParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	GatewayEventID string      `json:"gateway_event_id"`
}

func (q *Queries) CheckPaymentEventProcessed(ctx context.Context, arg CheckPaymentEventProcessedParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPaymentEventProcessed, arg.TenantID, arg.GatewayEventID)
	var processed bool
	err := row.Scan(&processed)
	return processed, err
}

const createFeeHead = `-- name: CreateFeeHead :one

INSERT INTO fee_heads (tenant_id, name, type)
VALUES ($1, $2, $3)
RETURNING id, tenant_id, name, type, created_at
`

type CreateFeeHeadParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Name     string      `json:"name"`
	Type     pgtype.Text `json:"type"`
}


func (q *Queries) CreateFeeHead(ctx context.Context, arg CreateFeeHeadParams) (FeeHead, error) {
	row := q.db.QueryRow(ctx, createFeeHead, arg.TenantID, arg.Name, arg.Type)
	var i FeeHead
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const createFeePlan = `-- name: CreateFeePlan :one
INSERT INTO fee_plans (tenant_id, name, academic_year_id, total_amount)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, name, academic_year_id, total_amount, created_at
`

type CreateFeePlanParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	Name           string      `json:"name"`
	AcademicYearID pgtype.UUID `json:"academic_year_id"`
	TotalAmount    pgtype.Int8 `json:"total_amount"`
}

func (q *Queries) CreateFeePlan(ctx context.Context, arg CreateFeePlanParams) (FeePlan, error) {
	row := q.db.QueryRow(ctx, createFeePlan,
		arg.TenantID,
		arg.Name,
		arg.AcademicYearID,
		arg.TotalAmount,
	)
	var i FeePlan
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.AcademicYearID,
		&i.TotalAmount,
		&i.CreatedAt,
	)
	return i, err
}

const createFeePlanItem = `-- name: CreateFeePlanItem :one
INSERT INTO fee_plan_items (plan_id, head_id, amount, due_date, info)
VALUES ($1, $2, $3, $4, $5)
RETURNING plan_id, head_id, amount, due_date, info
`

type CreateFeePlanItemParams struct {
	PlanID  pgtype.UUID `json:"plan_id"`
	HeadID  pgtype.UUID `json:"head_id"`
	Amount  int64       `json:"amount"`
	DueDate pgtype.Date `json:"due_date"`
	Info    pgtype.Text `json:"info"`
}

func (q *Queries) CreateFeePlanItem(ctx context.Context, arg CreateFeePlanItemParams) (FeePlanItem, error) {
	row := q.db.QueryRow(ctx, createFeePlanItem,
		arg.PlanID,
		arg.HeadID,
		arg.Amount,
		arg.DueDate,
		arg.Info,
	)
	var i FeePlanItem
	err := row.Scan(
		&i.PlanID,
		&i.HeadID,
		&i.Amount,
		&i.DueDate,
		&i.Info,
	)
	return i, err
}

const createPaymentOrder = `-- name: CreatePaymentOrder :one
INSERT INTO payment_orders (
    tenant_id, student_id, amount, mode, status, external_ref
) VALUES (
    $1, $2, $3, $4, 'pending', $5
) RETURNING id, tenant_id, student_id, amount, mode, status, external_ref, created_at
`

type CreatePaymentOrderParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	StudentID   pgtype.UUID `json:"student_id"`
	Amount      int64       `json:"amount"`
	Mode        string      `json:"mode"`
	ExternalRef pgtype.Text `json:"external_ref"`
}

func (q *Queries) CreatePaymentOrder(ctx context.Context, arg CreatePaymentOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, createPaymentOrder,
		arg.TenantID,
		arg.StudentID,
		arg.Amount,
		arg.Mode,
		arg.ExternalRef,
	)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Amount,
		&i.Mode,
		&i.Status,
		&i.ExternalRef,
		&i.CreatedAt,
	)
	return i, err
}

const createReceipt = `-- name: CreateReceipt :one
INSERT INTO receipts (
    tenant_id, receipt_number, student_id, amount_paid, 
    payment_mode, series_id, created_by, transaction_ref
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tenant_id, receipt_number, student_id, amount_paid, payment_mode, status, cancelled_by, cancellation_reason, transaction_ref, created_by, created_at, series_id
`

type CreateReceiptParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ReceiptNumber  string      `json:"receipt_number"`
	StudentID      pgtype.UUID `json:"student_id"`
	AmountPaid     int64       `json:"amount_paid"`
	PaymentMode    string      `json:"payment_mode"`
	SeriesID       pgtype.UUID `json:"series_id"`
	CreatedBy      pgtype.UUID `json:"created_by"`
	TransactionRef pgtype.Text `json:"transaction_ref"`
}

func (q *Queries) CreateReceipt(ctx context.Context, arg CreateReceiptParams) (Receipt, error) {
	row := q.db.QueryRow(ctx, createReceipt,
		arg.TenantID,
		arg.ReceiptNumber,
		arg.StudentID,
		arg.AmountPaid,
		arg.PaymentMode,
		arg.SeriesID,
		arg.CreatedBy,
		arg.TransactionRef,
	)
	var i Receipt
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ReceiptNumber,
		&i.StudentID,
		&i.AmountPaid,
		&i.PaymentMode,
		&i.Status,
		&i.CancelledBy,
		&i.CancellationReason,
		&i.TransactionRef,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.SeriesID,
	)
	return i, err
}

const createReceiptSeries = `-- name: CreateReceiptSeries :one
INSERT INTO receipt_series (tenant_id, branch_id, prefix, current_number, is_active)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, branch_id, prefix, current_number, is_active, created_at, updated_at
`

type CreateReceiptSeriesParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	BranchID      pgtype.UUID `json:"branch_id"`
	Prefix        string      `json:"prefix"`
	CurrentNumber pgtype.Int4 `json:"current_number"`
	IsActive      pgtype.Bool `json:"is_active"`
}

func (q *Queries) CreateReceiptSeries(ctx context.Context, arg CreateReceiptSeriesParams) (ReceiptSeries, error) {
	row := q.db.QueryRow(ctx, createReceiptSeries,
		arg.TenantID,
		arg.BranchID,
		arg.Prefix,
		arg.CurrentNumber,
		arg.IsActive,
	)
	var i ReceiptSeries
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.Prefix,
		&i.CurrentNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRefund = `-- name: CreateRefund :one
INSERT INTO fee_refunds (tenant_id, receipt_id, amount, reason)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, receipt_id, amount, reason, status, decided_by, decided_at, created_at
`

type CreateRefundParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	ReceiptID pgtype.UUID `json:"receipt_id"`
	Amount    int64       `json:"amount"`
	Reason    pgtype.Text `json:"reason"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (FeeRefund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.TenantID,
		arg.ReceiptID,
		arg.Amount,
		arg.Reason,
	)
	var i FeeRefund
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ReceiptID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.DecidedBy,
		&i.DecidedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveSeries = `-- name: GetActiveSeries :one
SELECT id, tenant_id, branch_id, prefix, current_number, is_active, created_at, updated_at FROM receipt_series
WHERE tenant_id = $1 AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetActiveSeries(ctx context.Context, tenantID pgtype.UUID) (ReceiptSeries, error) {
	row := q.db.QueryRow(ctx, getActiveSeries, tenantID)
	var i ReceiptSeries
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.Prefix,
		&i.CurrentNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextReceiptNumber = `-- name: GetNextReceiptNumber :one
UPDATE receipt_series
SET current_number = current_number + 1, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING prefix || (current_number)::text as receipt_number
`

type GetNextReceiptNumberParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetNextReceiptNumber(ctx context.Context, arg GetNextReceiptNumberParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getNextReceiptNumber, arg.ID, arg.TenantID)
	var receipt_number interface{}
	err := row.Scan(&receipt_number)
	return receipt_number, err
}

const getPaymentOrder = `-- name: GetPaymentOrder :one
SELECT id, tenant_id, student_id, amount, mode, status, external_ref, created_at FROM payment_orders
WHERE id = $1 AND tenant_id = $2
`

type GetPaymentOrderParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetPaymentOrder(ctx context.Context, arg GetPaymentOrderParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, getPaymentOrder, arg.ID, arg.TenantID)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Amount,
		&i.Mode,
		&i.Status,
		&i.ExternalRef,
		&i.CreatedAt,
	)
	return i, err
}

const getStudentFeeSummary = `-- name: GetStudentFeeSummary :many
SELECT fpi.plan_id, fpi.head_id, fpi.amount, fpi.due_date, fpi.info, fh.name as head_name
FROM student_fee_plans sfp
JOIN fee_plan_items fpi ON sfp.plan_id = fpi.plan_id
JOIN fee_heads fh ON fpi.head_id = fh.id
WHERE sfp.student_id = $1
`

type GetStudentFeeSummaryRow struct {
	PlanID   pgtype.UUID `json:"plan_id"`
	HeadID   pgtype.UUID `json:"head_id"`
	Amount   int64       `json:"amount"`
	DueDate  pgtype.Date `json:"due_date"`
	Info     pgtype.Text `json:"info"`
	HeadName string      `json:"head_name"`
}

func (q *Queries) GetStudentFeeSummary(ctx context.Context, studentID pgtype.UUID) ([]GetStudentFeeSummaryRow, error) {
	rows, err := q.db.Query(ctx, getStudentFeeSummary, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentFeeSummaryRow
	for rows.Next() {
		var i GetStudentFeeSummaryRow
		if err := rows.Scan(
			&i.PlanID,
			&i.HeadID,
			&i.Amount,
			&i.DueDate,
			&i.Info,
			&i.HeadName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTallyExportData = `-- name: GetTallyExportData :many
SELECT 
    r.receipt_number,
    r.amount_paid,
    r.created_at,
    r.payment_mode,
    s.admission_number,
    s.full_name as student_name,
    tlm.tally_ledger_name
FROM receipts r
JOIN students s ON r.student_id = s.id
LEFT JOIN student_fee_plans sfp ON s.id = sfp.student_id
LEFT JOIN fee_plans fp ON sfp.plan_id = fp.id
LEFT JOIN fee_plan_items fpi ON fp.id = fpi.plan_id
LEFT JOIN tally_ledger_mappings tlm ON fpi.head_id = tlm.fee_head_id AND r.tenant_id = tlm.tenant_id
WHERE r.tenant_id = $1 AND r.created_at BETWEEN $2 AND $3
ORDER BY r.created_at ASC
`

type GetTallyExportDataParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetTallyExportDataRow struct {
	ReceiptNumber   string             `json:"receipt_number"`
	AmountPaid      int64              `json:"amount_paid"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	PaymentMode     string             `json:"payment_mode"`
	AdmissionNumber string             `json:"admission_number"`
	StudentName     string             `json:"student_name"`
	TallyLedgerName pgtype.Text        `json:"tally_ledger_name"`
}

// Simple mapping for demo: using the first head's mapping from the plan
func (q *Queries) GetTallyExportData(ctx context.Context, arg GetTallyExportDataParams) ([]GetTallyExportDataRow, error) {
	rows, err := q.db.Query(ctx, getTallyExportData, arg.TenantID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTallyExportDataRow
	for rows.Next() {
		var i GetTallyExportDataRow
		if err := rows.Scan(
			&i.ReceiptNumber,
			&i.AmountPaid,
			&i.CreatedAt,
			&i.PaymentMode,
			&i.AdmissionNumber,
			&i.StudentName,
			&i.TallyLedgerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeHeads = `-- name: ListFeeHeads :many
SELECT id, tenant_id, name, type, created_at FROM fee_heads WHERE tenant_id = $1
`

func (q *Queries) ListFeeHeads(ctx context.Context, tenantID pgtype.UUID) ([]FeeHead, error) {
	rows, err := q.db.Query(ctx, listFeeHeads, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeeHead
	for rows.Next() {
		var i FeeHead
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLedgerMappings = `-- name: ListLedgerMappings :many
SELECT lm.id, lm.tenant_id, lm.fee_head_id, lm.tally_ledger_name, lm.created_at, fh.name as fee_head_name
FROM tally_ledger_mappings lm
JOIN fee_heads fh ON lm.fee_head_id = fh.id
WHERE lm.tenant_id = $1
`

type ListLedgerMappingsRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	FeeHeadID       pgtype.UUID        `json:"fee_head_id"`
	TallyLedgerName string             `json:"tally_ledger_name"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FeeHeadName     string             `json:"fee_head_name"`
}

func (q *Queries) ListLedgerMappings(ctx context.Context, tenantID pgtype.UUID) ([]ListLedgerMappingsRow, error) {
	rows, err := q.db.Query(ctx, listLedgerMappings, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLedgerMappingsRow
	for rows.Next() {
		var i ListLedgerMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.FeeHeadID,
			&i.TallyLedgerName,
			&i.CreatedAt,
			&i.FeeHeadName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceiptSeries = `-- name: ListReceiptSeries :many
SELECT id, tenant_id, branch_id, prefix, current_number, is_active, created_at, updated_at FROM receipt_series WHERE tenant_id = $1
`

func (q *Queries) ListReceiptSeries(ctx context.Context, tenantID pgtype.UUID) ([]ReceiptSeries, error) {
	rows, err := q.db.Query(ctx, listReceiptSeries, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReceiptSeries
	for rows.Next() {
		var i ReceiptSeries
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.BranchID,
			&i.Prefix,
			&i.CurrentNumber,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStudentReceipts = `-- name: ListStudentReceipts :many
SELECT id, tenant_id, receipt_number, student_id, amount_paid, payment_mode, status, cancelled_by, cancellation_reason, transaction_ref, created_by, created_at, series_id FROM receipts
WHERE student_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
`

type ListStudentReceiptsParams struct {
	StudentID pgtype.UUID `json:"student_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ListStudentReceipts(ctx context.Context, arg ListStudentReceiptsParams) ([]Receipt, error) {
	rows, err := q.db.Query(ctx, listStudentReceipts, arg.StudentID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Receipt
	for rows.Next() {
		var i Receipt
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ReceiptNumber,
			&i.StudentID,
			&i.AmountPaid,
			&i.PaymentMode,
			&i.Status,
			&i.CancelledBy,
			&i.CancellationReason,
			&i.TransactionRef,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.SeriesID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logPaymentEvent = `-- name: LogPaymentEvent :one
INSERT INTO payment_events (tenant_id, gateway_event_id, event_type)
VALUES ($1, $2, $3)
RETURNING id, tenant_id, gateway_event_id, event_type, processed_at
`

type LogPaymentEventParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	GatewayEventID string      `json:"gateway_event_id"`
	EventType      string      `json:"event_type"`
}

func (q *Queries) LogPaymentEvent(ctx context.Context, arg LogPaymentEventParams) (PaymentEvent, error) {
	row := q.db.QueryRow(ctx, logPaymentEvent, arg.TenantID, arg.GatewayEventID, arg.EventType)
	var i PaymentEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.GatewayEventID,
		&i.EventType,
		&i.ProcessedAt,
	)
	return i, err
}

const updatePaymentOrderStatus = `-- name: UpdatePaymentOrderStatus :one
UPDATE payment_orders
SET status = $3, external_ref = $4
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, student_id, amount, mode, status, external_ref, created_at
`

type UpdatePaymentOrderStatusParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Status      pgtype.Text `json:"status"`
	ExternalRef pgtype.Text `json:"external_ref"`
}

func (q *Queries) UpdatePaymentOrderStatus(ctx context.Context, arg UpdatePaymentOrderStatusParams) (PaymentOrder, error) {
	row := q.db.QueryRow(ctx, updatePaymentOrderStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ExternalRef,
	)
	var i PaymentOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.StudentID,
		&i.Amount,
		&i.Mode,
		&i.Status,
		&i.ExternalRef,
		&i.CreatedAt,
	)
	return i, err
}

const updateReceiptSeries = `-- name: UpdateReceiptSeries :one
UPDATE receipt_series
SET is_active = $3, updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, branch_id, prefix, current_number, is_active, created_at, updated_at
`

type UpdateReceiptSeriesParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateReceiptSeries(ctx context.Context, arg UpdateReceiptSeriesParams) (ReceiptSeries, error) {
	row := q.db.QueryRow(ctx, updateReceiptSeries, arg.ID, arg.TenantID, arg.IsActive)
	var i ReceiptSeries
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BranchID,
		&i.Prefix,
		&i.CurrentNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertLedgerMapping = `-- name: UpsertLedgerMapping :one
INSERT INTO tally_ledger_mappings (tenant_id, fee_head_id, tally_ledger_name)
VALUES ($1, $2, $3)
ON CONFLICT (tenant_id, fee_head_id) DO UPDATE
SET tally_ledger_name = EXCLUDED.tally_ledger_name
RETURNING id, tenant_id, fee_head_id, tally_ledger_name, created_at
`

type UpsertLedgerMappingParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	FeeHeadID       pgtype.UUID `json:"fee_head_id"`
	TallyLedgerName string      `json:"tally_ledger_name"`
}

func (q *Queries) UpsertLedgerMapping(ctx context.Context, arg UpsertLedgerMappingParams) (TallyLedgerMapping, error) {
	row := q.db.QueryRow(ctx, upsertLedgerMapping, arg.TenantID, arg.FeeHeadID, arg.TallyLedgerName)
	var i TallyLedgerMapping
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FeeHeadID,
		&i.TallyLedgerName,
		&i.CreatedAt,
	)
	return i, err
}
