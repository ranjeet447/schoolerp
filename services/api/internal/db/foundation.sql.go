// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: foundation.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkLock = `-- name: CheckLock :one
SELECT EXISTS(
    SELECT 1 FROM locks
    WHERE tenant_id = $1 AND module = $2 AND (resource_id = $3 OR resource_id IS NULL)
) as is_locked
`

type CheckLockParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	Module     string      `json:"module"`
	ResourceID pgtype.UUID `json:"resource_id"`
}

func (q *Queries) CheckLock(ctx context.Context, arg CheckLockParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkLock, arg.TenantID, arg.Module, arg.ResourceID)
	var is_locked bool
	err := row.Scan(&is_locked)
	return is_locked, err
}

const createApprovalRequest = `-- name: CreateApprovalRequest :one
INSERT INTO approval_requests (tenant_id, requester_id, module, action, resource_id, payload)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, requester_id, module, action, resource_id, payload, status, reason, created_at, updated_at
`

type CreateApprovalRequestParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	RequesterID pgtype.UUID `json:"requester_id"`
	Module      string      `json:"module"`
	Action      string      `json:"action"`
	ResourceID  pgtype.UUID `json:"resource_id"`
	Payload     []byte      `json:"payload"`
}

// Approvals
func (q *Queries) CreateApprovalRequest(ctx context.Context, arg CreateApprovalRequestParams) (ApprovalRequest, error) {
	row := q.db.QueryRow(ctx, createApprovalRequest,
		arg.TenantID,
		arg.RequesterID,
		arg.Module,
		arg.Action,
		arg.ResourceID,
		arg.Payload,
	)
	var i ApprovalRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RequesterID,
		&i.Module,
		&i.Action,
		&i.ResourceID,
		&i.Payload,
		&i.Status,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLock = `-- name: CreateLock :one
INSERT INTO locks (tenant_id, module, resource_id, locked_by, reason)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, module, resource_id, locked_by, reason, created_at, updated_at
`

type CreateLockParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	Module     string      `json:"module"`
	ResourceID pgtype.UUID `json:"resource_id"`
	LockedBy   pgtype.UUID `json:"locked_by"`
	Reason     pgtype.Text `json:"reason"`
}

// Locks
func (q *Queries) CreateLock(ctx context.Context, arg CreateLockParams) (Lock, error) {
	row := q.db.QueryRow(ctx, createLock,
		arg.TenantID,
		arg.Module,
		arg.ResourceID,
		arg.LockedBy,
		arg.Reason,
	)
	var i Lock
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Module,
		&i.ResourceID,
		&i.LockedBy,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLock = `-- name: DeleteLock :exec
DELETE FROM locks
WHERE tenant_id = $1 AND module = $2 AND resource_id = $3
`

type DeleteLockParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	Module     string      `json:"module"`
	ResourceID pgtype.UUID `json:"resource_id"`
}

func (q *Queries) DeleteLock(ctx context.Context, arg DeleteLockParams) error {
	_, err := q.db.Exec(ctx, deleteLock, arg.TenantID, arg.Module, arg.ResourceID)
	return err
}

const getApprovalRequest = `-- name: GetApprovalRequest :one
SELECT id, tenant_id, requester_id, module, action, resource_id, payload, status, reason, created_at, updated_at FROM approval_requests
WHERE id = $1
`

func (q *Queries) GetApprovalRequest(ctx context.Context, id pgtype.UUID) (ApprovalRequest, error) {
	row := q.db.QueryRow(ctx, getApprovalRequest, id)
	var i ApprovalRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RequesterID,
		&i.Module,
		&i.Action,
		&i.ResourceID,
		&i.Payload,
		&i.Status,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPolicy = `-- name: GetPolicy :one

SELECT id, tenant_id, module, action, logic, is_active, created_at, updated_at FROM policies
WHERE tenant_id = $1 AND module = $2 AND action = $3 AND is_active = TRUE
`

type GetPolicyParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Module   string      `json:"module"`
	Action   string      `json:"action"`
}

// foundation.sql
// Policies
func (q *Queries) GetPolicy(ctx context.Context, arg GetPolicyParams) (Policy, error) {
	row := q.db.QueryRow(ctx, getPolicy, arg.TenantID, arg.Module, arg.Action)
	var i Policy
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Module,
		&i.Action,
		&i.Logic,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPendingApprovals = `-- name: ListPendingApprovals :many
SELECT id, tenant_id, requester_id, module, action, resource_id, payload, status, reason, created_at, updated_at FROM approval_requests
WHERE tenant_id = $1 AND status = 'pending'
`

func (q *Queries) ListPendingApprovals(ctx context.Context, tenantID pgtype.UUID) ([]ApprovalRequest, error) {
	rows, err := q.db.Query(ctx, listPendingApprovals, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApprovalRequest
	for rows.Next() {
		var i ApprovalRequest
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RequesterID,
			&i.Module,
			&i.Action,
			&i.ResourceID,
			&i.Payload,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPolicies = `-- name: ListPolicies :many
SELECT id, tenant_id, module, action, logic, is_active, created_at, updated_at FROM policies
WHERE tenant_id = $1
`

func (q *Queries) ListPolicies(ctx context.Context, tenantID pgtype.UUID) ([]Policy, error) {
	rows, err := q.db.Query(ctx, listPolicies, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Policy
	for rows.Next() {
		var i Policy
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Module,
			&i.Action,
			&i.Logic,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApprovalStatus = `-- name: UpdateApprovalStatus :one
UPDATE approval_requests
SET status = $2, reason = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, tenant_id, requester_id, module, action, resource_id, payload, status, reason, created_at, updated_at
`

type UpdateApprovalStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status pgtype.Text `json:"status"`
	Reason pgtype.Text `json:"reason"`
}

func (q *Queries) UpdateApprovalStatus(ctx context.Context, arg UpdateApprovalStatusParams) (ApprovalRequest, error) {
	row := q.db.QueryRow(ctx, updateApprovalStatus, arg.ID, arg.Status, arg.Reason)
	var i ApprovalRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RequesterID,
		&i.Module,
		&i.Action,
		&i.ResourceID,
		&i.Payload,
		&i.Status,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrCreatePolicy = `-- name: UpdateOrCreatePolicy :one
INSERT INTO policies (tenant_id, module, action, logic, is_active)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (tenant_id, module, action) DO UPDATE
SET logic = $4, is_active = $5, updated_at = NOW()
RETURNING id, tenant_id, module, action, logic, is_active, created_at, updated_at
`

type UpdateOrCreatePolicyParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Module   string      `json:"module"`
	Action   string      `json:"action"`
	Logic    []byte      `json:"logic"`
	IsActive pgtype.Bool `json:"is_active"`
}

func (q *Queries) UpdateOrCreatePolicy(ctx context.Context, arg UpdateOrCreatePolicyParams) (Policy, error) {
	row := q.db.QueryRow(ctx, updateOrCreatePolicy,
		arg.TenantID,
		arg.Module,
		arg.Action,
		arg.Logic,
		arg.IsActive,
	)
	var i Policy
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Module,
		&i.Action,
		&i.Logic,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
