// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: kb.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createKBChunk = `-- name: CreateKBChunk :one
INSERT INTO kb_chunks (
    tenant_id, document_id, chunk_index, content, tsv
) VALUES (
    $1, $2, $3, $4, to_tsvector('simple', $4)
) RETURNING id, tenant_id, document_id, chunk_index, content, tsv, created_at
`

type CreateKBChunkParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	DocumentID pgtype.UUID `json:"document_id"`
	ChunkIndex int32       `json:"chunk_index"`
	Content    string      `json:"content"`
}

func (q *Queries) CreateKBChunk(ctx context.Context, arg CreateKBChunkParams) (KbChunk, error) {
	row := q.db.QueryRow(ctx, createKBChunk,
		arg.TenantID,
		arg.DocumentID,
		arg.ChunkIndex,
		arg.Content,
	)
	var i KbChunk
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.DocumentID,
		&i.ChunkIndex,
		&i.Content,
		&i.Tsv,
		&i.CreatedAt,
	)
	return i, err
}

const createKBDocument = `-- name: CreateKBDocument :one
INSERT INTO kb_documents (
    tenant_id, title, category, tags, visibility, status, content_text, created_by, updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $8
) RETURNING id, tenant_id, title, category, tags, visibility, status, content_text, created_by, updated_by, created_at, updated_at, deleted_at
`

type CreateKBDocumentParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Title       string      `json:"title"`
	Category    pgtype.Text `json:"category"`
	Tags        []string    `json:"tags"`
	Visibility  string      `json:"visibility"`
	Status      string      `json:"status"`
	ContentText string      `json:"content_text"`
	CreatedBy   pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateKBDocument(ctx context.Context, arg CreateKBDocumentParams) (KbDocument, error) {
	row := q.db.QueryRow(ctx, createKBDocument,
		arg.TenantID,
		arg.Title,
		arg.Category,
		arg.Tags,
		arg.Visibility,
		arg.Status,
		arg.ContentText,
		arg.CreatedBy,
	)
	var i KbDocument
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Category,
		&i.Tags,
		&i.Visibility,
		&i.Status,
		&i.ContentText,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteKBChunksByDocument = `-- name: DeleteKBChunksByDocument :exec
DELETE FROM kb_chunks
WHERE tenant_id = $1 AND document_id = $2
`

type DeleteKBChunksByDocumentParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	DocumentID pgtype.UUID `json:"document_id"`
}

func (q *Queries) DeleteKBChunksByDocument(ctx context.Context, arg DeleteKBChunksByDocumentParams) error {
	_, err := q.db.Exec(ctx, deleteKBChunksByDocument, arg.TenantID, arg.DocumentID)
	return err
}

const getKBDocument = `-- name: GetKBDocument :one
SELECT id, tenant_id, title, category, tags, visibility, status, content_text, created_by, updated_by, created_at, updated_at, deleted_at FROM kb_documents
WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL
`

type GetKBDocumentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetKBDocument(ctx context.Context, arg GetKBDocumentParams) (KbDocument, error) {
	row := q.db.QueryRow(ctx, getKBDocument, arg.ID, arg.TenantID)
	var i KbDocument
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Category,
		&i.Tags,
		&i.Visibility,
		&i.Status,
		&i.ContentText,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTenantKBSettings = `-- name: GetTenantKBSettings :one
SELECT tenant_id, enabled, allowed_roles, allow_parents, allow_students, created_at, updated_at FROM tenant_kb_settings
WHERE tenant_id = $1
`

func (q *Queries) GetTenantKBSettings(ctx context.Context, tenantID pgtype.UUID) (TenantKbSetting, error) {
	row := q.db.QueryRow(ctx, getTenantKBSettings, tenantID)
	var i TenantKbSetting
	err := row.Scan(
		&i.TenantID,
		&i.Enabled,
		&i.AllowedRoles,
		&i.AllowParents,
		&i.AllowStudents,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listKBCategories = `-- name: ListKBCategories :many
SELECT DISTINCT category
FROM kb_documents
WHERE tenant_id = $1
  AND deleted_at IS NULL
  AND status = 'published'
  AND category IS NOT NULL
  AND category <> ''
  AND (array_length($2::text[], 1) IS NULL OR visibility = ANY($2::text[]))
ORDER BY category ASC
`

type ListKBCategoriesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  []string    `json:"column_2"`
}

func (q *Queries) ListKBCategories(ctx context.Context, arg ListKBCategoriesParams) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listKBCategories, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var category pgtype.Text
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKBChunksByDocument = `-- name: ListKBChunksByDocument :many
SELECT id, tenant_id, document_id, chunk_index, content, tsv, created_at FROM kb_chunks
WHERE tenant_id = $1 AND document_id = $2
ORDER BY chunk_index ASC
`

type ListKBChunksByDocumentParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	DocumentID pgtype.UUID `json:"document_id"`
}

func (q *Queries) ListKBChunksByDocument(ctx context.Context, arg ListKBChunksByDocumentParams) ([]KbChunk, error) {
	rows, err := q.db.Query(ctx, listKBChunksByDocument, arg.TenantID, arg.DocumentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []KbChunk
	for rows.Next() {
		var i KbChunk
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.DocumentID,
			&i.ChunkIndex,
			&i.Content,
			&i.Tsv,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKBDocuments = `-- name: ListKBDocuments :many
SELECT id, tenant_id, title, category, tags, visibility, status, content_text, created_by, updated_by, created_at, updated_at, deleted_at FROM kb_documents
WHERE tenant_id = $1
  AND deleted_at IS NULL
  AND ($2::text = '' OR status = $2)
  AND ($3::text = '' OR visibility = $3)
  AND ($4::text = '' OR category = $4)
  AND ($5::text = '' OR title ILIKE '%' || $5 || '%' OR content_text ILIKE '%' || $5 || '%')
ORDER BY updated_at DESC
LIMIT $6 OFFSET $7
`

type ListKBDocumentsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  string      `json:"column_2"`
	Column3  string      `json:"column_3"`
	Column4  string      `json:"column_4"`
	Column5  string      `json:"column_5"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListKBDocuments(ctx context.Context, arg ListKBDocumentsParams) ([]KbDocument, error) {
	rows, err := q.db.Query(ctx, listKBDocuments,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []KbDocument
	for rows.Next() {
		var i KbDocument
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Category,
			&i.Tags,
			&i.Visibility,
			&i.Status,
			&i.ContentText,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKBTags = `-- name: ListKBTags :many
SELECT DISTINCT tag::text
FROM kb_documents d
CROSS JOIN LATERAL unnest(d.tags) AS tag
WHERE tenant_id = $1
  AND deleted_at IS NULL
  AND status = 'published'
  AND tags IS NOT NULL
  AND array_length(tags, 1) > 0
  AND (array_length($2::text[], 1) IS NULL OR visibility = ANY($2::text[]))
ORDER BY tag ASC
`

type ListKBTagsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  []string    `json:"column_2"`
}

func (q *Queries) ListKBTags(ctx context.Context, arg ListKBTagsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listKBTags, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchKBChunksFTSOnly = `-- name: SearchKBChunksFTSOnly :many
WITH q AS (
  SELECT plainto_tsquery('simple', $2::text) AS tsq
)
SELECT
  d.id AS document_id,
  d.title,
  d.category,
  d.tags,
  d.visibility,
  d.status,
  d.updated_at,
  c.id AS chunk_id,
  c.chunk_index,
  c.content AS raw_chunk_content,
  ts_headline(
    'simple',
    c.content,
    q.tsq,
    'StartSel=<mark>,StopSel=</mark>,MaxWords=35,MinWords=10,ShortWord=2,HighlightAll=FALSE,MaxFragments=2,FragmentDelimiter= ... '
  )::text AS snippet_html,
  (
    ts_rank_cd(c.tsv, q.tsq) +
    LEAST(0.05, GREATEST(0::double precision, 0.05 - (EXTRACT(EPOCH FROM (NOW() - d.updated_at)) / 86400.0 / 365.0)))
  )::double precision AS score
FROM kb_chunks c
JOIN kb_documents d ON d.id = c.document_id
CROSS JOIN q
WHERE c.tenant_id = $1
  AND d.tenant_id = $1
  AND d.deleted_at IS NULL
  AND d.status = $6
  AND (array_length($7::text[], 1) IS NULL OR d.visibility = ANY($7::text[]))
  AND ($3::text = '' OR d.category = $3)
  AND (array_length($4::text[], 1) IS NULL OR d.tags && $4::text[])
  AND ($5::text = '' OR d.visibility = $5)
  AND c.tsv @@ q.tsq
ORDER BY score DESC, d.updated_at DESC
LIMIT $8
`

type SearchKBChunksFTSOnlyParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  string      `json:"column_2"`
	Column3  string      `json:"column_3"`
	Column4  []string    `json:"column_4"`
	Column5  string      `json:"column_5"`
	Status   string      `json:"status"`
	Column7  []string    `json:"column_7"`
	Limit    int32       `json:"limit"`
}

type SearchKBChunksFTSOnlyRow struct {
	DocumentID      pgtype.UUID        `json:"document_id"`
	Title           string             `json:"title"`
	Category        pgtype.Text        `json:"category"`
	Tags            []string           `json:"tags"`
	Visibility      string             `json:"visibility"`
	Status          string             `json:"status"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ChunkID         pgtype.UUID        `json:"chunk_id"`
	ChunkIndex      int32              `json:"chunk_index"`
	RawChunkContent string             `json:"raw_chunk_content"`
	SnippetHtml     string             `json:"snippet_html"`
	Score           float64            `json:"score"`
}

func (q *Queries) SearchKBChunksFTSOnly(ctx context.Context, arg SearchKBChunksFTSOnlyParams) ([]SearchKBChunksFTSOnlyRow, error) {
	rows, err := q.db.Query(ctx, searchKBChunksFTSOnly,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Status,
		arg.Column7,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchKBChunksFTSOnlyRow
	for rows.Next() {
		var i SearchKBChunksFTSOnlyRow
		if err := rows.Scan(
			&i.DocumentID,
			&i.Title,
			&i.Category,
			&i.Tags,
			&i.Visibility,
			&i.Status,
			&i.UpdatedAt,
			&i.ChunkID,
			&i.ChunkIndex,
			&i.RawChunkContent,
			&i.SnippetHtml,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchKBChunksWithTrgm = `-- name: SearchKBChunksWithTrgm :many
WITH q AS (
  SELECT plainto_tsquery('simple', $2::text) AS tsq
)
SELECT
  d.id AS document_id,
  d.title,
  d.category,
  d.tags,
  d.visibility,
  d.status,
  d.updated_at,
  c.id AS chunk_id,
  c.chunk_index,
  c.content AS raw_chunk_content,
  ts_headline(
    'simple',
    c.content,
    q.tsq,
    'StartSel=<mark>,StopSel=</mark>,MaxWords=35,MinWords=10,ShortWord=2,HighlightAll=FALSE,MaxFragments=2,FragmentDelimiter= ... '
  )::text AS snippet_html,
  (
    (0.7 * ts_rank_cd(c.tsv, q.tsq)) +
    (0.3 * similarity(c.content, $2::text)) +
    LEAST(0.05, GREATEST(0::double precision, 0.05 - (EXTRACT(EPOCH FROM (NOW() - d.updated_at)) / 86400.0 / 365.0)))
  )::double precision AS score
FROM kb_chunks c
JOIN kb_documents d ON d.id = c.document_id
CROSS JOIN q
WHERE c.tenant_id = $1
  AND d.tenant_id = $1
  AND d.deleted_at IS NULL
  AND d.status = $6
  AND (array_length($7::text[], 1) IS NULL OR d.visibility = ANY($7::text[]))
  AND ($3::text = '' OR d.category = $3)
  AND (array_length($4::text[], 1) IS NULL OR d.tags && $4::text[])
  AND ($5::text = '' OR d.visibility = $5)
  AND (
    c.tsv @@ q.tsq
    OR similarity(c.content, $2::text) > 0.08
  )
ORDER BY score DESC, d.updated_at DESC
LIMIT $8
`

type SearchKBChunksWithTrgmParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  string      `json:"column_2"`
	Column3  string      `json:"column_3"`
	Column4  []string    `json:"column_4"`
	Column5  string      `json:"column_5"`
	Status   string      `json:"status"`
	Column7  []string    `json:"column_7"`
	Limit    int32       `json:"limit"`
}

type SearchKBChunksWithTrgmRow struct {
	DocumentID      pgtype.UUID        `json:"document_id"`
	Title           string             `json:"title"`
	Category        pgtype.Text        `json:"category"`
	Tags            []string           `json:"tags"`
	Visibility      string             `json:"visibility"`
	Status          string             `json:"status"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ChunkID         pgtype.UUID        `json:"chunk_id"`
	ChunkIndex      int32              `json:"chunk_index"`
	RawChunkContent string             `json:"raw_chunk_content"`
	SnippetHtml     string             `json:"snippet_html"`
	Score           float64            `json:"score"`
}

func (q *Queries) SearchKBChunksWithTrgm(ctx context.Context, arg SearchKBChunksWithTrgmParams) ([]SearchKBChunksWithTrgmRow, error) {
	rows, err := q.db.Query(ctx, searchKBChunksWithTrgm,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Status,
		arg.Column7,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchKBChunksWithTrgmRow
	for rows.Next() {
		var i SearchKBChunksWithTrgmRow
		if err := rows.Scan(
			&i.DocumentID,
			&i.Title,
			&i.Category,
			&i.Tags,
			&i.Visibility,
			&i.Status,
			&i.UpdatedAt,
			&i.ChunkID,
			&i.ChunkIndex,
			&i.RawChunkContent,
			&i.SnippetHtml,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteKBDocument = `-- name: SoftDeleteKBDocument :exec
UPDATE kb_documents
SET deleted_at = NOW(), updated_at = NOW(), updated_by = $3
WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL
`

type SoftDeleteKBDocumentParams struct {
	ID        pgtype.UUID `json:"id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

func (q *Queries) SoftDeleteKBDocument(ctx context.Context, arg SoftDeleteKBDocumentParams) error {
	_, err := q.db.Exec(ctx, softDeleteKBDocument, arg.ID, arg.TenantID, arg.UpdatedBy)
	return err
}

const updateKBDocument = `-- name: UpdateKBDocument :one
UPDATE kb_documents
SET
    title = $3,
    category = $4,
    tags = $5,
    visibility = $6,
    status = $7,
    content_text = $8,
    updated_by = $9,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL
RETURNING id, tenant_id, title, category, tags, visibility, status, content_text, created_by, updated_by, created_at, updated_at, deleted_at
`

type UpdateKBDocumentParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Title       string      `json:"title"`
	Category    pgtype.Text `json:"category"`
	Tags        []string    `json:"tags"`
	Visibility  string      `json:"visibility"`
	Status      string      `json:"status"`
	ContentText string      `json:"content_text"`
	UpdatedBy   pgtype.UUID `json:"updated_by"`
}

func (q *Queries) UpdateKBDocument(ctx context.Context, arg UpdateKBDocumentParams) (KbDocument, error) {
	row := q.db.QueryRow(ctx, updateKBDocument,
		arg.ID,
		arg.TenantID,
		arg.Title,
		arg.Category,
		arg.Tags,
		arg.Visibility,
		arg.Status,
		arg.ContentText,
		arg.UpdatedBy,
	)
	var i KbDocument
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Category,
		&i.Tags,
		&i.Visibility,
		&i.Status,
		&i.ContentText,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const upsertTenantKBSettings = `-- name: UpsertTenantKBSettings :one
INSERT INTO tenant_kb_settings (
    tenant_id, enabled, allowed_roles, allow_parents, allow_students, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW()
)
ON CONFLICT (tenant_id) DO UPDATE
SET
    enabled = EXCLUDED.enabled,
    allowed_roles = EXCLUDED.allowed_roles,
    allow_parents = EXCLUDED.allow_parents,
    allow_students = EXCLUDED.allow_students,
    updated_at = NOW()
RETURNING tenant_id, enabled, allowed_roles, allow_parents, allow_students, created_at, updated_at
`

type UpsertTenantKBSettingsParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	Enabled       bool        `json:"enabled"`
	AllowedRoles  []string    `json:"allowed_roles"`
	AllowParents  bool        `json:"allow_parents"`
	AllowStudents bool        `json:"allow_students"`
}

func (q *Queries) UpsertTenantKBSettings(ctx context.Context, arg UpsertTenantKBSettingsParams) (TenantKbSetting, error) {
	row := q.db.QueryRow(ctx, upsertTenantKBSettings,
		arg.TenantID,
		arg.Enabled,
		arg.AllowedRoles,
		arg.AllowParents,
		arg.AllowStudents,
	)
	var i TenantKbSetting
	err := row.Scan(
		&i.TenantID,
		&i.Enabled,
		&i.AllowedRoles,
		&i.AllowParents,
		&i.AllowStudents,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
